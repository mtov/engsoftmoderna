<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Chapter 3: Requirements ‚Äì Software Engineering: A Modern Approach</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <meta name="robots" content="noindex">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p> <h5>Disclaimer: This chapter is a beta version subjected to proofreading. </h5> </p>

<p> <h5> All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>. </h5> </p>
<header id="title-block-header">
<h1 class="title">Software Engineering: A Modern Approach</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="2" id="requirements"><span
class="header-section-number">2</span> Requirements <a
href="#requirements" class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em><q>The hardest single part of building a software system is
deciding precisely what to build.</q></em> ‚Äì Frederick Brooks</p>
</blockquote>
<p> This chapter begins with a presentation on the importance of
software requirements and their different types (Section 3.1). Next, we
characterize and present the activities that comprise what we call
Requirements Engineering (Section 3.2). The next four sections (Sections
3.3 to 3.6) present a variety of techniques and documents used for
specification and validation of requirements. Section 3.3 focuses on
user stories which are the principal tools for defining requirements in
agile methods. Following that, Section 3.4 elaborates on use cases which
are more detailed documents for expressing requirements. In Section 3.5,
we explore the concept of Minimum Viable Product (MVP), a popular
instrument nowadays for identifying and validating requirements. To wrap
up, Section 3.6 provides insights on A/B testing, a common practice for
validating and selecting the requirements of software products.</p>
<h2 data-number="2.1" id="introduction"><span
class="header-section-number">2.1</span> Introduction <a
href="#introduction" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> <strong>Requirements</strong> define what a system should do and the
constraints under which it should operate. <q>What a system should
do</q> or its functions fall under <strong>Functional
Requirements</strong>. On the other hand, the constraints part is
described by <strong>Non-Functional Requirements</strong>.</p>
<p> To better illustrate the dichotomy between these two types of
requirements, let‚Äôs revisit the home-banking system example from Chapter
1. For such a system, functional requirements include features like
reporting the balance and statement of an account, processing transfers
between accounts, executing bank slip payments, canceling debit cards,
among others. In contrast, non-functional requirements are tied to the
quality attributes of the system, including performance, availability,
security, portability, privacy, memory and disk usage, and more.
Essentially, non-functional requirements refer to operational
constraints. For example, it is not enough for our home-banking system
to provide all the functionalities required by the bank. It also needs
to have 99.9% availability‚Äîwhich thus acts as a constraint on its
operation.</p>
<p> As Fredrick Brooks emphasizes in the opening quote of this chapter,
requirements definition is a critical stage in software development
processes. For example, it is pointless to have a system with the best
design, implemented in a modern programming language, using the best
development process, with high test coverage if it does not meet the
needs of the users. Indeed, incorrectly specified or missing
requirements can result in significant costs. The system, after being
fully developed, might require major rework to fix these problems. In
the worst case scenario, it might be rejected by users for not
addressing their needs.</p>
<p>Functional requirements are frequently specified in natural language.
Conversely, non-functional requirements are quantitatively specified
using metrics, as illustrated in the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Non-Functional Requirement</strong></th>
<th><strong>Metric</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Performance</td>
<td>Transactions per second, response time, latency, throughput</td>
</tr>
<tr class="even">
<td>Space</td>
<td>Disk usage, RAM, cache usage</td>
</tr>
<tr class="odd">
<td>Reliability</td>
<td>% of availability, Mean Time Between Failures (MTBF)</td>
</tr>
<tr class="even">
<td>Robustness</td>
<td>Time to recover the system after a failure (MTTR); probability of
data loss after a failure</td>
</tr>
<tr class="odd">
<td>Usability</td>
<td>User training time</td>
</tr>
<tr class="even">
<td>Portability</td>
<td>% of portable lines of code</td>
</tr>
</tbody>
</table>
<p>Using metrics for non-functional requirements avoid nebulous
specifications like <q>the system should be fast and have high
availability</q>. Instead, it is recommended to specify, for example,
that the system should ensure 99.99% availability and 99% of the
transactions conducted in any 5-minute window should have a maximum
response time of 1 second.</p>
<p> Some authors, such as Ian Sommerville (<a
href="https://dl.acm.org/doi/book/10.5555/2851535">link</a>), also
divide requirements into <strong>user requirements</strong> and
<strong>system requirements</strong>. User requirements are high-level,
non-technical, and usually written by users in natural language.
Conversely, system requirements are more technical, precise and defined
by the developers. Oftentimes, a single user requirement expands into a
set of system requirements. As an example, in a banking system, a user
requirement like <q>the system should allow funds transfer to another
bank‚Äôs checking account via wire transfers</q> would result in system
requirements specifying the detailed protocol that should be used for
such transactions. Essentially, user requirements are closer to the
problem while system requirements lean towards the solution.</p>
<h2 data-number="2.2" id="requirements-engineering"><span
class="header-section-number">2.2</span> Requirements Engineering <a
href="#requirements-engineering" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> <strong>Requirements Engineering</strong> refers to activities such
as the identification, analysis, specification, and maintenance of a
system‚Äôs requirements. The term engineering is used to emphasize that
these activities should be performed systematically throughout a
system‚Äôs lifecycle, using only well-defined techniques whenever
possible.</p>
<p> The process of identifying, discovering, and understanding a
system‚Äôs requirements is termed <strong>Requirements
Elicitation</strong>. Elicitation, in this context, implies drawing out
the main requirements of the system from discussions and interactions
between the system‚Äôs developers and its stakeholders.</p>
<p>We can use various techniques for requirements elicitation, including
conducting stakeholder interviews, issuing questionnaires, reviewing
organizational documents, organizing user workshops, creating
prototypes, and analyzing usage scenarios. Some elicitation techniques
also rely on ethnographic studies. Ethnography, a term whose roots trace
back to Anthropology, refers to studying a culture in its natural
environment (<em>ethnos</em>, in Greek, means people or culture). For
instance, to study a newly discovered indigenous tribe in Amazon, an
anthropologist might move to the tribe‚Äôs location and spend months
living amongst them and understanding their habits, customs, language,
etc. Similarly, in the context of Requirements Engineering, ethnography
is a technique of requirements elicitation that recommends the developer
integrate into the work environment of the stakeholders and
observe‚Äîtypically for several days‚Äìhow they perform their tasks. Note
that this observation is silent, meaning that the developer should not
interfere with or express personal views about the observed tasks and
events.</p>
<p>Once requirements are elicited, they should be (1) documented, (2)
checked, validated, and (3) prioritized.</p>
<p>In Agile development, requirements are documented through simplified
<strong>user stories</strong> as previously discussed in Chapter 2.
However, in some projects, a <strong>Requirements Specification
Document</strong> might be necessary. This document elaborates all
requirements of the software to be built‚Äî including functional and
non-functional requirements‚Äî normally in natural language. In the 90s,
the <strong>IEEE 830 Standard</strong>, a standard for requirements
specification documents, was proposed. This standard was suggested
within the context of Waterfall-based models, which, as we studied in
Chapter 2, involves a lengthy phase of requirements gathering. The main
sections of the IEEE 830 standard are illustrated in the next
figure.</p>
<figure>
<img src="figs/cap3/ieee-830-standard.svg" style="width:70.0%"
alt="IEEE 830 standard for requirement specification documents" />
<figcaption aria-hidden="true">IEEE 830 standard for requirement
specification documents</figcaption>
</figure>
</div>
</div>
</div>

<footer>
All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>.
</footer>
</body>
</html>
