<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Chapter 3: Requirements ‚Äì Software Engineering: A Modern Approach</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <meta name="robots" content="noindex">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p> <h5>Disclaimer: This chapter is a beta version subjected to proofreading. </h5> </p>

<p> <h5> All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>. </h5> </p>
<header id="title-block-header">
<h1 class="title">Software Engineering: A Modern Approach</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="2" id="requirements"><span
class="header-section-number">2</span> Requirements <a
href="#requirements" class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em><q>The hardest single part of building a software system is
deciding precisely what to build.</q></em> ‚Äì Frederick Brooks</p>
</blockquote>
<p> This chapter begins with a presentation on the importance of
software requirements and their different types (Section 3.1). Next, we
characterize and present the activities that comprise what we call
Requirements Engineering (Section 3.2). The next four sections (Sections
3.3 to 3.6) present a variety of techniques and documents used for
specification and validation of requirements. Section 3.3 focuses on
user stories which are the principal tools for defining requirements in
agile methods. Following that, Section 3.4 elaborates on use cases which
are more detailed documents for expressing requirements. In Section 3.5,
we explore the concept of Minimum Viable Product (MVP), a popular
instrument nowadays for identifying and validating requirements. To wrap
up, Section 3.6 provides insights on A/B testing, a common practice for
validating and selecting the requirements of software products.</p>
<h2 data-number="2.1" id="introduction"><span
class="header-section-number">2.1</span> Introduction <a
href="#introduction" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> <strong>Requirements</strong> define what a system should do and the
constraints under which it should operate. <q>What a system should
do</q> or its functions fall under <strong>Functional
Requirements</strong>. On the other hand, the constraints part is
described by <strong>Non-Functional Requirements</strong>.</p>
<p> To better illustrate the dichotomy between these two types of
requirements, let‚Äôs revisit the home-banking system example from Chapter
1. For such a system, functional requirements include features like
reporting the balance and statement of an account, processing transfers
between accounts, executing bank slip payments, canceling debit cards,
among others. In contrast, non-functional requirements are tied to the
quality attributes of the system, including performance, availability,
security, portability, privacy, memory and disk usage, and more.
Essentially, non-functional requirements refer to operational
constraints. For example, it is not enough for our home-banking system
to provide all the functionalities required by the bank. It also needs
to have 99.9% availability‚Äîwhich thus acts as a constraint on its
operation.</p>
<p> As Fredrick Brooks emphasizes in the opening quote of this chapter,
requirements definition is a critical stage in software development
processes. For example, it is pointless to have a system with the best
design, implemented in a modern programming language, using the best
development process, with high test coverage if it does not meet the
needs of the users. Indeed, incorrectly specified or missing
requirements can result in significant costs. The system, after being
fully developed, might require major rework to fix these problems. In
the worst case scenario, it might be rejected by users for not
addressing their needs.</p>
<p>Functional requirements are frequently specified in natural language.
Conversely, non-functional requirements are quantitatively specified
using metrics, as illustrated in the following table:</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Non-Functional Requirement</strong></th>
<th><strong>Metric</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Performance</td>
<td>Transactions per second, response time, latency, throughput</td>
</tr>
<tr class="even">
<td>Space</td>
<td>Disk usage, RAM, cache usage</td>
</tr>
<tr class="odd">
<td>Reliability</td>
<td>% of availability, Mean Time Between Failures (MTBF)</td>
</tr>
<tr class="even">
<td>Robustness</td>
<td>Time to recover the system after a failure (MTTR); probability of
data loss after a failure</td>
</tr>
<tr class="odd">
<td>Usability</td>
<td>User training time</td>
</tr>
<tr class="even">
<td>Portability</td>
<td>% of portable lines of code</td>
</tr>
</tbody>
</table>
<p>Using metrics for non-functional requirements avoid nebulous
specifications like <q>the system should be fast and have high
availability</q>. Instead, it is recommended to specify, for example,
that the system should ensure 99.99% availability and 99% of the
transactions conducted in any 5-minute window should have a maximum
response time of 1 second.</p>
<p> Some authors, such as Ian Sommerville (<a href="c">link</a>), also
divide requirements into <strong>user requirements</strong> and
<strong>system requirements</strong>. User requirements are high-level,
non-technical, and usually written by users in natural language.
Conversely, system requirements are more technical, precise and defined
by the developers. Oftentimes, a single user requirement expands into a
set of system requirements. As an example, in a banking system, a user
requirement like <q>the system should allow funds transfer to another
bank‚Äôs checking account via wire transfers</q> would result in system
requirements specifying the detailed protocol that should be used for
such transactions. Essentially, user requirements are closer to the
problem while system requirements lean towards the solution.</p>
<h2 data-number="2.2" id="requirements-engineering"><span
class="header-section-number">2.2</span> Requirements Engineering <a
href="#requirements-engineering" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> <strong>Requirements Engineering</strong> refers to activities such
as the identification, analysis, specification, and maintenance of a
system‚Äôs requirements. The term engineering is used to emphasize that
these activities should be performed systematically throughout a
system‚Äôs lifecycle, using only well-defined techniques whenever
possible.</p>
<p> The process of identifying, discovering, and understanding a
system‚Äôs requirements is termed <strong>Requirements
Elicitation</strong>. Elicitation, in this context, implies drawing out
the main requirements of the system from discussions and interactions
between the system‚Äôs developers and its stakeholders.</p>
<p>We can use various techniques for requirements elicitation, including
conducting stakeholder interviews, issuing questionnaires, reviewing
organizational documents, organizing user workshops, creating
prototypes, and analyzing usage scenarios. Some elicitation techniques
also rely on ethnographic studies. Ethnography, a term whose roots trace
back to Anthropology, refers to studying a culture in its natural
environment (<em>ethnos</em>, in Greek, means people or culture). For
instance, to study a newly discovered indigenous tribe in Amazon, an
anthropologist might move to the tribe‚Äôs location and spend months
living amongst them and understanding their habits, customs, language,
etc. Similarly, in the context of Requirements Engineering, ethnography
is a technique of requirements elicitation that recommends the developer
integrate into the work environment of the stakeholders and
observe‚Äîtypically for several days‚Äìhow they perform their tasks. Note
that this observation is silent, meaning that the developer should not
interfere with or express personal views about the observed tasks and
events.</p>
<p>Once requirements are elicited, they should be (1) documented, (2)
checked, validated, and (3) prioritized.</p>
<p>In Agile development, requirements are documented using <strong>user
stories</strong> as previously discussed in Chapter 2. However, in some
projects, a <strong>Requirements Specification Document</strong> might
be necessary. This document elaborates all requirements of the software
to be built‚Äîincluding functional and non-functional requirements‚Äî
normally in natural language. In the 90s, the <strong>IEEE 830
Standard</strong>, a standard for such documents was proposed. This
standard was suggested within the context of Waterfall-based models,
which, as we studied in Chapter 2, involves a lengthy phase of
requirements specification. The main sections of the IEEE 830 standard
are illustrated in the next figure.</p>
<figure>
<img src="figs/cap3/ieee-830-standard.svg" style="width:70.0%"
alt="Template of a requirement specification document following the IEEE 830 standard" />
<figcaption aria-hidden="true">Template of a requirement specification
document following the IEEE 830 standard</figcaption>
</figure>
<p> After specification, requirements should be checked and validated to
ensure they are correct, precise, complete, consistent, and verifiable,
as described below:</p>
<ul>
<li><p>Requirement should be <strong>correct</strong>. For example, an
incorrect computation for the savings account returns in a banking
system could result in either bank or client losses.</p></li>
<li><p>Requirements should be <strong>precise</strong> to avoid
ambiguity. However, ambiguity occurs more frequently than we‚Äôd like when
using natural language. For example, consider the following condition:
to pass, a student needs to score 60 points during the semester or score
60 points in the Special Exam and attend the classes regularly. Observe
that it admits two different interpretations. Firstly: (60 points during
the semester or 60 points in the Special Exam) and attend classes
regularly. But it can also be interpreted as: 60 points during the
semester or (60 points in the Special Exam and regular attendance). As
shown, parentheses had to be used to remove ambiguity in the combination
of the <q>and</q> and <q>or</q> operations</p></li>
<li><p>Requirements should be <strong>complete</strong> to ensure all
necessary features, especially crucial ones, are considered and are not
forgotten.</p></li>
<li><p>Requirements must be <strong>consistent</strong>. Inconsistency
arises when different stakeholders have distinct expectations‚Äîfor
example, if one stakeholder expects system availability at 99.9%, but
another believes 90% suffices.</p></li>
<li><p>Requirements should be <strong>verifiable</strong>, implying we
can test their implementations. For example, stating that a system
should be user-friendly is vague; how can developers verify if they‚Äôve
met the clients‚Äô expectations in this case?</p></li>
</ul>
<p>Lastly, requirements must be prioritized. At times, the term
requirements is taken literally, i.e., as a list of mandatory features
and constraints in software systems. However, not everything specified
by clients will be implemented in the initial releases. For instance,
budget and time constraints might require the delay of certain
requirements.</p>
<p>Furthermore, requirements can change, as the world changes. For
example, in the banking system mentioned earlier, the rules for savings
account returns should be updated every time they are changed by the
responsible federal agencies. Thus, if a requirements specification
document exists, documenting such rules, it should be updated, just like
the source code. The ability to identify the requirements implemented by
a given piece of code and vice versa (i.e., to map a particular
requirement to the code implementing it) is called
<strong>traceability</strong>.</p>
<p>Before concluding, it‚Äôs important to mention that Requirements
Engineering is a multi-disciplinary and complex activity. For instance,
political factors might motivate certain stakeholders to do not
cooperate with requirement elicitation, particularly when this threatens
their status and power within the organization. Other stakeholders may
simply not have time to meet with developers to explain the system‚Äôs
requirements. Moreover, a cognitive barrier between stakeholders and
developers may also impact the elicitation of requirements. For example,
since stakeholders are typically seasoned experts, they might use a
specialized language, unfamiliar to developers.</p>
<p><strong>Real World Insight</strong>: To understand the challenges
faced in Requirements Engineering, in 2016, about two dozen researchers
organized a survey with 228 software-developing companies spread across
10 countries (<a href="https://arxiv.org/abs/1611.10288">link</a>). When
asked about the main problems faced in requirements the specification,
the ten most common answers were as follows (including the percentage of
companies that cited each problem):</p>
<ul>
<li>Incomplete or undocumented requirements (48%)</li>
<li>Communication failures between team members and customers (41%)</li>
<li>Constantly changing requirements (33%)</li>
<li>Abstractly specified requirements (33%)</li>
<li>Time constraints (32%)</li>
<li>Communication problems among team members (27%)</li>
<li>Difficulty to distinguish requirements from solutions (25%)</li>
<li>Lack of customer support (20%)</li>
<li>Inconsistent requirements (19%)</li>
<li>Lack of access to customers‚Äô or business needs (18%)</li>
</ul>
<h3 data-number="2.2.1" id="what-will-we-study"><span
class="header-section-number">2.2.1</span> What Will We Study? <a
href="#what-will-we-study" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>The following figure summarizes our studies on requirements so far,
showing how they act as a pivotal bridge that links a real-world problem
with a software designed to solve it. We will use this figure to
motivate and introduce the topics we will study for the rest of this
chapter.</p>
<figure>
<img src="figs/cap3/requirements.svg" style="width:60.0%"
alt="Requirements are the bridge between real-world problems and their software solutions" />
<figcaption aria-hidden="true">Requirements are the bridge between
real-world problems and their software solutions</figcaption>
</figure>
<p>The figure is useful for illustrating a common situation in
Requirements Engineering: systems whose requirements change frequently
or whose users cannot accurately specify what they want in the system.
In fact, we‚Äôve already studied such systems in Chapter 2, when we
covered Agile Methods. As the reader may recall, when requirements
change frequently, and the system is a non-mission-critical one, it is
not recommended to invest years drafting a Detailed Requirements
Document. There‚Äôs a risk the requirements become outdated before the
system is finalized‚Äîor a competitor can build an equivalent system and
dominate the market. In such cases, as we also commented on Chapter 2,
we should use lightweight requirement specification documents‚Äîcalled
<strong>User Stories</strong>‚Äîand incorporate a representative of the
customers into the development team, to clarify and explain the
requirements to the developers. Given the importance of such
scenarios‚Äîsystems with constantly evolving, but non-critical
requirements‚Äìwe will start by studying User Stories in Section 3.3.</p>
<p>On the other hand, some systems have relatively stable requirements.
In these cases, it might be worth to invest in detailed requirement
specifications. Certain companies, for instance, might prefer to know
all the system‚Äôs requirements before starting its development. Lastly,
requirements can be demanded by certification organizations, especially
for systems that deal with human lives, such as systems in the medical,
transportation, or military fields. In Section 3.4, we will study
<strong>Use Cases</strong>, which are comprehensive documents for
specifying requirements.</p>
<p>A third scenario arises when we are no sure if the proposed
<q>problem</q> truly warrants a solution. That is, we might collect all
the requirements of this <q>problem</q> and implement a system that
solves it. However, the uncertainty remains whether this system will
succeed and attract users. In these scenarios, an interesting procedure
is to take a step back and first test the relevance of the problem we
intend to solve using a software system. A possible test involves
building a <strong>Minimal Viable Product</strong>
(<strong>MVP</strong>). An MVP is a functional system that can be used
by real clients. However, it only includes the features necessary to
prove its market feasibility, i.e, its ability to solve a problem faced
by some clients. Given the contemporary importance of such
scenarios‚Äîsoftware for solving problems in unknown or uncertain
markets‚Äîwe will study more about MVPs in Section 3.5.</p>
</div>
</div>
</div>

<footer>
All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>.
</footer>
</body>
</html>
