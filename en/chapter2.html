<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Chapter 2: Process ‚Äì Software Engineering: A Modern Approach</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <meta name="robots" content="noindex">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p> <h4>Disclaimer: This chapter is a beta version subjected to proofreading. </h4> </p>
<header id="title-block-header">
<h1 class="title">Software Engineering: A Modern Approach</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="2" id="process"><span
class="header-section-number">2</span> Process <a href="#process"
class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>In software development, perfect is a verb, not an adjective.
There is no perfect process. There is no perfect design. There are no
perfect stories. You can, however, perfect your process, your design,
and your stories.</em> ‚Äì Kent Beck</p>
</blockquote>
<p> This chapter starts with a discussion on the importance of software
process (Section 2.1). Next, we discuss general and foundational aspects
of agile processes (Section 2.2), including a discussion into the
historical context that motivated the emergence of these processes. The
next sections focus on three agile methods: Extreme Programming (Section
2.3), Scrum (Section 2.4), and Kanban (Section 2.5). Following that, we
comment on scenarios where agile methods might not be the most
recommended processes (Section 2.6). Lastly, in Section 2.7, we briefly
present some traditional processes, such as the Unified Process.</p>
<h2 data-number="2.1" id="importance-of-process"><span
class="header-section-number">2.1</span> Importance of Process <a
href="#importance-of-process" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>The production of a car in an automobile factory follows a
well-defined process. In simple terms, sheets of steel are initially cut
and pressed to shape doors, roofs, and hoods. Next, the car is painted
and components like the dashboard, seats, seat belts, and wiring are
installed. Finally, the mechanical parts, including the engine,
suspension, and brakes, are fitted.</p>
<p>Analogously, software production should follow a
<strong>process</strong>, although less mechanized and more dependent on
intellectual endeavor. A software development process defines a series
of steps, tasks, events, and practices that developers must observe
while developing a software system.</p>
<p> There are some who critique software processes and question their
need, often asking: <q>Why must I follow a process?</q> or <q>What
process did Linus Torvalds or Donald Knuth used when implementing the
Linux operating system or the TeX text formatter?</q></p>
<p>In reality, the second question above do not apply to our context as
both Linux (in its initial versions) and TeX were individual projects
led by a single developer. In such scenarios, following a process is
less important. Stated in better terms, the process followed in those
projects was a personal one, reflecting the principles, practices, and
experience of a single developer.</p>
<p>However, contemporary software systems are too complex to be
developed by a single developer. Thus, systems implemented by solitary
heroes are increasingly rare nowadays. In practice, modern systems‚Äîthe
focus of this book‚Äîare developed by <strong>teams</strong>.</p>
<p>However, these teams require at least a minimal set of rules to
produce quality software efficiently. That‚Äôs why software companies
invest so much in software processes. They serve as tools for companies
to coordinate, motivate, organize, and evaluate their developers,
ensuring at the same time productivity and alignment with the
organization‚Äôs goals. Without a process‚Äîeven a light and simplified one,
such as the agile methods we will study in this chapter‚Äîthere is a risk
that teams will work in a uncoordinated way, creating products with no
business value. Finally, processes not only benefit the company, but
they also serve developers by clarifying expected tasks and outcomes,
thus reducing misalignment among team members.</p>
<p>In this chapter, we explore various software processes. In fact, in
Chapter 1, we already presented a first introduction to Waterfall and
Agile methods. In the following sections, we will continue this
discussion and present three well-known Agile methods.</p>
<h2 data-number="2.2" id="agile-manifesto"><span
class="header-section-number">2.2</span> Agile Manifesto <a
href="#agile-manifesto" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> The earliest software development process‚Äîas the Waterfall process,
proposed in the 1970s‚Äîfollowed a sequential approach. Usually, projects
began with a requirement specification phase and ended with the
implementation, testing, deployment, and maintenance phases.</p>
<p>Given the historical context, this strictly sequential approach was
understandable. Indeed, traditional engineering projects are<br />
developed sequentially and are based on detailed and upfront planning.
Therefore, it‚Äôs not a surprise that the emerging Software Engineering
field mirrored the processes of longer-established domains like
Electronics, Civil, Mechanical, and Aeronautical Engineering, among
others.</p>
<p>However, by the 80s, the industry began to recognize that software is
different from other engineering products. The recurrent problems faced
by software projects at this time reinforced this conclusion. For
instance, such projects routinely overshot schedules and budgets. Some
were even abandoned after years of effort without delivering a
functioning system to customers.</p>
<p> The CHAOS Report published in 1994 by the Standish Group consulting
firm provided more details about the state of software projects at the
time. This report (<a
href="https://www.standishgroup.com/sample_research_files/chaos_report_1994.pdf">link</a>)
revealed that over 55% of projects surpassed their<br />
deadlines by 51% to 200%; and at least 12% exceeded the deadlines by
more than 200%, as shown in the next figure.</p>
<figure>
<img src="figs/cap2/chaos2-en.svg" style="width:90.0%"
alt="CHAOS Report (1994): percentage of projects exceeding their deadlines (for each range of overrun)" />
<figcaption aria-hidden="true">CHAOS Report (1994): percentage of
projects exceeding their deadlines (for each range of
overrun)</figcaption>
</figure>
<p>In terms of costs, almost 40% of the studied projects overshot their
budgets by 51% to 200%, as indicated in the following figure:</p>
<figure>
<img src="figs/cap2/chaos1-en.svg" style="width:90.0%"
alt="CHAOS Report (1994): percentage of projects exceeding their budgets (for each range of overrun)" />
<figcaption aria-hidden="true">CHAOS Report (1994): percentage of
projects exceeding their budgets (for each range of
overrun)</figcaption>
</figure>
<p>Therefore, in 2001, some industry professionals gathered in Snowbird,
Utah, to discuss and propose an alternative to the prevailing
Waterfall-based processes. They argued that, being different from
traditional engineering products, software requires a distinct
development process.</p>
<p>For instance, software requirements change more frequently than those
of a computer, airplane, or bridge. Moreover, customers often lack a
clear understanding of their needs. As a result, there is always a risk
of designing a product that will be obsolete by the time it‚Äôs finished
due to changing circumstances or customer needs. The professionals that
met at Utah also identified issues with the document-centric approach
advocated by Waterfall. At the time, requirements documents were
detailed, heavy, and dense, which contributes to making them obsolete
very quickly as developers would not update the documentation to reflect
requirement changes.</p>
<p>In response, the group proposed a new type of software process, which
was described in a document they named the <strong>Agile
Manifesto</strong>. The manifesto reads:</p>
<blockquote>
<p>Through this work, we have come to value:</p>
<p><strong>Individuals and interactions</strong> over processes and
tools</p>
<p><strong>Working software</strong> over comprehensive
documentation</p>
<p><strong>Customer collaboration</strong> over contract negotiation</p>
<p><strong>Responding to change</strong> over following a plan.</p>
</blockquote>
<p> Agile processes are characterized by short and iterative development
cycles. Systems are built incrementally, starting with the most relevant
features, according to customers. Initially, a first version of the
system is created, which implements only high-priority functionalities.
This version is then validated by the customer. If approved, a new
cycle‚Äîalso callled <strong>iteration</strong> or
<strong>sprint</strong>‚Äîbegins, adding a few more features. Typically,
these cycles are short, having two weeks, for example. This allows the
systems to be incrementally built, with each feature increment receiving
explicit approval by the customer. The development ends when all the
customer‚Äôs requests have been implemented.</p>
<p> The following figures present a comparison between Waterfall and
Agile methods:</p>
<figure>
<img src="figs/cap2/waterfall2-en.svg" style="width:90.0%"
alt="Development using a Waterfall process. The software is finished only at the end." />
<figcaption aria-hidden="true">Development using a Waterfall process.
The software is finished only at the end.</figcaption>
</figure>
<figure>
<img src="figs/cap2/agile-en.svg" style="width:90.0%"
alt="Development using an Agile process. Each iteration (represented by the rectangles) produces a product increment (S++), which is validated and tested by customers." />
<figcaption aria-hidden="true">Development using an Agile process. Each
iteration (represented by the rectangles) produces a product increment
(S++), which is validated and tested by customers.</figcaption>
</figure>
<p>However, the previous figures may suggest that in agile development,
each iteration replicates a mini-Waterfall process, encompassing all the
Waterfall phases. This isn‚Äôt accurate; generally, iterations in agile
methods aren‚Äôt a series of tasks like in Waterfall (more details in the
following sections). The figure may also suggest that a system must be
put into production at the end of each iteration. This is also
incorrect. Indeed, the objective is to deliver a functional system that
performs useful tasks. However, the decision to launch the software
involves other variables such as business risks, hardware resources
availability, marketing campaigns, user training, etc.</p>
<p>Other agile process characteristics include:</p>
<ul>
<li><p>Minimal emphasis on documentation: Only vital information should
be documented.</p></li>
<li><p>Less emphasis on detailed plans: At the start of a project, often
neither the customer nor the developers have a clear understanding of
all requirements that should be implemented. Such understanding
gradually unfolds as sprints are finished and validated. In other words,
the essence of agile development is to advance even when we have
incomplete, partial, and changing requirements.</p></li>
<li><p>No dedicated design phase, i.e., no Big Design Up Fron (BDUF):
The design of the software system is also incremental, evolving on each
iteration.</p></li>
<li><p>Small teams: Teams typically comprise about a dozen developers
or, as Amazon CEO Jeff Bezos phrased it, <q>teams that can be fed with
two pizzas</q>. We also like to say that the size of agile teams varies
between the size of a basketball team (5 members) to the one of a soccer
team (11 members).</p></li>
<li><p>Emphasis on novel programming practices (as in the early 2000s),
such as pair programming, automated testing, refactoring, and continuous
integration.</p></li>
</ul>
<p>Due to such characteristics, agile processes are considered
<strong>light processes</strong>, having few prescriptions and
documents.</p>
<p>However, the characteristics we presented above are still generic and
broad. Thus, to make agile principles more concrete and actionable,
several methods were proposed and defined. Interestingly, they were all
initially proposed before the 2001 Agile Manifesto‚Äôs meeting.
Particularly, in this chapter, we will study three agile methods:</p>
<ul>
<li><p>Extreme Programming (XP): Kent Beck proposed this method in a
1999 book (<a
href="https://dl.acm.org/citation.cfm?id=318762">link</a>). A second and
heavily revised edition was also released in 2004.</p></li>
<li><p>Scrum: This agile method was introduced by Jeffrey Sutherland and
Ken Schwaber in a 1995 article (<a
href="https://dl.acm.org/citation.cfm?id=260274">link</a>).</p></li>
<li><p>Kanban: This method originated from a production control system
implemented in Toyota‚Äôs factories in the 1950s (<a
href="https://hbr.org/1986/01/the-new-new-product-development-game">link</a>).
Over the past years, Kanban has been gradually adapted for software
development.</p></li>
</ul>
<p>It‚Äôs also important to understand that all development methods are
essentially a set of recommendations. Every organization should analyze
each one and decide if it‚Äôs suitable for their particular context.
Consequently, organizations might need to adapt any existing method to
their needs. For this reason, it‚Äôs rare to see two organizations that
follow exactly the same development process. For instance, even if they
say they‚Äôre using Scrum.</p>
<p><strong>In-Depth</strong>: The terms process and methods are often
used interchangeably. However, there are also subtle differences between
them. In our context, a process is a set of steps, events, and tasks
used to construct software. Every organization employs a process to
develop its systems, which can be Agile, Waterfall, or even a
<q>chaotic</q> one. However, a process always exists. On the other hand,
a method specifies a particular process (the term originates from Greek,
meaning <q>the means to achieve a goal</q>). Therefore, XP, Scrum, and
Kanban are agile methods or, put another way, they define practices,
activities, events, and techniques compatible with agile principles.</p>
<p></p>
<p><strong>Real World Insight</strong>: The widespread success and
impact of agile methods are noteworthy. At present, an overwhelming
majority of organizations, irrespective of their size or business
domain, follow agile principles to varying degrees. Here‚Äôs an
interesting statistic: in 2018, the Stack Overflow survey included a
question about the most used development methods (<a
href="https://insights.stackoverflow.com/survey/2018/#career-values">link</a>).
Over 57 thousand professional developers responded, and a majority
identified with agile methods or practices. This includes methodologies
we will study in this chapter‚Äîsuch as Scrum (63% responses), Kanban
(36%), and Extreme Programming (16%). Only 15% of participants answered
Waterfall as their development method.</p>
<h2 data-number="2.3" id="extreme-programming"><span
class="header-section-number">2.3</span> Extreme Programming <a
href="#extreme-programming" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> Extreme Programming (XP) is a lightweight method for developing
software with ever-changing or unclear requirements, such as the Type B
systems (Business), according to the classification described in Chapter
1. As any agile method, XP embodies characteristics like short iterative
development cycles, less emphasis on comprehensive documentation,
incremental design, and development in small teams.</p>
<p>In other words, XP is not a prescriptive method that proposes a
step-by-step plan for software construction. Instead, XP is defined by a
set of <strong>values</strong>, <strong>principles</strong>, and
<strong>practices</strong>. The values and principles are important to
shape the culture of software development teams. Then, they are
materialized into a list of development practices. Often, when deciding
to adopt XP, developers and organizations tend to focus on the
practices. However, the values and principles are key components of the
method, as they give meaning to the practices proposed by XP. To be
clear, if an organization is unprepared to embrace the XP mindset‚Äîas
represented by its values and principles‚Äîit should not invest time in
adopting the practices.</p>
<p>In this chapter, we will first present the values and principles
defended by XP. Here is a list of them:</p>
<ul>
<li><p><strong>Values</strong>: Communication, simplicity, feedback,
courage, respect, and quality of life.</p></li>
<li><p><strong>Principles</strong>: Humanity, economics, mutual
benefits, continuous improvements, acknowledging failures, baby steps,
and personal responsibility.</p></li>
</ul>
<p>Next, we‚Äôll explain the practices, which we organize into three
groups: process practices, programming practices, and project management
practices. Here is a list of the practices within each group:</p>
<ul>
<li><p><strong>Process Practices</strong>: Customer representative, user
stories, iterations, releases, release planning, iteration planning,
planning poker, and slacks.</p></li>
<li><p><strong>Programming Practices</strong>: Incremental design, pair
programming, test-driven development (TDD), automated builds, continuous
integration.</p></li>
<li><p><strong>Project Management Practices</strong>: Metrics, working
environment, open-scope contracts.</p></li>
</ul>
<h3 data-number="2.3.1" id="values"><span
class="header-section-number">2.3.1</span> Values <a href="#values"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> XP advocates that software projects should be guided by three main
values: communication, simplicity, and feedback. Indeed,<br />
these values are important in any human collaboration effort. Good
<strong>communication</strong> is important not only to avoid mistakes
but also to learn from them. The second XP value is
<strong>simplicity</strong>, as in every complex and challenging
software system there is a simpler system that is sometimes overlooked.
Lastly, continuous <strong>feedback</strong> from stakeholders
counterbalances risks like changing requirements and technologies.</p>
<p>In fact, it is difficult to develop the <q>right</q> software system
at the first attempt. Frederick Brooks has a well-known recommendation
regarding this problem:</p>
<blockquote>
<p><em>Plan to throw away parts of your system, because you
will.</em></p>
</blockquote>
<p>Thus, feedback is an essential value to ensure that the software
parts that are going to be discarded are identified as early as
possible, to reduce waste and rework. Besides, XP also defends other
values such as <strong>courage</strong>, <strong>respect</strong>, and
<strong>quality of life</strong>.</p>
<h3 data-number="2.3.2" id="principles"><span
class="header-section-number">2.3.2</span> Principles <a
href="#principles" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> While XP‚Äôs values are abstract, its practices are concrete and
pragmatic. To bridge this gap between values and practices, XP
encourages following a set of principles. Picture it as a river with the
values on one side and the practices on the other. Principles act as a
bridge between both sides. The main XP principles are:</p>
<p><strong>Humanity</strong>. Software is a activity that depends on
human capital. The principal resource of software companies are not
physical assets‚Äîcomputers, buildings, chairs, or Internet connections,
for example‚Äîbut their developers. A term that nicely reflects the
importance of this principle is <em>peopleware</em>, which was coined by
Tom DeMarco in a book with the same title (<a
href="https://dl.acm.org/citation.cfm?id=2505459">link</a>). The idea is
that managing people‚Äîincluding factors such as expectations, growth,
motivation, and responsibilities‚Äîis essential for the success of
software projects.</p>
<p><strong>Economics</strong>: Software development requires substantial
financial investment. Hence, it‚Äôs not merely an intellectual pursuit; it
must deliver economic results, particularly in the case of Type B
(Business) systems, according to the classification we studied in
Chapter 1.</p>
<p><strong>Mutual Benefits</strong>: XP advocates that decisions taken
in a software project should benefit multiple stakeholders. For example,
a software company should ensure a good work environment; in return, the
team should deliver a software that adds value to its business. Another
example: by writing tests a developer benefits, as tests help to detect
bugs in her code. But tests also help other developers, who will be more
confident that their code does not introduce regressions, i.e., bugs in
previously working code. A third and last example: refactoring makes
code cleaner and easier to understand, both for the developer who wrote
it and for a developer who in the future will have to maintain it.</p>
<p><strong>Continuous Improvements</strong>: As expressed in the quote
by Kent Beck opening this chapter, no software development process is
perfect. Therefore, what we should aim is a process that is under
continuous improvement, at each iteration, with feedback from clients
and team members. For the same reason, XP does not recommend investing a
large amount of time in an initial and complete design. Instead, the
software‚Äôs design is also incremental, improving at each iteration.
Finally, the programming practices themselves can be improved; for this,
the team should set aside time to discuss and reflect on them.</p>
<p><strong>Failures Happen</strong>: Software development is not a
risk-free endeavor. As discussed in Chapter 1, software is one of the
most complex human constructions. Thus, failures are expected in
software projects, including major bugs, features that did not attracted
users, and issues with non-functional requirements, such as performance,
usability, privacy, availability, etc. Evidently, XP does not advocate
covering up these failures. However, they should not be used to punish
team members. On the contrary, failures are part of the game if a team
aims to deliver software that solves problems at the right time.</p>
<p><strong>Baby Steps</strong>: A secure, tested, and validated
progress, albeit small, is better than large software increments with
risks of being discarded by the users. The same applies to tests (which
are useful even when the units under test are small, such as individual
methods), code integration (it‚Äôs better to integrate daily, than to go
through the stress of a major integration after weeks of work) and
refactorings (which should occur in small steps intercalated with
running the tests). In summary, it‚Äôs important to focus on continuous
improvements, no matter how small, as long as they‚Äôre in the right
direction. Indeed, in software engineering, <q>baby steps</q> are
usually better than major changes, which tend to be risky and may not
lead to positive outcomes.</p>
<p><strong>Personal Responsibility</strong> (or accepted
responsibility): According to this principle, developers should have a
clear idea of their role and responsibility in the team. The reason is
that responsibility cannot be transferred without the other party
accepting it. For a similar reason, XP advocates that the developer who
implements a <em>user story</em>‚Äîi.e., a small feature increment‚Äîshould
also be also the one who will test and maintain it.</p>
<p></p>
<p><strong>Real World Insight</strong>: One of the first systems to
adopt XP was a payroll system for the car manufacturer Chrysler, called
Chrysler Comprehensive Compensation (C3) system (<a
href="https://doi.org/10.1109/2.796139">link</a>). The project began in
early 1995 and, as it failed to deliver concrete results, it was
restarted the following year under the leadership of Kent Beck. Another
well-known member of the agile community, Martin Fowler, participated in
the project as a consultant. While building the C3 system, many facets
of the soon-to-be-named XP method were defined and experimented
with.</p>
<h3 data-number="2.3.3" id="process-practices"><span
class="header-section-number">2.3.3</span> Process Practices <a
href="#process-practices" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Just like other agile methodologies, XP recommends direct client
involvement in the project, not limiting the team members to developers
only. When using XP, teams should include one <strong>customer
representative</strong> who is an expert on the domain of the system
under development. This representative should propose and write the
<strong>user stories</strong>, which are XP‚Äôs version of requirement
specification documents. However, user stories are rather short and
lightweight documents, comprising two to three sentences, in which the
customer representative describes the features the system should
implement.</p>
<p>We‚Äôll examine user stories more closely in Chapter 3. For now, we
should note that they are usually written on cards, by hand or using
project management tools. As we mentioned, they are simple documents
focusing on the key features of the system from a user perspective, as
opposed to complex requirement documents, which are used for example
with Waterfall-based approaches.</p>
<p>Here‚Äôs an example of user story for a Question &amp; Answer (Q&amp;A)
forum app‚Äîsimilar to Stack Overflow‚Äîwhich we‚Äôll use to present XP in
this chapter.</p>
<table style="width:90%;">
<colgroup>
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Post Question</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>A logged-in user should be able to
post questions. Since it‚Äôs a programming forum, questions may
incorporate code blocks, which must be presented in a differentiated
layout.</em></td>
</tr>
</tbody>
</table>
<p>Note that the story has a title (Post Question) and a brief
description in two sentences. These stories serve as reminders for
subsequent detailed verbal specifications by the customer
representative. In other words, developers can at any time consult the
customer representative to clarify issues about user stories.</p>
<p>After creation by the customer representative, developers should
estimate the effort required for implementing the stories. This
estimation is often performed in <strong>story points</strong>, instead
of hours or man-days. An integer scale is used in these cases to label
stories as having a certain number of story points. The simplest stories
are marked as having one story point. If a story is twice as complex, it
is marked with two story points, and so on. Indeed, story points are
commonly defined by a Fibonacci sequence, such as 1, 2, 3, 5, 8, 13. The
goal is to use a scale that makes the stories progressively harder and
also allows the team to make comparisons similar to the following one:
in terms of effort, is a task that has 8 story points equivalent to a
task with 5 story points plus a task with 3 points (i.e., the two
previous marks in the scale)? If yes, 8 story points is a good estimate.
If not, it is better to estimate the story with 5 story points.</p>
<p> </p>
<p><strong>In-Depth</strong>: A technique for estimating story points is
called <strong>Planning Poker</strong>. Here‚Äôs how it works: the
customer representative selects a story, reads it to the developers, who
can discuss it with the representative to clarify any doubts. After
that, each developer independently estimates the story‚Äôs size in story
points, and then everyone simultaneously reveals their estimates using
previously distributed cards with numbers 1, 2, 3, 5, etc. If there is
consensus, the team moves to the next story. If not, there is a
discussion and further voting until common ground is found.</p>
<p> The user stories are implemented in
<strong>iterations</strong>‚Äîwhich have a fixed duration, usually ranging
between one to three weeks. These iterations are also organized in
longer cycles, referred to as <strong>releases</strong>, typically
lasting two to three months. A team‚Äôs <strong>velocity</strong> is the
number of story points it can implement within an iteration. The
customer representative should propose and create stories that take at
least one release to implement. Hence, in XP, the planning horizon is
one release, which may span a few months.</p>
<p><strong>Note</strong>: The term release in XP differs from its usage
in configuration management where it refers to a version of a system
that is available for usage. However, the version produced at the end of
a release in XP does not necessarily need to go into production.</p>
<p>To summarize, to initiate the use of XP, an organization should:</p>
<ul>
<li>Define the duration of an iteration.</li>
<li>Define the number of iterations in a release.</li>
<li>Set a list of stories, as proposed the customer representative.</li>
<li>Get estimates for each story from the developers.</li>
<li>Define the team‚Äôs velocity, that is, the number of story points that
it can implement per iteration</li>
</ul>
<p>Upon defining the above aspects, the customer representative must
prioritize the stories. To do this, the representative must select the
stories to be implemented in each iteration of the first release. In
this prioritization, the team‚Äôs velocity should be taken into account.
For example, assume that a team has a velocity of 25 story points per
iteration. In this case, the customer representative cannot allocate
stories to an iteration whose combined story points exceed this limit.
The process of assigning stories to iterations and releases is known as
<strong>release planning</strong> or planning game, which is the term
used in the first edition of the XP book.</p>
<p>For example, consider the Q&amp;A forum we used earlier. The next
table summarizes the outcome of a possible release planning. In this
example, we are assuming that the customer representative wrote 8
stories, that each release has two iterations, and that the team‚Äôs
velocity is 21 story points per iteration (note that the sum of the
story points of each iteration is exactly 21).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Story</strong></th>
<th style="text-align: center;"><strong>Story Points</strong></th>
<th style="text-align: right;"><strong>Iteration</strong></th>
<th style="text-align: center;"><strong>Release</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Register user</td>
<td style="text-align: center;">8</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Post questions</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Post answers</td>
<td style="text-align: center;">3</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Opening screen</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Gamify questions/answers</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Search questions/answers</td>
<td style="text-align: center;">8</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Add tags</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Comment on questions/answers</td>
<td style="text-align: center;">3</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>The table emphasizes two points: (1) the stories in XP represent the
main features of the intended system; (2) developers have no control on
the order of story implementation; this is decided by the customer
representative, who must be someone capable and with authority to define
the most urgent and important features for the organization contracting
the development.</p>
<p>After the release planning, the iterations start. At the beginning of
each iteration, the development team must meet to conduct an
<strong>iteration planning</strong>. The purpose of this planning is to
decompose the stories of an iteration into tasks that can be assigned to
one of the team‚Äôs developers. For example, the <em>Post questions</em>
story can be decomposed into the following tasks:</p>
<ul>
<li>Design and test the web interface, including layout, CSS templates,
etc.</li>
<li>Install the database server, as well as design and create the
database tables.</li>
<li>Implement the data access layer.</li>
<li>Install and test the web server framework.</li>
<li>Implement the control layer, with endpoints to register, remove, and
update questions.</li>
<li>Implement the Web interface.</li>
</ul>
<p>Generally, tasks should not be complex and should be completed in a
few days.</p>
<p>So, an XP project encompasses:</p>
<ul>
<li>Releases, which are groups of iterations spanning a few months</li>
<li>Iterations, which are groups of stories and respective tasks,
lasting a few weeks</li>
<li>Tasks, which take a few days to complete</li>
</ul>
<p>Once the tasks are created, the team should also decide who is
responsible for each one. With that, the iteration begins with task
implementation.</p>
<p>An iteration concludes when all its stories have been implemented and
validated by the customer representative. Therefore, at an iteration‚Äôs
end, the stories should be demonstrated to the customer representative,
who must check and confirm their implementations.</p>
<p> XP also proposes that teams should program <strong>slack</strong>
tasks, or tasks that can be postponed, during an iteration. Examples
include studying a new technology, taking an online course, improving
documentation, or even developing a side project. In fact, companies
like Google are renowned for allowing developers to use 20% of their
time for personal projects (<a
href="https://arxiv.org/abs/1702.01715">link</a>). In XP, slack tasks
have two primary objectives: (1) create a buffer that can be used should
a task require more time than estimated and (2) allow developers some
downtime from the demanding and intense project pace.</p>
<h4 class="unnumbered" id="frequently-asked-questions">Frequently Asked
Questions <a href="#frequently-asked-questions" class="anchor-link"
aria-hidden="true">üîó</a></h4>
<p>Now let‚Äôs answer some questions about the XP practices we have just
studied.</p>
<p><strong>How long should an iteration be?</strong> There isn‚Äôt a
definitive answer as numerous factors such as team characteristics,
system domain, and requirements all play a part. Short
iterations‚Äîtypically a week long‚Äîoffer quick feedback. However, they
also require more client involvement as new software increments need
weekly validation. Moreover, stories must be simple and straightforward
to fit in a 1-week iteration. Conversely, longer iterations‚Äîlike a
month‚Äîgrant the team more time to plan and execute tasks with less
pressure. The trade-off here is delays in receiving client feedback,
which is particularly relevant when the requirements are unclear. As a
result, a 2-3 week time box tends to provide a balance between rapid
feedback and less pressure on the team. Another useful recommendation is
to experiment, meaning testing and evaluating different durations before
settling on one.</p>
<p><strong>What role does the customer representative play during
iterations?</strong> At the beginning of a release, the customer
representative drafts the stories to be included in that release. They
then validate and approve the implementation of these stories at the end
of each iteration. The representative also needs to be readily available
during iterations to address questions the team may have. Given that
user stories contain only a few sentences, these questions might
naturally arise.</p>
<p><strong>How do we select the customer representative?</strong> The
most important criteria are that the person has a solid understanding of
the system‚Äôs domain and authority to prioritize user stories. There are
at least three potential scenarios for customer representatives:</p>
<ul>
<li><p>Consider a team developing a system for a department within their
own company. In this scenario, the customer representative might be an
employee from that client department.</p></li>
<li><p>Consider a team developing a system for a different company.
Here, the customer representative should ideally be an employee from
that client company who has knowledge of the software domain.</p></li>
<li><p>Consider a team creating a product for any client. The customer
representative in this case should be someone from the marketing, sales
or business sectors. Meaning, they should be closely aligned with the
problem but distant from the solution. For this reason, it‚Äôs preferable
not having a developer in this role. This type of representative is
often called a <strong>user proxy</strong>.</p></li>
</ul>
<p> <strong>How to define the team‚Äôs velocity?</strong> There is no
silver bullet for this issue. This definition depends on the team‚Äôs
experience. If the team members have already participated in projects
similar to the one they are starting, this is a less difficult question.
Otherwise, the team will need to test and calibrate their velocity
throughout successive iterations.</p>
<p><strong>Can stories refer to software engineering
activities?</strong> No, as the customer representative‚Äîwho is a
non-software engineering expert‚Äîis the one responsible for defining the
stories. However, a story could trigger the necessity for a task like
<q>install and test the database</q>. In essence, stories refer to
functional requirements. On the other hand, the tasks created for
implementing these stories might relate to functional requirements,
non-functional requirements or technical tasks such as database or
framework installation.</p>
<p><strong>What if story X is prioritized before Y, despite depending on
Y?</strong> For instance, the customer representative has allocated the
story <q>Post Question</q> to iteration 2 and <q>Post Answer</q> to
iteration 1. Although it seems contradictory, the team should respect
this order as the final decision always lies with the customer
representative. But then the dilemma might be <q>how can we post
responses without having the questions?</q> To resolve this problem,
placeholder questions that can‚Äôt be edited by users can be used. In
iteration 1, these questions will appear by default and users will be
able to respond to them.</p>
<p><strong>When does an XP project conclude?</strong> The project ends
when the customer representative decides the already implemented stories
to be adequate and that there are no more relevant stories to be
implemented.</p>
<h3 data-number="2.3.4" id="programming-practices"><span
class="header-section-number">2.3.4</span> Programming Practices <a
href="#programming-practices" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>The name Extreme Programming was chosen due to the novel programming
practices the method proposed at the end of the 90‚Äôs. The essence of XP
revolves around its emphasis on many programming practices and on the
production of running code since the first weeks of a project. The
importance of this fact can be better understood within the context of
the 90‚Äôs where distinct roles for analysts and programmers were the
norm. Analysts at that time were responsible for designing the
high-level system, defining its main components, classes, and interfaces
using graphical modeling languages, like UML, which we will discuss in
Chapter 4. Only upon completion of the analysis and design phases, the
coding phase would start under the responsibility of programmers. This
setup inherently created a hierarchy, with analysts often being regarded
as the more prestigious roles. However, with the introduction of agile
methodologies‚Äîparticularly XP‚Äîthis hierarchy was dismantled, since XP
advocates for starting coding<br />
at a project‚Äôs outset.</p>
<p>Simultaneously, to counteract the risk of low-quality code
production, XP introduced a novel set of programming practices. These
practices included pair programming, automated testing, test-driven
development (TDD), automated builds, and continuous integration, among
others. Most of these practices have been widely accepted within the
software industry, and are extensively used nowadays even by projects
not entirely adhering to agile principles.</p>
<p>Let‚Äôs now look at XP‚Äôs programming practices.</p>
<p> <strong>Incremental Design.</strong> XP projects do not have a
traditional design phase, known as <em>Big Design Up Front</em> (BDUF).
Instead, XP promotes the idea of making design a continuous and
incremental activity. This approach aims to address issues that arise
when an entire design activity is confined to the beginning of a
project. This is a stage where the project‚Äôs requirements tend to be
unclear both to the team and to the clients, leading to overestimating
or underestimating their value. Moreover, new requirements may come up
as the project progresses, making the initially intended design
obsolete.</p>
<p>For this reason, XP contends that the best time to contemplate the
design is when it becomes crucial. Two key phrases often used to
encourage and justify this practice are: <em>Do the simplest thing that
could possibly work</em> and <em>you aren‚Äôt going to need it</em>, the
latter known by the acronym YAGNI.</p>
<p>For a better understanding of the incremental design approach
proposed by XP, two points need to be highlighted. Firstly, proficient
teams often already have a design in mind before the first iteration.
This might include knowing that the system will have a web interface, a
set of backend components for implementing complex business logic and
also components for accessing a relational database. These decisions, by
themselves, cover and solve major system‚Äôs design concerns. Secondly, at
any iteration, the team can also allocate a technical task to discuss
and refine the system‚Äôs design.</p>
<p>Finally, it‚Äôs crucial to note that the concept of incremental design
is viable only when used in conjunction with other XP practices,
especially <strong>refactoring</strong>. XP insists on the importance of
refactoring to enhance the design‚Äôs quality. Hence, every opportunity to
refactor should put be in practice without delay.</p>
<p> <strong>Pair Programming</strong>. Accompanied by incremental
design, pair programming stands out as one of the most controversial
practices proposed by Extreme Programming. The concept is
straightforward: every coding task, whether it‚Äôs implementing a user
story, implementing a testing, or fixing a bug, should be conducted by
two developers working together, using the same keyboard and monitor.
One developer takes on the role of <strong>driver</strong>, controlling
the keyboard and mouse, while the other acts as a
<strong>navigator</strong> or reviewer. The navigator monitors the
driver‚Äôs code, providing feedback and direction, similar to a car rally
team.</p>
<p>Pair programming aims to enhance code quality and internal design,
guided by the principle that <q>two heads are better than one.</q> It
also aids in spreading code knowledge within a team, preventing
knowledge silos where only one developer understands a specific part of
the code. The practice also provides a valuable training tool for less
experienced developers, offering exposure to various programming
technologies, algorithms, data structures, design patterns, and
principles, testing and debugging techniques, etc.</p>
<p>However, employing two developers per task has economic implications,
as usually commented by pair programming critics. Also, for some
developers it is emotionally and cognitively uncomfortable to discuss
each line of code and each implementation decision with a colleague. To
mitigate this, XP recommends to rotate pairs at every session. These
sessions are typically 50 minutes long, followed by a 10-minute break.
In the following session, both pairs and roles (driver vs.¬†navigator)
switch.</p>
<p></p>
<p><strong>Real World Insight:</strong> In 2008, Microsoft Research‚Äôs
Andrew Begel and Nachiappan Nagappan surveyed 106 company developers
about their experiences with pair programming (<a
href="https://doi.org/10.1145/1414004.1414026">link</a>). Approximately
65% of the respondents found pair programming beneficial. When asked
about the advantages, reduced bugs (62%), better code quality (45%),
knowledge spread (40%), and peer learning opportunities (40%) received
most votes. However, 75% regarded the associated cost as a significant
disadvantage. Lastly, the majority (38%) preferred pairing with a
colleague having complementary skills to compensate for their
weaknesses.</p>
<p> In recent times, many software companies embraced the practice of
<strong>code review</strong>. In this case, another developer checks a
developer‚Äôs code asynchronously, avoiding the need for two developers
working at the same time on the same code.</p>
<p> <strong>Collective Code Ownership</strong>. According to this
practice, any developer or pair of developers can modify any part of the
code‚Äîto implement a new feature, fix a bug, or perform a
refactoring‚Äîwithout needing approval from the original code developer or
whoever last maintained it.</p>
<p> <strong>Automated Testing</strong>. This is one of the programming
practices advocated by XP that reached the greatest success. The
rationale is that manual testing‚Äîwhen a tester runs the program,
provides inputs and checks the outputs‚Äîis a costly procedure that cannot
be reproduced at every moment. Therefore, XP proposes the implementation
of programs‚Äîcalled automated tests‚Äîthat call units of a system code,
such as methods, and verify if the results are the ones expected.
Automated testing‚Äôs advent coincided with the development of the first
unit testing frameworks, including JUnit (developed by Kent Beck and
Erich Gamma in 1997), which was very important to promote the practice.
We reserve a detailed discussion about automated tests for Chapter
8.</p>
<p> <strong>Test-Driven Development (TDD).</strong> TDD is another
innovative programming practice proposed by XP where every method should
first have a test before its actual implementation begins. This practice
serves two main purposes: (1) it ensures that developers do not forget
to write tests because they are implemented first, and (2) by writing a
test first, developers put themselves in the method‚Äôs user‚Äôs shoes. For
example, they have to consider the method‚Äôs interface and how it should
be called before approaching the actual implementation. This encourages
the creation of more user-friendly methods. We will discuss TDD in more
detail in Chapter 8.</p>
<p> <strong>Automated Build</strong>. This practice refers to the
automated generation of an executable system version ready for
production. Several tools can be used for this process, such as the Make
system, a part of Unix distributions since the 1970s, or newer tools
like Ant, Maven, Gradle, Rake, MSBuild, etc. XP promotes two key
concepts about the build process. First, to avoid manual intervention
from developers, it should be fully automated. Second, the build process
should be as quick as possible to provide developers with prompt
feedback about possible problems, such as compilation errors or failing
tests.</p>
<p> <strong>Continuous Integration</strong>. As we discussed in Chapter
1, version control systems (VCS) such as Git are widely used nowadays. A
VCS stores the source code and related files, including configuration
files, images, and documentation. To work on a task, developers
<em>pull</em> the source code to their local machines, make
modifications, and then <em>push</em> the updated code back to the VCS.
This upload and merge step is referred to as
<strong>integration</strong>.</p>
<p>However, integration is subjected to conflicts when multiple
developers change the same lines of code. In such cases, the VCS
prevents integration. For example, if Developer A assigns a value of 10
to a variable <em>x</em>, whilst Developer B, working independently,
assigns <em>x</em> a value of 20, a conflict is created. To resolve this
conflict, A and B must agree on the correct value for <em>x</em>. This
is a simple example, but conflicts often involve larger sections of code
and more developers, making them time-consuming and challenging to
resolve and leading to situations known as <strong>integration
hell</strong>.</p>
<p>To minimize integration conflicts, XP encourages developers to
integrate their code frequently‚Äîdaily, if possible‚Äîunder a practice
known as <strong>continuous integration</strong>. The aim is to reduce
the number of conflicts and the time developers spend on resolving
them.</p>
<p>To check the quality of the code that is integrated, we should also
configure a <strong>continuous integration service</strong>. Before
carrying out any integration, this service builds the code and executes
the tests. The aim is to ensure that the new code does not have
compilation errors and that it passes all the tests. Examples of these
services include GitHub Actions, Jenkins, TravisCI, CircleCI, and more.
In Chapter 10, we will delve deeper into Continuous Integration.</p>
<p><strong>Real World</strong>: In 2010, Laurie Williams, a professor at
the University of North Carolina in the USA, surveyed 326 developers
about their experiences with agile methodologies (<a
href="https://doi.org/10.1145/2133806.2133823">link</a>). Participants
ranked the importance of various agile practices on a scale of 1 to 5,
with five denoting essential practices. Three practices tied for first
place with an average score of 4.5 and a standard deviation of 0.8:
continuous integration, short iterations (less than 30 days), and
definition of done criteria (i.e., the criteria used to consider the
implementation of user stories finished). Conversely, planning poker and
pair programming were ranked lower, with average scores of 3.1 and 3.3,
respectively.</p>
<h3 data-number="2.3.5" id="project-management-practices"><span
class="header-section-number">2.3.5</span> Project Management Practices
<a href="#project-management-practices" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> <strong>Working Environment</strong>. XP advocates for the
development of software by small, dedicated teams, ideally composed of
fewer than 10 developers. It also discourages scenarios where team
members split their time between multiple projects during the week.</p>
<p>Furthermore, XP emphasizes the importance of maintaining sustainable
work schedules. It‚Äôs a known fact that software companies often demand
long working hours, extensive overtime, and weekend commitments.
However, XP contests this practice, arguing instead for sustainable work
schedules, with around 40 hours per week, even before important
deliveries. Notably, XP was proposed by seasoned professionals with
experience in managing real-world software projects, and thus, they have
firsthand experience on the effects of prolonged working hours. Long
hours can be detrimental to developers‚Äô physical and mental health and
can also lead to high team turnover, with developers frequently
contemplating changing jobs.</p>
<p> <strong>Open Scope Contracts</strong>. Two types of contracts are
possible when outsourcing development: open scope and closed scope
contracts. Closed scope contracts requires the hiring company to provide
a specification of the requirements, even minimally. Based on that, the
outsourced company establishes a cost and a delivery date. XP questions
these contracts due to the volatile nature of software requirements and
the client‚Äôs inability to precisely define them in advance.
Consequently, the outsourced company may deliver a system with several
quality issues, including bugs, solely to avoid potential fines.</p>
<p>Conversely, open scope contracts are based on a pay-per-hour model.
For instance, an agreement might prescribe the allocation of a full-time
development team from the outsourced company, which will work in
accordance with XP practices. The client defines the stories and
validate their implementation at the end of each iteration. These
contracts also provide the flexibility for termination or renewal every
few months, enabling clients to switch companies should they find the
quality unsatisfactory. As usual in XP, the objective is to cultivate
communication and feedback streams between client and outsourced
companies, rather than compelling the latter to deliver a low-quality
product just to fulfill the contract. In summary, open scope contracts
align better with the Agile Manifesto, which recommends <q>customer
collaboration over contract negotiation</q>.</p>
<p> <strong>Process Metrics</strong>. To efficiently track an XP
project, managers and executives are encouraged to use two key metrics:
number of bug detected in production (ideally a few per year) and time
interval between project start and the project yielding its first
financial returns (ideally within one year).</p>
<h2 data-number="2.4" id="scrum-framework"><span
class="header-section-number">2.4</span> Scrum Framework <a
href="#scrum-framework" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> Scrum is an agile, iterative, and incremental method for project
management. It was first proposed by Jeffrey Sutherland and Ken Schwaber
in an article in 1995
([link]https://doi.org/10.1007/978-1-4471-0947-1_11)). Among various
agile methos, Scrum is probably the most popular and broadly applied.
Its widespread acceptance can be partly explained by the proliferation
of related books, educational courses, professional consultancies, and
credentials.</p>
<p>We begin this section by addressing an often-asked question: How do
Scrum and XP differ? There are a number of minor variations, but the key
difference lies in their purpose:</p>
<ul>
<li><p>XP is an agile method specifically designed for software
development projects. For this reason, it introduces a set of
programming practices, such as unit testing, pair programming,
continuous integration, and incremental design, which we have explored
in the previous section.</p></li>
<li><p>Scrum, however, is an agile method that isn‚Äôt confined to
software projects. For example, the creation of this book, as we will
explain shortly, was based on Scrum concepts. Having a broader scope
than XP, Scrum doesn‚Äôt specify any programming practices.</p></li>
</ul>
<p>Among the agile methods, Scrum stands out as the most
well-structured, including a well-defined set of <strong>roles</strong>,
<strong>artifacts</strong>, and <strong>events</strong>, which are
listed below. In the rest of this section, we will explain each of
them.</p>
<ul>
<li><p><strong>Roles</strong>: Product Owner, Scrum Master,
Developer.</p></li>
<li><p><strong>Artifacts</strong>: Product Backlog, Sprint Backlog,
Scrum Board, Burndown Chart.</p></li>
<li><p><strong>Events</strong>: Sprint Planning, Sprint, Daily Meetings,
Sprint Review, Retrospective.</p></li>
</ul>
</div>
</div>
</div>

<footer>
All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>.
</footer>
</body>
</html>
