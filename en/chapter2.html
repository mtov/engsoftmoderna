<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Chapter 2: Process ‚Äì Software Engineering: A Modern Approach</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <meta name="robots" content="noindex">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p> <h4>Disclaimer: This chapter is a beta version subjected to proofreading. </h4> </p>
<header id="title-block-header">
<h1 class="title">Software Engineering: A Modern Approach</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="2" id="processes"><span
class="header-section-number">2</span> Processes <a href="#processes"
class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>In software development, perfect is a verb, not an adjective.
There is no perfect process. There is no perfect design. There are no
perfect stories. You can, however, perfect your process, your design,
and your stories.</em> ‚Äì Kent Beck</p>
</blockquote>
<p> This chapter starts with a discussion on the importance of software
process (Section 2.1). Next, we discuss general and foundational aspects
of agile processes (Section 2.2), including a discussion into the
historical context that motivated the emergence of these processes. The
next sections focus on three agile methods: Extreme Programming (Section
2.3), Scrum (Section 2.4), and Kanban (Section 2.5). Following that, we
comment on scenarios where agile methods might not be the most
recommended processes (Section 2.6). Lastly, in Section 2.7, we briefly
present some traditional processes, such as the Unified Process.</p>
<h2 data-number="2.1" id="importance-of-processes"><span
class="header-section-number">2.1</span> Importance of Processes <a
href="#importance-of-processes" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>The production of a car in an automobile factory follows a
well-defined process. In simple terms, sheets of steel are initially cut
and pressed to shape doors, roofs, and hoods. Next, the car is painted
and components like the dashboard, seats, seat belts, and wiring are
installed. Finally, the mechanical parts, including the engine,
suspension, and brakes, are fitted.</p>
<p>Analogously, software production should follow a
<strong>process</strong>, although less mechanized and more dependent on
intellectual endeavor. A software development process defines a series
of steps, tasks, events, and practices that developers must observe
while developing a software system.</p>
<p> There are some who critique software processes and question their
need, often asking: <q>Why must I follow a process?</q> or <q>What
process did Linus Torvalds or Donald Knuth used when implementing the
Linux operating system or the TeX text formatter?</q></p>
<p>In reality, the second question above do not apply to our context as
both Linux (in its initial versions) and TeX were individual projects
led by a single developer. In such scenarios, following a process is
less important. Stated in better terms, the process followed in those
projects was a personal one, reflecting the principles, practices, and
experience of a single developer.</p>
<p>However, contemporary software systems are too complex to be
developed by a single developer. Thus, systems implemented by solitary
heroes are increasingly rare nowadays. In practice, modern systems‚Äîthe
focus of this book‚Äîare developed by <strong>teams</strong>.</p>
<p>However, these teams require at least a minimal set of rules to
produce quality software efficiently. That‚Äôs why software companies
invest so much in software processes. They serve as tools for companies
to coordinate, motivate, organize, and evaluate their developers,
ensuring at the same time productivity and alignment with the
organization‚Äôs goals. Without a process‚Äîeven a light and simplified one,
such as the agile methods we will study in this chapter‚Äîthere is a risk
that teams will work in a uncoordinated way, creating products with no
business value. Finally, processes not only benefit the company, but
they also serve developers by clarifying expected tasks and outcomes,
thus reducing misalignment among team members.</p>
<p>In this chapter, we explore various software processes. In fact, in
Chapter 1, we already presented a first introduction to Waterfall and
Agile methods. In the following sections, we will continue this
discussion and present three well-known Agile methods.</p>
<h2 data-number="2.2" id="agile-manifesto"><span
class="header-section-number">2.2</span> Agile Manifesto <a
href="#agile-manifesto" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> The earliest software development process‚Äîas the Waterfall process,
proposed in the 1970s‚Äîfollowed a sequential approach. Usually, projects
began with a requirement specification phase and ended with the
implementation, testing, deployment, and maintenance phases.</p>
<p>Given the historical context, this strictly sequential approach was
understandable. Indeed, traditional engineering projects are<br />
developed sequentially and are based on detailed and upfront planning.
Therefore, it‚Äôs not a surprise that the emerging Software Engineering
field mirrored the processes of longer-established domains like
Electronics, Civil, Mechanical, and Aeronautical Engineering, among
others.</p>
<p>However, by the 80s, the industry began to recognize that software is
different from other engineering products. The recurrent problems faced
by software projects at this time reinforced this conclusion. For
instance, such projects routinely overshot schedules and budgets. Some
were even abandoned after years of effort without delivering a
functioning system to customers.</p>
<p> The CHAOS Report published in 1994 by the Standish Group consulting
firm provided more details about the state of software projects at the
time. This report (<a
href="https://www.standishgroup.com/sample_research_files/chaos_report_1994.pdf">link</a>)
revealed that over 55% of projects surpassed their<br />
deadlines by 51% to 200%; and at least 12% exceeded the deadlines by
more than 200%, as shown in the next figure.</p>
<figure>
<img src="figs/cap2/chaos2-en.svg" style="width:90.0%"
alt="CHAOS Report (1994): percentage of projects exceeding their deadlines (for each range of overrun)" />
<figcaption aria-hidden="true">CHAOS Report (1994): percentage of
projects exceeding their deadlines (for each range of
overrun)</figcaption>
</figure>
<p>In terms of costs, almost 40% of the studied projects overshot their
budgets by 51% to 200%, as indicated in the following figure:</p>
<figure>
<img src="figs/cap2/chaos1-en.svg" style="width:90.0%"
alt="CHAOS Report (1994): percentage of projects exceeding their budgets (for each range of overrun)" />
<figcaption aria-hidden="true">CHAOS Report (1994): percentage of
projects exceeding their budgets (for each range of
overrun)</figcaption>
</figure>
<p>Therefore, in 2001, some industry professionals gathered in Snowbird,
Utah, to discuss and propose an alternative to the prevailing
Waterfall-based processes. They argued that, being different from
traditional engineering products, software requires a distinct
development process.</p>
<p>For instance, software requirements change more frequently than those
of a computer, airplane, or bridge. Moreover, customers often lack a
clear understanding of their needs. As a result, there is always a risk
of designing a product that will be obsolete by the time it‚Äôs finished
due to changing circumstances or customer needs. The professionals that
met at Utah also identified issues with the document-centric approach
advocated by Waterfall. At the time, requirements documents were
detailed, heavy, and dense, which contributes to making them obsolete
very quickly as developers would not update the documentation to reflect
requirement changes.</p>
<p>In response, the group proposed a new type of software process, which
was described in a document they named the <strong>Agile
Manifesto</strong>. The manifesto reads:</p>
<blockquote>
<p>Through this work, we have come to value:</p>
<p><strong>Individuals and interactions</strong> over processes and
tools</p>
<p><strong>Working software</strong> over comprehensive
documentation</p>
<p><strong>Customer collaboration</strong> over contract negotiation</p>
<p><strong>Responding to change</strong> over following a plan.</p>
</blockquote>
<p> Agile processes are characterized by short and iterative development
cycles. Systems are built incrementally, starting with the most relevant
features, according to customers. Initially, a first version of the
system is created, which implements only high-priority functionalities.
This version is then validated by the customer. If approved, a new
cycle‚Äîalso callled <strong>iteration</strong> or
<strong>sprint</strong>‚Äîbegins, adding a few more features. Typically,
these cycles are short, having two weeks, for example. This allows the
systems to be incrementally built, with each feature increment receiving
explicit approval by the customer. The development ends when all the
customer‚Äôs requests have been implemented.</p>
<p> The following figures present a comparison between Waterfall and
Agile methods:</p>
<figure>
<img src="figs/cap2/waterfall2-en.svg" style="width:90.0%"
alt="Development using a Waterfall process. The software is finished only at the end." />
<figcaption aria-hidden="true">Development using a Waterfall process.
The software is finished only at the end.</figcaption>
</figure>
<figure>
<img src="figs/cap2/agile-en.svg" style="width:90.0%"
alt="Development using an Agile process. Each iteration (represented by the rectangles) produces a product increment (S++), which is validated and tested by customers." />
<figcaption aria-hidden="true">Development using an Agile process. Each
iteration (represented by the rectangles) produces a product increment
(S++), which is validated and tested by customers.</figcaption>
</figure>
<p>However, the previous figures may suggest that in agile development,
each iteration replicates a mini-Waterfall process, encompassing all the
Waterfall phases. This isn‚Äôt accurate; generally, iterations in agile
methods aren‚Äôt a series of tasks like in Waterfall (more details in the
following sections). The figure may also suggest that a system must be
put into production at the end of each iteration. This is also
incorrect. Indeed, the objective is to deliver a functional system that
performs useful tasks. However, the decision to launch the software
involves other variables such as business risks, hardware resources
availability, marketing campaigns, user training, etc.</p>
<p>Other agile process characteristics include:</p>
<ul>
<li><p>Minimal emphasis on documentation: Only vital information should
be documented.</p></li>
<li><p>Less emphasis on detailed plans: At the start of a project, often
neither the customer nor the developers have a clear understanding of
all requirements that should be implemented. Such understanding
gradually unfolds as sprints are finished and validated. In other words,
the essence of agile development is to advance even when we have
incomplete, partial, and changing requirements.</p></li>
<li><p>No dedicated design phase, i.e., no Big Design Up Fron (BDUF):
The design of the software system is also incremental, evolving on each
iteration.</p></li>
<li><p>Small teams: Teams typically comprise about a dozen developers
or, as Amazon CEO Jeff Bezos phrased it, <q>teams that can be fed with
two pizzas</q>. We also like to say that the size of agile teams varies
between the size of a basketball team (5 members) to the one of a soccer
team (11 members).</p></li>
<li><p>Emphasis on novel programming practices (as in the early 2000s),
such as pair programming, automated testing, refactoring, and continuous
integration.</p></li>
</ul>
<p>Due to such characteristics, agile processes are considered
<strong>light processes</strong>, having few prescriptions and
documents.</p>
<p>However, the characteristics we presented above are still generic and
broad. Thus, to make agile principles more concrete and actionable,
several methods were proposed and defined. Interestingly, they were all
initially proposed before the 2001 Agile Manifesto‚Äôs meeting.
Particularly, in this chapter, we will study three agile methods:</p>
<ul>
<li><p>Extreme Programming (XP): Kent Beck proposed this method in a
1999 book (<a
href="https://dl.acm.org/citation.cfm?id=318762">link</a>). A second and
heavily revised edition was also released in 2004.</p></li>
<li><p>Scrum: This agile method was introduced by Jeffrey Sutherland and
Ken Schwaber in a 1995 article (<a
href="https://dl.acm.org/citation.cfm?id=260274">link</a>).</p></li>
<li><p>Kanban: This method originated from a production control system
implemented in Toyota‚Äôs factories in the 1950s (<a
href="https://hbr.org/1986/01/the-new-new-product-development-game">link</a>).
Over the past years, Kanban has been gradually adapted for software
development.</p></li>
</ul>
<p>It‚Äôs also important to understand that all development methods are
essentially a set of recommendations. Every organization should analyze
each one and decide if it‚Äôs suitable for their particular context.
Consequently, organizations might need to adapt any existing method to
their needs. For this reason, it‚Äôs rare to see two organizations that
follow exactly the same development process. For instance, even if they
say they‚Äôre using Scrum.</p>
<p><strong>In-Depth</strong>: The terms process and methods are often
used interchangeably. However, there are also subtle differences between
them. In our context, a process is a set of steps, events, and tasks
used to construct software. Every organization employs a process to
develop its systems, which can be Agile, Waterfall, or even a
<q>chaotic</q> one. However, a process always exists. On the other hand,
a method specifies a particular process (the term originates from Greek,
meaning <q>the means to achieve a goal</q>). Therefore, XP, Scrum, and
Kanban are agile methods or, put another way, they define practices,
activities, events, and techniques compatible with agile principles.</p>
<p></p>
<p><strong>Real World Insight</strong>: The widespread success and
impact of agile methods are noteworthy. At present, an overwhelming
majority of organizations, irrespective of their size or business
domain, follow agile principles to varying degrees. Here‚Äôs an
interesting statistic: in 2018, the Stack Overflow survey included a
question about the most used development methods (<a
href="https://insights.stackoverflow.com/survey/2018/#career-values">link</a>).
Over 57 thousand professional developers responded, and a majority
identified with agile methods or practices. This includes methodologies
we will study in this chapter‚Äîsuch as Scrum (63% responses), Kanban
(36%), and Extreme Programming (16%). Only 15% of participants answered
Waterfall as their development method.</p>
<h2 data-number="2.3" id="extreme-programming"><span
class="header-section-number">2.3</span> Extreme Programming <a
href="#extreme-programming" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> Extreme Programming (XP) is a lightweight method for developing
software with ever-changing or unclear requirements, such as the Type B
systems (Business), according to the classification described in Chapter
1. As any agile method, XP embodies characteristics like short iterative
development cycles, less emphasis on comprehensive documentation,
incremental design, and development in small teams.</p>
<p>In other words, XP is not a prescriptive method that proposes a
step-by-step plan for software construction. Instead, XP is defined by a
set of <strong>values</strong>, <strong>principles</strong>, and
<strong>practices</strong>. The values and principles are important to
shape the culture of software development teams. Then, they are
materialized into a list of development practices. Often, when deciding
to adopt XP, developers and organizations tend to focus on the
practices. However, the values and principles are key components of the
method, as they give meaning to the practices proposed by XP. To be
clear, if an organization is unprepared to embrace the XP mindset‚Äîas
represented by its values and principles‚Äîit should not invest time in
adopting the practices.</p>
<p>In this chapter, we will first present the values and principles
defended by XP. Here is a list of them:</p>
<ul>
<li><p><strong>Values</strong>: Communication, simplicity, feedback,
courage, respect, and quality of life.</p></li>
<li><p><strong>Principles</strong>: Humanity, economics, mutual
benefits, continuous improvements, acknowledging failures, baby steps,
and personal responsibility.</p></li>
</ul>
<p>Next, we‚Äôll explain the practices, which we organize into three
groups: process practices, programming practices, and project management
practices. Here is a list of the practices within each group:</p>
<ul>
<li><p><strong>Process Practices</strong>: Customer representative, user
stories, iterations, releases, release planning, iteration planning,
planning poker, and slacks.</p></li>
<li><p><strong>Programming Practices</strong>: Incremental design, pair
programming, test-driven development (TDD), automated builds, continuous
integration.</p></li>
<li><p><strong>Project Management Practices</strong>: Metrics, working
environment, open-scope contracts.</p></li>
</ul>
<h3 data-number="2.3.1" id="values"><span
class="header-section-number">2.3.1</span> Values <a href="#values"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> XP advocates that software projects should be guided by three main
values: communication, simplicity, and feedback. Indeed,<br />
these values are important in any human collaboration effort. Good
<strong>communication</strong> is important not only to avoid mistakes
but also to learn from them. The second XP value is
<strong>simplicity</strong>, as in every complex and challenging
software system there is a simpler system that is sometimes overlooked.
Lastly, continuous <strong>feedback</strong> from stakeholders
counterbalances risks like changing requirements and technologies.</p>
<p>In fact, it is difficult to develop the <q>right</q> software system
at the first attempt. Frederick Brooks has a well-known recommendation
regarding this problem:</p>
<blockquote>
<p><em>Plan to throw away parts of your system, because you
will.</em></p>
</blockquote>
<p>Thus, feedback is an essential value to ensure that the software
parts that are going to be discarded are identified as early as
possible, to reduce waste and rework. Besides, XP also defends other
values such as <strong>courage</strong>, <strong>respect</strong>, and
<strong>quality of life</strong>.</p>
<h3 data-number="2.3.2" id="principles"><span
class="header-section-number">2.3.2</span> Principles <a
href="#principles" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> While XP‚Äôs values are abstract, its practices are concrete and
pragmatic. To bridge this gap between values and practices, XP
encourages following a set of principles. Picture it as a river with the
values on one side and the practices on the other. Principles act as a
bridge between both sides. The main XP principles are:</p>
<p><strong>Humanity</strong>. Software is a activity that depends on
human capital. The principal resource of software companies are not
physical assets‚Äîcomputers, buildings, chairs, or Internet connections,
for example‚Äîbut their developers. A term that nicely reflects the
importance of this principle is <em>peopleware</em>, which was coined by
Tom DeMarco in a book with the same title (<a
href="https://dl.acm.org/citation.cfm?id=2505459">link</a>). The idea is
that managing people‚Äîincluding factors such as expectations, growth,
motivation, and responsibilities‚Äîis essential for the success of
software projects.</p>
<p><strong>Economics</strong>: Software development requires substantial
financial investment. Hence, it‚Äôs not merely an intellectual pursuit; it
must deliver economic results, particularly in the case of Type B
(Business) systems, according to the classification we studied in
Chapter 1.</p>
<p><strong>Mutual Benefits</strong>: XP advocates that decisions taken
in a software project should benefit multiple stakeholders. For example,
a software company should ensure a good work environment; in return, the
team should deliver a software that adds value to its business. Another
example: by writing tests a developer benefits, as tests help to detect
bugs in her code. But tests also help other developers, who will be more
confident that their code does not introduce regressions, i.e., bugs in
previously working code. A third and last example: refactoring makes
code cleaner and easier to understand, both for the developer who wrote
it and for a developer who in the future will have to maintain it.</p>
<p><strong>Continuous Improvements</strong>: As expressed in the quote
by Kent Beck opening this chapter, no software development process is
perfect. Therefore, what we should aim is a process that is under
continuous improvement, at each iteration, with feedback from clients
and team members. For the same reason, XP does not recommend investing a
large amount of time in an initial and complete design. Instead, the
software‚Äôs design is also incremental, improving at each iteration.
Finally, the programming practices themselves can be improved; for this,
the team should set aside time to discuss and reflect on them.</p>
<p><strong>Failures Happen</strong>: Software development is not a
risk-free endeavor. As discussed in Chapter 1, software is one of the
most complex human constructions. Thus, failures are expected in
software projects, including major bugs, features that did not attracted
users, and issues with non-functional requirements, such as performance,
usability, privacy, availability, etc. Evidently, XP does not advocate
covering up these failures. However, they should not be used to punish
team members. On the contrary, failures are part of the game if a team
aims to deliver software that solves problems at the right time.</p>
<p><strong>Baby Steps</strong>: A secure, tested, and validated
progress, albeit small, is better than large software increments with
risks of being discarded by the users. The same applies to tests (which
are useful even when the units under test are small, such as individual
methods), code integration (it‚Äôs better to integrate daily, than to go
through the stress of a major integration after weeks of work) and
refactorings (which should occur in small steps intercalated with
running the tests). In summary, it‚Äôs important to focus on continuous
improvements, no matter how small, as long as they‚Äôre in the right
direction. Indeed, in software engineering, <q>baby steps</q> are
usually better than major changes, which tend to be risky and may not
lead to positive outcomes.</p>
<p><strong>Personal Responsibility</strong> (or accepted
responsibility): According to this principle, developers should have a
clear idea of their role and responsibility in the team. The reason is
that responsibility cannot be transferred without the other party
accepting it. For a similar reason, XP advocates that the developer who
implements a <em>user story</em>‚Äîi.e., a small feature increment‚Äîshould
also be also the one who will test and maintain it.</p>
<p></p>
<p><strong>Real World Insight</strong>: One of the first systems to
adopt XP was a payroll system for the car manufacturer Chrysler, called
Chrysler Comprehensive Compensation (C3) system (<a
href="https://doi.org/10.1109/2.796139">link</a>). The project began in
early 1995 and, as it failed to deliver concrete results, it was
restarted the following year under the leadership of Kent Beck. Another
well-known member of the agile community, Martin Fowler, participated in
the project as a consultant. While building the C3 system, many facets
of the soon-to-be-named XP method were defined and experimented
with.</p>
<h3 data-number="2.3.3" id="process-practices"><span
class="header-section-number">2.3.3</span> Process Practices <a
href="#process-practices" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Just like other agile methodologies, XP recommends direct client
involvement in the project, not limiting the team members to developers
only. When using XP, teams should include one <strong>customer
representative</strong> who is an expert on the domain of the system
under development. This representative should propose and write the
<strong>user stories</strong>, which are XP‚Äôs version of requirement
specification documents. However, user stories are rather short and
lightweight documents, comprising two to three sentences, in which the
customer representative describes the features the system should
implement.</p>
<p>We‚Äôll examine user stories more closely in Chapter 3. For now, we
should note that they are usually written on cards, by hand or using
project management tools. As we mentioned, they are simple documents
focusing on the key features of the system from a user perspective, as
opposed to complex requirement documents, which are used for example
with Waterfall-based approaches.</p>
<p>Here‚Äôs an example of user story for a Question &amp; Answer (Q&amp;A)
forum app‚Äîsimilar to Stack Overflow‚Äîwhich we‚Äôll use to present XP in
this chapter.</p>
<table style="width:90%;">
<colgroup>
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Post Question</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>A logged-in user should be able to
post questions. Since it‚Äôs a programming forum, questions may
incorporate code blocks, which must be presented in a differentiated
layout.</em></td>
</tr>
</tbody>
</table>
<p>Note that the story has a title (Post Question) and a brief
description in two sentences. These stories serve as reminders for
subsequent detailed verbal specifications by the customer
representative. In other words, developers can at any time consult the
customer representative to clarify issues about user stories.</p>
<p>After creation by the customer representative, developers should
estimate the effort required for implementing the stories. This
estimation is often performed in <strong>story points</strong>, instead
of hours or man-days. An integer scale is used in these cases to label
stories as having a certain number of story points. The simplest stories
are marked as having one story point. If a story is twice as complex, it
is marked with two story points, and so on. Indeed, story points are
commonly defined by a Fibonacci sequence, such as 1, 2, 3, 5, 8, 13. The
goal is to use a scale that makes the stories progressively harder and
also allows the team to make comparisons similar to the following one:
in terms of effort, is a task that has 8 story points equivalent to a
task with 5 story points plus a task with 3 points (i.e., the two
previous marks in the scale)? If yes, 8 story points is a good estimate.
If not, it is better to estimate the story with 5 story points.</p>
<p> </p>
<p><strong>In-Depth</strong>: A technique for estimating story points is
called <strong>Planning Poker</strong>. Here‚Äôs how it works: the
customer representative selects a story, reads it to the developers, who
can discuss it with the representative to clarify any doubts. After
that, each developer independently estimates the story‚Äôs size in story
points, and then everyone simultaneously reveals their estimates using
previously distributed cards with numbers 1, 2, 3, 5, etc. If there is
consensus, the team moves to the next story. If not, there is a
discussion and further voting until common ground is found.</p>
<p> The user stories are implemented in
<strong>iterations</strong>‚Äîwhich have a fixed duration, usually ranging
between one to three weeks. These iterations are also organized in
longer cycles, referred to as <strong>releases</strong>, typically
lasting two to three months. A team‚Äôs <strong>velocity</strong> is the
number of story points it can implement within an iteration. The
customer representative should propose and create stories that take at
least one release to implement. Hence, in XP, the planning horizon is
one release, which may span a few months.</p>
<p><strong>Note</strong>: The term release in XP differs from its usage
in configuration management where it refers to a version of a system
that is available for usage. However, the version produced at the end of
a release in XP does not necessarily need to go into production.</p>
<p>To summarize, to initiate the use of XP, an organization should:</p>
<ul>
<li>Define the duration of an iteration.</li>
<li>Define the number of iterations in a release.</li>
<li>Set a list of stories, as proposed the customer representative.</li>
<li>Get estimates for each story from the developers.</li>
<li>Define the team‚Äôs velocity, that is, the number of story points that
it can implement per iteration</li>
</ul>
<p>Upon defining the above aspects, the customer representative must
prioritize the stories. To do this, the representative must select the
stories to be implemented in each iteration of the first release. In
this prioritization, the team‚Äôs velocity should be taken into account.
For example, assume that a team has a velocity of 25 story points per
iteration. In this case, the customer representative cannot allocate
stories to an iteration whose combined story points exceed this limit.
The process of assigning stories to iterations and releases is known as
<strong>release planning</strong> or planning game, which is the term
used in the first edition of the XP book.</p>
<p>For example, consider the Q&amp;A forum we used earlier. The next
table summarizes the outcome of a possible release planning. In this
example, we are assuming that the customer representative wrote 8
stories, that each release has two iterations, and that the team‚Äôs
velocity is 21 story points per iteration (note that the sum of the
story points of each iteration is exactly 21).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Story</strong></th>
<th style="text-align: center;"><strong>Story Points</strong></th>
<th style="text-align: right;"><strong>Iteration</strong></th>
<th style="text-align: center;"><strong>Release</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Register user</td>
<td style="text-align: center;">8</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Post questions</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Post answers</td>
<td style="text-align: center;">3</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Opening screen</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Gamify questions/answers</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Search questions/answers</td>
<td style="text-align: center;">8</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Add tags</td>
<td style="text-align: center;">5</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Comment on questions/answers</td>
<td style="text-align: center;">3</td>
<td style="text-align: right;">2</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>The table emphasizes two points: (1) the stories in XP represent the
main features of the intended system; (2) developers have no control on
the order of story implementation; this is decided by the customer
representative, who must be someone capable and with authority to define
the most urgent and important features for the organization contracting
the development.</p>
<p>After the release planning, the iterations start. At the beginning of
each iteration, the development team must meet to conduct an
<strong>iteration planning</strong>. The purpose of this planning is to
decompose the stories of an iteration into tasks that can be assigned to
one of the team‚Äôs developers. For example, the <em>Post questions</em>
story can be decomposed into the following tasks:</p>
<ul>
<li>Design and test the web interface, including layout, CSS templates,
etc.</li>
<li>Install the database server, as well as design and create the
database tables.</li>
<li>Implement the data access layer.</li>
<li>Install and test the web server framework.</li>
<li>Implement the control layer, with endpoints to register, remove, and
update questions.</li>
<li>Implement the Web interface.</li>
</ul>
<p>Generally, tasks should not be complex and should be completed in a
few days.</p>
<p>So, an XP project encompasses:</p>
<ul>
<li>Releases, which are groups of iterations spanning a few months</li>
<li>Iterations, which are groups of stories and respective tasks,
lasting a few weeks</li>
<li>Tasks, which take a few days to complete</li>
</ul>
<p>Once the tasks are created, the team should also decide who is
responsible for each one. With that, the iteration begins with task
implementation.</p>
<p>An iteration concludes when all its stories have been implemented and
validated by the customer representative. Therefore, at an iteration‚Äôs
end, the stories should be demonstrated to the customer representative,
who must check and confirm their implementations.</p>
<p> XP also proposes that teams should program <strong>slack</strong>
tasks, or tasks that can be postponed, during an iteration. Examples
include studying a new technology, taking an online course, improving
documentation, or even developing a side project. In fact, companies
like Google are renowned for allowing developers to use 20% of their
time for personal projects (<a
href="https://arxiv.org/abs/1702.01715">link</a>). In XP, slack tasks
have two primary objectives: (1) create a buffer that can be used should
a task require more time than estimated and (2) allow developers some
downtime from the demanding and intense project pace.</p>
<h4 class="unnumbered" id="frequently-asked-questions">Frequently Asked
Questions <a href="#frequently-asked-questions" class="anchor-link"
aria-hidden="true">üîó</a></h4>
<p>Now let‚Äôs answer some questions about the XP practices we have just
studied.</p>
<p><strong>How long should an iteration be?</strong> There isn‚Äôt a
definitive answer as numerous factors such as team characteristics,
system domain, and requirements all play a part. Short
iterations‚Äîtypically a week long‚Äîoffer quick feedback. However, they
also require more client involvement as new software increments need
weekly validation. Moreover, stories must be simple and straightforward
to fit in a 1-week iteration. Conversely, longer iterations‚Äîlike a
month‚Äîgrant the team more time to plan and execute tasks with less
pressure. The trade-off here is delays in receiving client feedback,
which is particularly relevant when the requirements are unclear. As a
result, a 2-3 week time box tends to provide a balance between rapid
feedback and less pressure on the team. Another useful recommendation is
to experiment, meaning testing and evaluating different durations before
settling on one.</p>
<p><strong>What role does the customer representative play during
iterations?</strong> At the beginning of a release, the customer
representative drafts the stories to be included in that release. They
then validate and approve the implementation of these stories at the end
of each iteration. The representative also needs to be readily available
during iterations to address questions the team may have. Given that
user stories contain only a few sentences, these questions might
naturally arise.</p>
<p><strong>How do we select the customer representative?</strong> The
most important criteria are that the person has a solid understanding of
the system‚Äôs domain and authority to prioritize user stories. There are
at least three potential scenarios for customer representatives:</p>
<ul>
<li><p>Consider a team developing a system for a department within their
own company. In this scenario, the customer representative might be an
employee from that client department.</p></li>
<li><p>Consider a team developing a system for a different company.
Here, the customer representative should ideally be an employee from
that client company who has knowledge of the software domain.</p></li>
<li><p>Consider a team creating a product for any client. The customer
representative in this case should be someone from the marketing, sales
or business sectors. Meaning, they should be closely aligned with the
problem but distant from the solution. For this reason, it‚Äôs preferable
not having a developer in this role. This type of representative is
often called a <strong>user proxy</strong>.</p></li>
</ul>
<p> <strong>How to define the team‚Äôs velocity?</strong> There is no
silver bullet for this issue. This definition depends on the team‚Äôs
experience. If the team members have already participated in projects
similar to the one they are starting, this is a less difficult question.
Otherwise, the team will need to test and calibrate their velocity
throughout successive iterations.</p>
<p><strong>Can stories refer to software engineering
activities?</strong> No, as the customer representative‚Äîwho is a
non-software engineering expert‚Äîis the one responsible for defining the
stories. However, a story could trigger the necessity for a task like
<q>install and test the database</q>. In essence, stories refer to
functional requirements. On the other hand, the tasks created for
implementing these stories might relate to functional requirements,
non-functional requirements or technical tasks such as database or
framework installation.</p>
<p><strong>What if story X is prioritized before Y, despite depending on
Y?</strong> For instance, the customer representative has allocated the
story <q>Post Question</q> to iteration 2 and <q>Post Answer</q> to
iteration 1. Although it seems contradictory, the team should respect
this order as the final decision always lies with the customer
representative. But then the dilemma might be <q>how can we post
responses without having the questions?</q> To resolve this problem,
placeholder questions that can‚Äôt be edited by users can be used. In
iteration 1, these questions will appear by default and users will be
able to respond to them.</p>
<p><strong>When does an XP project conclude?</strong> The project ends
when the customer representative decides the already implemented stories
to be adequate and that there are no more relevant stories to be
implemented.</p>
<h3 data-number="2.3.4" id="programming-practices"><span
class="header-section-number">2.3.4</span> Programming Practices <a
href="#programming-practices" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>The name Extreme Programming was chosen due to the novel programming
practices the method proposed at the end of the 90‚Äôs. The essence of XP
revolves around its emphasis on many programming practices and on the
production of running code since the first weeks of a project. The
importance of this fact can be better understood within the context of
the 90‚Äôs where distinct roles for analysts and programmers were the
norm. Analysts at that time were responsible for designing the
high-level system, defining its main components, classes, and interfaces
using graphical modeling languages, like UML, which we will discuss in
Chapter 4. Only upon completion of the analysis and design phases, the
coding phase would start under the responsibility of programmers. This
setup inherently created a hierarchy, with analysts often being regarded
as the more prestigious roles. However, with the introduction of agile
methodologies‚Äîparticularly XP‚Äîthis hierarchy was dismantled, since XP
advocates for starting coding<br />
at a project‚Äôs outset.</p>
<p>Simultaneously, to counteract the risk of low-quality code
production, XP introduced a novel set of programming practices. These
practices included pair programming, automated testing, test-driven
development (TDD), automated builds, and continuous integration, among
others. Most of these practices have been widely accepted within the
software industry, and are extensively used nowadays even by projects
not entirely adhering to agile principles.</p>
<p>We will now look at XP‚Äôs programming practices.</p>
<p> <strong>Incremental Design.</strong> XP projects do not have a
traditional design phase, known as <em>Big Design Up Front</em> (BDUF).
Instead, XP promotes the idea of making design a continuous and
incremental activity. This approach aims to address issues that arise
when an entire design activity is confined to the beginning of a
project. This is a stage where the project‚Äôs requirements tend to be
unclear both to the team and to the clients, leading to overestimating
or underestimating their value. Moreover, new requirements may come up
as the project progresses, making the initially intended design
obsolete.</p>
<p>For this reason, XP contends that the best time to contemplate the
design is when it becomes crucial. Two key phrases often used to
encourage and justify this practice are: <em>Do the simplest thing that
could possibly work</em> and <em>you aren‚Äôt going to need it</em>, the
latter known by the acronym YAGNI.</p>
<p>For a better understanding of the incremental design approach
proposed by XP, two points need to be highlighted. Firstly, proficient
teams often already have a design in mind before the first iteration.
This might include knowing that the system will have a web interface, a
set of backend components for implementing complex business logic and
also components for accessing a relational database. These decisions, by
themselves, cover and solve major system‚Äôs design concerns. Secondly, at
any iteration, the team can also allocate a technical task to discuss
and refine the system‚Äôs design.</p>
<p>Finally, it‚Äôs crucial to note that the concept of incremental design
is viable only when used in conjunction with other XP practices,
especially <strong>refactoring</strong>. XP insists on the importance of
refactoring to enhance the design‚Äôs quality. Hence, every opportunity to
refactor should put be in practice without delay.</p>
<p> <strong>Pair Programming</strong>. Accompanied by incremental
design, pair programming stands out as one of the most controversial
practices proposed by Extreme Programming. The concept is
straightforward: every coding task, whether it‚Äôs implementing a user
story, implementing a testing, or fixing a bug, should be conducted by
two developers working together, using the same keyboard and monitor.
One developer takes on the role of <strong>driver</strong>, controlling
the keyboard and mouse, while the other acts as a
<strong>navigator</strong> or reviewer. The navigator monitors the
driver‚Äôs code, providing feedback and direction, similar to a car rally
team.</p>
<p>Pair programming aims to enhance code quality and internal design,
guided by the principle that <q>two heads are better than one.</q> It
also aids in spreading code knowledge within a team, preventing
knowledge silos where only one developer understands a specific part of
the code. The practice also provides a valuable training tool for less
experienced developers, offering exposure to various programming
technologies, algorithms, data structures, design patterns, and
principles, testing and debugging techniques, etc.</p>
<p>However, employing two developers per task has economic implications,
as usually commented by pair programming critics. Also, for some
developers it is emotionally and cognitively uncomfortable to discuss
each line of code and each implementation decision with a colleague. To
mitigate this, XP recommends to rotate pairs at every session. These
sessions are typically 50 minutes long, followed by a 10-minute break.
In the following session, both pairs and roles (driver vs.¬†navigator)
switch.</p>
<p></p>
<p><strong>Real World Insight:</strong> In 2008, Microsoft Research‚Äôs
Andrew Begel and Nachiappan Nagappan surveyed 106 company developers
about their experiences with pair programming (<a
href="https://doi.org/10.1145/1414004.1414026">link</a>). Approximately
65% of the respondents found pair programming beneficial. When asked
about the advantages, reduced bugs (62%), better code quality (45%),
knowledge spread (40%), and peer learning opportunities (40%) received
most votes. However, 75% regarded the associated cost as a significant
disadvantage. Lastly, the majority (38%) preferred pairing with a
colleague having complementary skills to compensate for their
weaknesses.</p>
<p> In recent times, many software companies embraced the practice of
<strong>code review</strong>. In this case, another developer checks a
developer‚Äôs code asynchronously, avoiding the need for two developers
working at the same time on the same code.</p>
<p> <strong>Collective Code Ownership</strong>. According to this
practice, any developer or pair of developers can modify any part of the
code‚Äîto implement a new feature, fix a bug, or perform a
refactoring‚Äîwithout needing approval from the original code developer or
whoever last maintained it.</p>
<p> <strong>Automated Testing</strong>. This is one of the programming
practices advocated by XP that reached the greatest success. The
rationale is that manual testing‚Äîwhen a tester runs the program,
provides inputs and checks the outputs‚Äîis a costly procedure that cannot
be reproduced at every moment. Therefore, XP proposes the implementation
of programs‚Äîcalled automated tests‚Äîthat call units of a system code,
such as methods, and verify if the results are the ones expected.
Automated testing‚Äôs advent coincided with the development of the first
unit testing frameworks, including JUnit (developed by Kent Beck and
Erich Gamma in 1997), which was very important to promote the practice.
We reserve a detailed discussion about automated tests for Chapter
8.</p>
<p> <strong>Test-Driven Development (TDD).</strong> TDD is another
innovative programming practice proposed by XP where every method should
first have a test before its actual implementation begins. This practice
serves two main purposes: (1) it ensures that developers do not forget
to write tests because they are implemented first, and (2) by writing a
test first, developers put themselves in the method‚Äôs user‚Äôs shoes. For
example, they have to consider the method‚Äôs interface and how it should
be called before approaching the actual implementation. This encourages
the creation of more user-friendly methods. We will discuss TDD in more
detail in Chapter 8.</p>
<p> <strong>Automated Build</strong>. This practice refers to the
automated generation of an executable system version ready for
production. Several tools can be used for this process, such as the Make
system, a part of Unix distributions since the 1970s, or newer tools
like Ant, Maven, Gradle, Rake, MSBuild, etc. XP promotes two key
concepts about the build process. First, to avoid manual intervention
from developers, it should be fully automated. Second, the build process
should be as quick as possible to provide developers with prompt
feedback about possible problems, such as compilation errors or failing
tests.</p>
<p> <strong>Continuous Integration</strong>. As we discussed in Chapter
1, version control systems (VCS) such as Git are widely used nowadays. A
VCS stores the source code and related files, including configuration
files, images, and documentation. To work on a task, developers
<em>pull</em> the source code to their local machines, make
modifications, and then <em>push</em> the updated code back to the VCS.
This upload and merge step is referred to as
<strong>integration</strong>.</p>
<p>However, integration is subjected to conflicts when multiple
developers change the same lines of code. In such cases, the VCS
prevents integration. For example, if Developer A assigns a value of 10
to a variable <em>x</em>, whilst Developer B, working independently,
assigns <em>x</em> a value of 20, a conflict is created. To resolve this
conflict, A and B must agree on the correct value for <em>x</em>. This
is a simple example, but conflicts often involve larger sections of code
and more developers, making them time-consuming and challenging to
resolve and leading to situations known as <strong>integration
hell</strong>.</p>
<p>To minimize integration conflicts, XP encourages developers to
integrate their code frequently‚Äîdaily, if possible‚Äîunder a practice
known as <strong>continuous integration</strong>. The aim is to reduce
the number of conflicts and the time developers spend on resolving
them.</p>
<p>To check the quality of the code that is integrated, we should also
configure a <strong>continuous integration service</strong>. Before
carrying out any integration, this service builds the code and executes
the tests. The aim is to ensure that the new code does not have
compilation errors and that it passes all the tests. Examples of these
services include GitHub Actions, Jenkins, TravisCI, CircleCI, and more.
In Chapter 10, we will delve deeper into Continuous Integration.</p>
<p><strong>Real World</strong>: In 2010, Laurie Williams, a professor at
the University of North Carolina in the USA, surveyed 326 developers
about their experiences with agile methodologies (<a
href="https://doi.org/10.1145/2133806.2133823">link</a>). Participants
ranked the importance of various agile practices on a scale of 1 to 5,
with five denoting essential practices. Three practices tied for first
place with an average score of 4.5 and a standard deviation of 0.8:
continuous integration, short iterations (less than 30 days), and
definition of done criteria (i.e., the criteria used to consider the
implementation of user stories finished). Conversely, planning poker and
pair programming were ranked lower, with average scores of 3.1 and 3.3,
respectively.</p>
<h3 data-number="2.3.5" id="project-management-practices"><span
class="header-section-number">2.3.5</span> Project Management Practices
<a href="#project-management-practices" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> <strong>Working Environment</strong>. XP advocates for the
development of software by small, dedicated teams, ideally composed of
fewer than 10 developers. It also discourages scenarios where team
members split their time between multiple projects during the week.</p>
<p>Furthermore, XP emphasizes the importance of maintaining sustainable
work schedules. It‚Äôs a known fact that software companies often demand
long working hours, extensive overtime, and weekend commitments.
However, XP contests this practice, arguing instead for sustainable work
schedules, with around 40 hours per week, even before important
deliveries. Notably, XP was proposed by seasoned professionals with
experience in managing real-world software projects, and thus, they have
firsthand experience on the effects of prolonged working hours. Long
hours can be detrimental to developers‚Äô physical and mental health and
can also lead to high team turnover, with developers frequently
contemplating changing jobs.</p>
<p> <strong>Open Scope Contracts</strong>. Two types of contracts are
possible when outsourcing development: open scope and closed scope
contracts. Closed scope contracts requires the hiring company to provide
a specification of the requirements, even minimally. Based on that, the
outsourced company establishes a cost and a delivery date. XP questions
these contracts due to the volatile nature of software requirements and
the client‚Äôs inability to precisely define them in advance.
Consequently, the outsourced company may deliver a system with several
quality issues, including bugs, solely to avoid potential fines.</p>
<p>Conversely, open scope contracts are based on a pay-per-hour model.
For instance, an agreement might prescribe the allocation of a full-time
development team from the outsourced company, which will work in
accordance with XP practices. The client defines the stories and
validate their implementation at the end of each iteration. These
contracts also provide the flexibility for termination or renewal every
few months, enabling clients to switch companies should they find the
quality unsatisfactory. As usual in XP, the objective is to cultivate
communication and feedback streams between client and outsourced
companies, rather than compelling the latter to deliver a low-quality
product just to fulfill the contract. In summary, open scope contracts
align better with the Agile Manifesto, which recommends <q>customer
collaboration over contract negotiation</q>.</p>
<p> <strong>Process Metrics</strong>. To efficiently track an XP
project, managers and executives are encouraged to use two key metrics:
number of bug detected in production (ideally a few per year) and time
interval between project start and the project yielding its first
financial returns (ideally within one year).</p>
<h2 data-number="2.4" id="scrum"><span
class="header-section-number">2.4</span> Scrum <a href="#scrum"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> Scrum is an agile, iterative, and incremental method for project
management. It was first proposed by Jeffrey Sutherland and Ken Schwaber
in an article in 1995 (<a
href="https://doi.org/10.1007/978-1-4471-0947-1_11">link</a>). Among
various agile methos, Scrum is probably the most popular and broadly
applied. Its widespread acceptance can be partly explained by the
proliferation of related books, educational courses, professional
consultancies, and certifications.</p>
<p>We begin this section by addressing an often-asked question: How do
Scrum and XP differ? There are a number of minor variations, but the key
difference lies in their purpose:</p>
<ul>
<li><p>XP is an agile method specifically designed for software
development projects. For this reason, it introduces a set of
programming practices, such as unit testing, pair programming,
continuous integration, and incremental design, which we have explored
in the previous section.</p></li>
<li><p>Scrum, however, is an agile method that isn‚Äôt confined to
software projects. For example, the creation of this book, as we will
explain shortly, was based on Scrum concepts. Having a broader scope
than XP, Scrum doesn‚Äôt specify any programming practices.</p></li>
</ul>
<p>Moreover, among the agile methods, Scrum stands out as the most
well-structured, including a well-defined set of <strong>roles</strong>,
<strong>artifacts</strong>, and <strong>events</strong>, which are
listed below. In the rest of this section, we will explain each of
them.</p>
<ul>
<li><p><strong>Roles</strong>: Product Owner, Scrum Master,
Developer.</p></li>
<li><p><strong>Artifacts</strong>: Product Backlog, Sprint Backlog,
Scrum Board, Burndown Chart.</p></li>
<li><p><strong>Events</strong>: Sprint Planning, Sprint, Daily Meetings,
Sprint Review, Retrospective.</p></li>
</ul>
<h3 data-number="2.4.1" id="roles"><span
class="header-section-number">2.4.1</span> Roles <a href="#roles"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> A Scrum team is composed of a Product Owner, a Scrum Master, and
between three to nine developers.</p>
<p> The <strong>Product Owner</strong> is equivalent to the customer
representative in XP. Their role requires having a clear vision for the
product being developed, in order to maximize the return on investment
for the project. Their responsibilities also include writing user
stories, and hence, they should always be available to address the
team‚Äôs questions.</p>
<p> The <strong>Scrum Master</strong> is a role unique to Scrum. They
are the team‚Äôs Scrum expert and their responsibility involves ensuring
adherence to the Scrum methodology. They should continuously train and
educate the team members on Scrum principles and work as a facilitator
to remove obstacles. For instance, if a team encounters issues with a
faulty database server, it is the Scrum Master‚Äôs role to ensure this
issue is resolved promptly to avoid hindering the team‚Äôs progress.
However, it‚Äôs crucial to note that a Scrum Master is not a traditional
project manager‚Äîthey do not lead the team, as Scrum teams operate on a
non-hierarchical basis.</p>
<p>Scrum teams are often described as <strong>cross-functional</strong>
or multidisciplinary, implying they should have all necessary
specialists for developing the product, thus avoiding dependencies on
external team members. In software projects, this includes specialists
such as front-end developers, back-end developers, database specialists,
and UI designers. These experts are responsible for the technical
decisions during the project, including defining the programming
language, architecture, and frameworks to be used in the implementation.
They are also responsible for estimating the size of the stories
proposed by the Product Owner, using units such as story points, similar
to what we studied in XP.</p>
<h3 data-number="2.4.2" id="artifacts-and-events"><span
class="header-section-number">2.4.2</span> Artifacts and Events <a
href="#artifacts-and-events" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Scrum defines two key artifacts known as the Product Backlog and the
Sprint Backlog. The key events include sprints and sprint planning,
which we will detail below.</p>
<ul>
<li><p>The <strong>Product Backlog</strong> is composed of a prioritized
list of user stories (along with other relevant work items). Much like
XP, the Product Owner is responsible for proposing these stories, which
are just short descriptions of the features the system should have. It‚Äôs
also worth noting that the Product Backlog is not static. It constantly
requires updates to capture changes to requirements and the overall
product vision. For instance, as the project advances, new feature ideas
may come up while some may no longer hold relevance. These changes are
under the responsibility of the Product Owner‚Äîa role which has this
title precisely for maintaining the Product Backlog.</p></li>
<li><p><strong>Sprint</strong> refers to an iteration in Scrum. Like all
agile methods, Scrum employs an iterative approach, organizing the
development into sprints, each one lasting up to a month. Every sprint
should yield a product increment that has tangible value for the
customer, called a potentially shippable product. The term
<q>potential</q> indicates that transitioning the product to production
is not mandatory, as we previously elaborated in Section 2.2.</p></li>
<li><p><strong>Sprint Planning</strong> is a preparatory meeting that
serves as the launchpad for every sprint. In this meeting, the team
decides the stories to be incorporated in the forthcoming sprint. This
meeting comprises two main parts. Initially, the Product Owner suggests
stories for the upcoming sprint, while the remaining team members
evaluate whether they have enough <strong>velocity</strong> (or
capacity) to implement them. In the second part, driven by the
developers, the selected stories are decomposed into tasks and their
execution times are estimated. The Product Owner should be present in
both parts of the sprint planning to answer questions about the selected
stories. In some circumstances, the team may decide to cancel a story,
as it proved to be more complex when broken down into tasks.</p></li>
<li><p>The <strong>Sprint Backlog</strong> is an artifact generated at
the conclusion of the Sprint Planning. It is a list of tasks for the
sprint, each with its respective duration. Like the Product Backlog, the
Sprint Backlog is also a dynamic entity. Tasks may be declared
unnecessary or new ones may be created throughout the sprint, and the
estimated effort for each task can also be adjusted if needed. However,
the <strong>sprint goal</strong>‚Äîthe stories selected by the Product
Owner for the sprint, which the development team has committed to
implement‚Äîshould not change. Thus, while Scrum is adaptable to changes,
they should occur between sprints. During a sprint, the development team
should have the stability and assurance to work on a fixed list of
stories.</p></li>
</ul>
<p>When the sprint planning concludes, the sprint begins, meaning the
team starts working on the tasks in the sprint backlog. At this point,
it‚Äôs also worth mentioning that Scrum teams are not only
cross-functional but also <strong>self-organizing</strong>, i.e., they
have the autonomy to decide how and who will implement the stories.</p>
<p> </p>
<p>In addition to the sprint backlog, teams can use a board with columns
denoting individual story stages, e.g., <em>to do</em>, <em>doing</em>,
<em>testing</em>, <em>done</em>, etc. This board, known as a
<strong>Scrum Board</strong>, provides a visual aid to track the daily
progress of the sprint. Refer to the next figure for an example.</p>
<figure>
<img src="figs/cap2/scrum-board.svg" style="width:60.0%"
alt="Example of a Scrum Board, illustrating the stories of the sprint and their corresponding tasks. Each task can be into one of the following stages/columns: to do, in progress, in testing, or completed." />
<figcaption aria-hidden="true">Example of a Scrum Board, illustrating
the stories of the sprint and their corresponding tasks. Each task can
be into one of the following stages/columns: to do, in progress, in
testing, or completed.</figcaption>
</figure>
<p></p>
<p>Defining the criteria for marking a story or task as <em>done</em> is
crucial in Scrum projects. The team should reach a consensus on these
criteria, and every member should follow it. For instance, the team can
define that a story is only considered completed if it has unit tests
that are all passing. A code review by another team member could also be
required. Ultimately, the code should be successfully merged into the
project repository. This criteria deter team members from prematurely
moving their tasks to the done column using substandard code.</p>
<p> </p>
<p>The <strong>Burndown Chart</strong> is another familiar artifact in
Scrum. It displays the number of work hours for completing the
unfinished tasks at each day of the sprint. In other words, on day
<em>x</em>, it shows that the unfinished sprint tasks amount to
<em>y</em> hours of work. Ideally, the burndown chart exhibits a
continuous decline, hitting zero by the end of the sprint (assuming
success). Next, we show a burndown chart for a sprint that spans 15
days.</p>
<figure>
<img src="figs/cap2/burndown-en.svg" style="width:85.0%"
alt="Burndown Chart for a 15-day sprint." />
<figcaption aria-hidden="true">Burndown Chart for a 15-day
sprint.</figcaption>
</figure>
<h3 data-number="2.4.3" id="additional-scrum-events"><span
class="header-section-number">2.4.3</span> Additional Scrum Events <a
href="#additional-scrum-events" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>We will now explore three further Scrum events: the Daily Stand-up,
Sprint Review, and Retrospective.</p>
<p> </p>
<p>Scrum recommends conducting <strong>Daily Stand-up</strong> meetings,
which typically last approximately 15 minutes and should involve all
team members. As the name suggests, these meetings are usually held with
participants standing, giving rise to alternative names such as
<strong>standup meetings</strong> or <strong>daily scrum</strong>.
During these meetings, each team member should respond to three key
questions: (1) What tasks were completed the previous day? (2) What
tasks are planned for the current day? (3) Are any significant obstacles
hindering their progress? The intention of these meetings is to enhance
communication and information sharing among team members, providing a
platform for keeping each member updated on the project‚Äôs progress. For
example, during the daily stand-up, two developers may discover they are
about to work on the same code section. In this scenario, it would be
beneficial to arrange a separate meeting to discuss their planned
changes, thereby reducing potential conflicts when integrating their
modifications.</p>
<p> </p>
<p>The <strong>Sprint Review</strong> serves to showcase the results of
a sprint. All members of the team should participate, including
additional stakeholders involved with the sprint‚Äôs outcome. At this
meeting, the team demonstrates the finished product to the clients.
Ideally, the Product Owner will approve all sprint stories. However, if
any issues arise with a story, it‚Äôs moved back to the Product Backlog to
be reworked in a future sprint. Similarly, stories the team was not able
to finish in the sprint should also be returned to the Product
Backlog.</p>
<p> </p>
<p>The <strong>Retrospective</strong> is the concluding event of a
sprint. This meeting is held to reflect on the completed sprint and to
identify possible improvements related to the process, team
interrelationships, and employed practices and tools. For instance, as a
result of the retrospective, the team might recommend the need for
punctuality and consistent attendance at daily stand-up meetings,
particularly if lateness has previously been an issue. It‚Äôs also
important to note that the aim of a retrospective is not to trigger
complaints or having heated discussions among team members. Instead,
more critical points should be addressed separately, either in other
meetings or under the supervision of managers. Once the retrospective is
completed, the cycle begins again with the following sprint.</p>
<p> A significant aspect of Scrum events is their fixed duration, also
known as the <strong>time-box</strong> of the event. That‚Äôs why this
term frequently appears in Scrum literature. For instance, consider a
quote from the official Scrum Guide (2017 version): <q>The heart of
Scrum is a sprint, a time-box of one month or less during which a
<em>Done</em>, useable, and potentially releasable product increment is
created</q> (<a
href="https://www.scrum.org/resources/scrum-guide">link</a>). The
objective of defining time-boxes is to maintain a steady workflow,
encourage team commitment to the sprint‚Äôs success, and avoid diversion
from the sprint goal.</p>
<p>Next, we show a table with the time-boxes associated with Scrum
events. When events have a maximum time-box (like sprint planning), the
maximum value applies to a one-month sprint. Thus, in the case of
shorter sprints, the respective time-box should be adjusted
accordingly.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Event</strong></th>
<th style="text-align: left;"><strong>Time-box</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Sprint Planning</td>
<td style="text-align: left;">maximum of 8 hours</td>
</tr>
<tr class="even">
<td style="text-align: left;">Sprint</td>
<td style="text-align: left;">less than 1 month</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Daily Stand-up</td>
<td style="text-align: left;">15 minutes</td>
</tr>
<tr class="even">
<td style="text-align: left;">Sprint Review</td>
<td style="text-align: left;">maximum of 4 hours</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Retrospective</td>
<td style="text-align: left;">maximum of 3 hours</td>
</tr>
</tbody>
</table>
<h3 data-number="2.4.4" id="example-writing-a-book-using-scrum"><span
class="header-section-number">2.4.4</span> Example: Writing a Book using
Scrum <a href="#example-writing-a-book-using-scrum" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>This book was written using various elements from Scrum. For example,
at the book‚Äôs inception, we planned the chapters, thus establishing a
Product Backlog. After that, each chapter was written within a sprint.
During the Sprint Planning meetings, we partitioned each chapter into
sections, thus treating these sections as tasks. Subsequently, the
writing for each chapter began, marking the start of a sprint.
Generally, the sprints were scheduled to last two months. Below we can
see the backlog of the current sprint, whose goal is to write Chapter 2.
We can also see the status of each task/section.</p>
<table style="width:97%;">
<colgroup>
<col style="width: 25%" />
<col style="width: 23%" />
<col style="width: 25%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Story</strong></th>
<th><strong>To Do</strong></th>
<th><strong>In</strong> <strong>Progress</strong></th>
<th><strong>Done</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Chapter 2 - Processes</td>
<td><p>Kanban</p>
<p>When not use</p>
<p>Other Methods</p>
<p>Exercises</p></td>
<td>Scrum</td>
<td><p>Introduction</p>
<p>Agile Manifesto</p>
<p>XP</p></td>
</tr>
</tbody>
</table>
<p>We decided for an agile approach when writing this book to minimize
risks associated with developing a product that doesn‚Äôt meet the needs
of our primary audience‚Äîstudents and professors of Software Engineering
courses, mainly at the undergraduate level. As such, at the end of each
sprint, a chapter was shared and announced publicly, with the aim of
receiving feedback. Thus, our objective was to avoid a Waterfall
approach, which would involve writing the book over years without
receiving any input.</p>
<p>To conclude, it‚Äôs important to examine the criteria we used to
consider a chapter as <em>done</em>. It involves the author of the book
thoroughly reading and reviewing the chapter. Once this in-depth review
was completed, the chapter was tentatively released to the members of
the Applied Software Engineering Research Group at DCC/UFMG (Brazil) for
a second round of review and feedback.</p>
<h3 data-number="2.4.5" id="frequently-asked-questions-1"><span
class="header-section-number">2.4.5</span> Frequently Asked Questions <a
href="#frequently-asked-questions-1" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Before we conclude this section, here are answers to common questions
about Scrum:</p>
<p><strong>What does Scrum mean?</strong> Scrum is not an acronym but a
term borrowed from rugby, where it refers to the <q>meeting</q> on the
field where teams compete for possession of the ball after an accidental
infringement.</p>
<p> <strong>What is a squad?</strong> A squad is another term for an
agile or Scrum team. The term was popularized by Spotify. Similar to
Scrum teams, squads are small, cross-functional, and self-organizing
units. The term tribe is also commonly used to designate a group of
squads.</p>
<p><strong>Can the Product Owner role be assigned to a
committee?</strong> Or in simpler terms, can we have more than one
Product Owner in a Scrum team? The answer is no. This role must be
assigned to a single individual to avoid committee-based
decision-making, which often leads to products overloaded with features,
implemented mainly to satisfy specific committee members. However, the
Product Owner can and should act as a link between the team and other
experts in the product being developed. Indeed, this facilitation is
expected as some requirements might be specific to the domain knowledge
of certain individuals within the organization.</p>
<p> <strong>Is the Scrum Master a full-time role?</strong> Ideally, a
Scrum Master should be committed on a full-time basis. However, for
mature teams who have a vast experience with Scrum, a full-time Scrum
Master might not be needed. In such scenarios, two alternatives can be
considered: (1) Allow the Scrum Master to operate in multiple teams, or
(2) Delegate the Scrum Master role to a team member. If the latter
approach is used, the chosen member should not simultaneously act as the
Product Owner. This is because one of the key responsibilities of a
Scrum Master is to support the PO in writing and prioritizing the user
stories.</p>
<p><strong>Does a Scrum Master need a degree in Computer
Science?</strong> No, a Computer Science degree is not a prerequisite as
a Scrum Master‚Äôs role primarily involves removing obstacles and making
sure the team follows the Scrum principles. Thus, they are not expected
to resolve technical issues like debugging, using frameworks correctly,
implementing features etc. On the other hand, some companies that adopt
Scrum may require Scrum Master certifications.</p>
<p><strong>What other items, besides stories, can be included in the
Product Backlog?</strong> In fact, the Product Backlog is not limited to
user stories‚Äîit can also comprise other work items like bug fixes
(particularly complex ones) and major refactoring efforts, for
example.</p>
<p><strong>Do Scrum organizations have managers?</strong> Yes! While
Scrum teams have autonomy to implement the stories defined by the
Product Owner, additional decisions typically associated with managerial
level are required in a project. Examples include:</p>
<ul>
<li><p>Team composition: Managers are responsible for allocating
developers to teams, as developers usually don‚Äôt have the authority to
select their teams.</p></li>
<li><p>Definition of goals and responsibilities: Managers designate
priorities and goals for each team, which includes the systems they will
be working on. For example, a team doesn‚Äôt decide by itself that a new
accounting system is needed and then start its development. Such
strategic decisions are the responsibility of the organizations‚Äô
managers and executives.</p></li>
<li><p>Human resources management: Managers also handle human resource
tasks, such as recruiting new employees, dismissals, promotions,
transfers, and training initiatives.</p></li>
<li><p>Performance evaluation: Managers are also tasked with assessing
whether the Scrum teams are providing value to the
organization.</p></li>
</ul>
<h2 data-number="2.5" id="kanban"><span
class="header-section-number">2.5</span> Kanban <a href="#kanban"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> The Japanese term <em>kanban</em> translates to <q>visual card</q>.
Since the 1950s, the term is also associated with the just-in-time
production process of Japanese factories, particularly in Toyota where
it was initially implemented. This process is also recognized as the
Toyota Production System (TPS) or, in more contemporary terms, <em>lean
manufacturing</em>.</p>
<p> In the context of software development, Kanban was first introduced
at Microsoft in 2004, by David Anderson (<a
href="https://isbnsearch.org/isbn/0984521402">source</a>). Anderson
describes Kanban as a method that <q>promotes sustainable work pace for
development teams by eliminating waste, delivering consistent value, and
fostering a culture of continuous improvement.</q></p>
<p>To better understand Kanban, we will compare it to Scrum. Primarily,
Kanban is more simple than Scrum because it does not have events like
sprints. Furthermore, strictly speaking, Kanban does not define
particular roles like Product Owner or Scrum Master. Lastly, unlike
Scrum, Kanban doesn‚Äôt include several artifacts, with the exception of
one main artifact: the task board. In Kanban, this is referred to as the
<strong>Kanban Board</strong>, which also includes the product
backlog.</p>
<p>The Kanban Board is organized into specific columns as described
below:</p>
<ul>
<li><p>The first column represents the product backlog, closely
mirroring the same artifact in Scrum. User stories are proposed and
subsequently added to this backlog.</p></li>
<li><p>The next columns represent the steps required to transition a
user story into a functioning feature. These columns typically have
labels such as Specification, Implementation, and Code Review. The
stories in the backlog are processed sequentially, mirroring the
workflow of an assembly line, progressing from left to right.
Furthermore, each column is sectioned into two subcolumns labeled <em>in
progress</em> and <em>ready</em> For instance, the Implementation column
contains two subcolumns: tasks undergoing implementation and tasks that
have been implemented. Completed tasks from one step await to be pulled
into the next step by a team member. This is why Kanban is commonly
referred to as a <em>pull</em> system.</p></li>
</ul>
<p>We will look at the structure of a Kanban Board using an example.</p>
<p><img src="figs/cap2/kanban1-en.png" style="width:90.0%" /></p>
<p>In this board, we can see stories and tasks at various stages. In the
backlog, we have one story labeled H3. Another story, labeled as H2, has
been picked up by a team member and is under Specification. Four tasks
from a previous story, labeled as T6 to T9, have already been specified.
Next, there are two tasks, T4 and T5, which are being implemented. Task
T3 has been implemented and is now awaiting Code Review. Lastly, Task T2
is currently under review, while T1 has been fully implemented and is
now considered done. You may also have noticed the acronym WIP appearing
at all stages, with the exception of the backlog. Don‚Äôt worry about this
for now; we will explain it shortly. It‚Äôs also important to note that,
in this example, we used the letters H and T to represent stories and
tasks, respectively. However, in real board setups, tasks and stories
are represented as cards that possibly carry a brief description of
each.</p>
<p>Days later, the Kanban Board evolved into the following state (tasks
that moved forward are distinguished by being underlined and colored
red).</p>
<p><img src="figs/cap2/kanban2-en.png" style="width:90.0%" /></p>
<p>It should be noted that H2 is no longer visible as it was decomposed
into three tasks (T10, T11, and T12). This decomposition is exactly what
occurs during the specification phase, whose objective is to convert a
story into an actionable task list. Furthermore, T6 and T7‚Äîwhich were
previously on hold‚Äîare now under Implementation. Simultaneously, T3 has
transitioned into the Code Review phase. Finally, the review of T2 has
been completed. It‚Äôs also important to note that currently there are no
tasks waiting for entering in the review stage.</p>
<p>Similar to other agile methodologies, Kanban teams are
self-organizing. This implies they have the autonomy to decide which
task they will work on. Also, they are cross-functional‚Äîmeaning the team
is composed of members who have the skillset to perform all the tasks in
the Kanban Board.</p>
<p> </p>
<p>We will now discuss the concept of <strong>WIP Limits</strong> (short
for <em>Work in Progress</em>). Project management methods typically
strive to maintain a sustainable work flow. To achieve this, two
scenarios need to be avoided:</p>
<ol type="1">
<li>Teams having no tasks to work on and consequently staying idle most
of the time.</li>
<li>Teams being overwhelmed with an excess of tasks, thus negatively
affecting the quality of the software produced.</li>
</ol>
<p>In order to circumvent the second scenario, Kanban proposes setting
maximum task limits for each step on a board. This cap is referred to as
the WIP Limit, which represents the maximum number of tasks‚Äîor
cards‚Äîthat can be present in each step, including the tasks in progress
(first sub-column) and those that are ready (second sub-column). The
exception is the final step, where the WIP limit applies only to the
first sub-column as it is meaningless to limit the number of
complemented tasks.</p>
<p>Next, we show a Kanban Board that incorporates these WIP limits. We
can see the limits below each step‚Äôs name. Our board allows a maximum of
2 stories in Specification, 5 tasks in Implementation, and 3 tasks in
Code Review. The reason for the particular WIP limit in<br />
Specification will be elaborated later. For now, note that 4 tasks are
under Implementation, thus remaining below the step‚Äôs WIP limit of 5.
Similarly, in Code Review the limit also is followed as only one task is
under review. Remember that to comply with the WIP limit, tasks from
both sub-columns‚Äî in progress and ready tasks‚Äîare taken into account,
except for the final step where only tasks from the first sub-column
count (T3, in this case).</p>
<p><img src="figs/cap2/kanban3-en.png" style="width:90.0%" /></p>
<p>We will now explain the concept of Work in Progress for the
Specification step. To compute the WIP for this step, we need to sum up
the stories in Specification (which was zero in our previous example)
with the stories that have already been specified. For instance, in the
example, we‚Äôve specified two stories, i.e., tasks T8 and T9 are products
of the same story‚Äôs specification, while tasks T10, T11, and T12
resulted from the specification of another story. Therefore, in this
step for the means of WIP computation, we have two stories, which is
under the limit of 2. To ease visualization, we display the tasks
emerging from the same story specification on a single line. Hence, to
compute the WIP of the Specification step, we should add up the stories
in the first sub-column (zero in our case) to the number of lines in the
second sub-column (two in this case).</p>
<p>Also about the previous board we have:</p>
<ul>
<li><p>Story H3, in the Backlog, can‚Äôt be moved into the Specification
because this step‚Äôs WIP has reached its maximum limit.</p></li>
<li><p>One of the tasks in the ready subcolumn of Specifications (T8 to
T12) can be moved to Implementation as the WIP for this step is
currently 4, but having a limit of 5.</p></li>
<li><p>One or more tasks in Implementation(T4 to T7) can be moved to
ready, which doesn‚Äôt affect that step‚Äôs WIP.</p></li>
<li><p>Reviewing of T3 can be finalized.</p></li>
</ul>
<p>An important point to note here is that WIP limits are in place to
avoid overloading the team with tasks. When a team is burdened with
numerous tasks‚Äîthat bypass the WIP limits‚Äîthe probability of producing
low quality software increases. Kanban understands this drawback and
implements an automatic <q>lock</q> to prevent teams from accepting
tasks beyond their delivery capacity. These locks, which are the WIP
limits, have internal as well as external usage. For example, they serve
as an instrument for the team to decline extra tasks that are being
forcefully assigned from the top management.</p>
<h3 data-number="2.5.1" id="determining-wip-limits"><span
class="header-section-number">2.5.1</span> Determining WIP Limits <a
href="#determining-wip-limits" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> In this section, we will explain the steps involved in defining Work
in Progress (WIP) limits. While several methods exist, we will adapt an
algorithm proposed by Eric Brechner, a Microsoft engineer. This
algorithm is detailed in his book on using Kanban in software
development (<a
href="https://dl.acm.org/citation.cfm?id=2774938">link</a>). Next, we
outline the algorithm‚Äôs steps.</p>
<p>Initially, we need to estimate the average time it takes to complete
a task in each step of the Kanban board, known as the <strong>lead time
(LT)</strong> of the step. For our example, we assume these values:</p>
<ul>
<li>LT(specification) = 5 days</li>
<li>LT(implementation) = 12 days</li>
<li>LT(review) = 6 days</li>
</ul>
<p>These estimated times reflect an average task‚Äôs duration, taking into
account that there will be more complex and simpler tasks. Note that the
<em>lead time</em> includes the queue time, i.e., the task‚Äôs waiting
time in the <q>ready</q> subcolumns of the Kanban board before
progressing to the next step.</p>
<p>After that, we should estimate the <strong>throughput (TP)</strong>
of the step with the longest lead time. In our example (which also holds
for most software development projects), this step is Implementation. If
the team can implement eight tasks per month, this step‚Äôs
<strong>throughput</strong> is: 8 / 21 = 0.38 tasks/day (we‚Äôve assumed a
month has 21 workdays).</p>
<p>Finally, each step‚Äôs WIP is calculated as:</p>
<p><strong>WIP(step) = TP * LT(step)</strong></p>
<p>Here, TP refers to the throughput of the slowest step, as calculated
in the previous step. So, using this formula, we derive:</p>
<ul>
<li>WIP(specification) = 0.38 * 5 = 1.9</li>
<li>WIP(implementation) = 0.38 * 12 = 4.57</li>
<li>WIP(review) = 0.38 * 6 = 2.29</li>
</ul>
<p>And after rounding, we get:</p>
<ul>
<li>WIP(specification) = 2</li>
<li>WIP(implementation) = 5</li>
<li>WIP(review) = 3</li>
</ul>
<p>Eric Brechner also suggests to add a 50% margin of error to the
calculated WIPs to allow for variations in task size and tasks blocked
due to external factors. However, we won‚Äôt apply this adjustment in our
example, as it is purely illustrative.</p>
<p>Finally, it‚Äôs important to note that the purpose of WIP limits, as
proposed by Kanban, is to maintain a sustainable work pace and therefore
to deliver quality software. These limits prevent developers from
becoming overburdened with tasks, which would reduce their work quality.
Virtually all development methods offer such instruments. For instance,
Scrum uses sprints with a fixed time-box to avoid overcommitting and to
limit the workload based on the team‚Äôs velocity. Once started, the
sprint‚Äôs goals can‚Äôt be changed to shield the team from priority shifts.
For Waterfall methods, the strategies to ensure a sustainable workflow
with quality outcomes involve a comprehensive phase of requirement
specifications. This phase aims to provide developers with a clear
understanding of the system they will implement.</p>
<h3 data-number="2.5.2" id="littles-law"><span
class="header-section-number">2.5.2</span> Little‚Äôs Law <a
href="#littles-law" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>The procedure we used for calculating WIP limits is an application of
<strong>Little‚Äôs Law</strong>, a prominent result from Queue Theory (<a
href="https://isbnsearch.org/isbn/0471503363">link</a>). Little‚Äôs Law
states that the number of items in a queue system is the product of the
arrival rate of these items and the time each item spends within the
system.</p>
<p>When applied to our context, where the items we referred to are
tasks, the law can be broken down as follows:</p>
<ul>
<li><p>WIP: number of tasks in a particular step of the Kanban
board.</p></li>
<li><p>Throughput (TP): rate at which tasks arrive at this
step.</p></li>
<li><p>Lead Time (LT): time each task spends at this step.</p></li>
</ul>
<p>Thus, according to Little‚Äôs Law, <strong>WIP = TP * LT</strong>.
Below, we also visually represent Little‚Äôs Law for a clearer
understanding.</p>
<figure>
<img src="figs/cap2/lei-little-en.svg" style="width:60.0%"
alt="Little‚Äôs Law: WIP = TP * LT" />
<figcaption aria-hidden="true">Little‚Äôs Law: WIP = TP * LT</figcaption>
</figure>
<h3 data-number="2.5.3" id="frequently-asked-questions-2"><span
class="header-section-number">2.5.3</span> Frequently Asked Questions <a
href="#frequently-asked-questions-2" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Before we conclude, let‚Äôs answer some common questions related to
Kanban:</p>
<p><strong>What roles exist in Kanban?</strong> In contrast to Scrum,
Kanban doesn‚Äôt prescribe a rigid set of roles. The responsibility rests
on the team and the organization to determine the necessary roles, such
as a Product Owner, testers, and so on.</p>
<p><strong>How are user stories prioritized?</strong> Kanban‚Äôs approach
is lightweight compared to Scrum and even XP. One reason is the absence
of explicitly defined criteria for prioritizing user stories. As
mentioned in the previous answer, the existence of a Product
Owner‚Äîresponsible for prioritization‚Äîisn‚Äôt mandatory. Thus, alternative
solutions like external prioritization by a manager can also be
used.</p>
<p><strong>Can Kanban teams conduct typical Scrum events, like daily
meetings, reviews, and retrospectives?</strong> Yes, they can. While
Kanban does not prescribe these events, it doesn‚Äôt explicitly prevent
them either. The decision regarding which events are essential, their
timing, duration, etc., is left to the team.</p>
<h2 data-number="2.6" id="when-not-to-use-agile-methods"><span
class="header-section-number">2.6</span> When Not to Use Agile Methods?
<a href="#when-not-to-use-agile-methods" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> Although agile methods are very popular nowadays, it‚Äôs important to
remember that there‚Äôs no one-size-fits-all solution in Software
Engineering. As such, this section examines scenarios and domains where
agile practices may not be the most suitable choice.</p>
<p>However, the question posed in this section doesn‚Äôt allow for simple
answers such as <q>systems from areas X, Y, and Z should avoid agile
methods, while the rest should use them</q>. In reality, systems from
all areas could benefit from at least some agile practices. On the other
hand, some practices might not be advisable for specific types of
systems, organizations, and environments. Therefore, we will answer the
proposed question at a finer granularity. That is, we will comment on
when <strong>not</strong> to use certain agile practices.</p>
<ul>
<li><p>Incremental Design. This approach is effective when the team has
an initial understanding of the system‚Äôs design. However, if such vision
is absent, or the domain of the system is new and complex, or if future
changes have high costs, it may be better to conduct an initial design
phase prior to starting the implementation of features.</p></li>
<li><p>User Stories. As a light-weight method for specifying
requirements, stories are typically clarified with daily customer
participation in the sprints. However, certain projects may require a
detailed requirements specification at the beginning, particularly if
they originate from unfamiliar domains for the developers.</p></li>
<li><p>Customer Involvement. If the requirements are stable and
thoroughly understood by the developers, constant involvement of a
Customer Representative or Product Owner may be unnecessary. For
instance, in the development of a compiler for a language with
well-established grammar and semantics, this role is not
relevant.</p></li>
<li><p>Lightweight Documentation. For specific domains, detailed
requirements and comprehensive documentation are crucial. For example,
systems where failures can result in human fatalities‚Äîsuch as in the
medical and transportation sectors‚Äîoften require certification from an
external entity. This entity may require extensive documentation in
addition to the source code.</p></li>
<li><p>Self-organizing Teams. Agile teams have autonomy to work without
interference during a sprint. For example, they do not need to report
daily to the organization‚Äôs managers and executives. Nonetheless, this
procedure can conflict with the values and culture of some
organizations, particularly those with a hierarchical structure and
rigid control.</p></li>
<li><p>Open Scope Contracts. With open scope contracts, remuneration is
defined by the hour. Therefore, mainly in the first weeks of months, the
contracting company does not have a clear understanding of the features
to be implemented or the time and cost of the project. Certain
organizations might be reluctant to sign such types of contracts,
particularly if they lack prior experience with agile development or do
not trust the contracted company.</p></li>
</ul>
<p>To conclude, it‚Äôs important to mention that two agile practices have
become prevalent in a majority of software projects:</p>
<ul>
<li><p>Small teams, because communication and coordination challenges
increase significantly for large teams.</p></li>
<li><p>Iterations (or sprints), even they are longer than typical agile
sprints. For instance, iterations lasting two or three months, as
opposed to the usual sprint length of less than 30 days. Interestingly,
even before the rise of agile methods, some iterative methods were
suggested, i.e., methods with validation points throughout the
development. We will explore two of these methods in the next
section.</p></li>
</ul>
<h2 data-number="2.7" id="other-iterative-methods"><span
class="header-section-number">2.7</span> Other Iterative Methods <a
href="#other-iterative-methods" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>The shift from the Waterfall model‚Äîhighly prevalent during the 70s
and 80s‚Äîto Agile approaches, which only gained traction in the final
years of the 2000s, was a gradual process. For example, some methods
proposed during this transition also incorporated the concept of
iterations, although having a longer duration than those typically seen
nowadays in Agile. Rather than lasting a few weeks, these iteration
could extend over months. Furthermore, these transition methods retained
many elements from Waterfall, like the focus on documentation and an
initial requirements specification phase followed by a design phase.</p>
<p> One such method formulated during this transition period is the
<strong>Spiral Model</strong>, proposed by Barry Boehm, in 1986 (<a
href="https://doi.org/10.1145/12944.12948">link</a>). In the Spiral
Model, a system is developed through a spiral of iterations. Each
iteration, which includes a <q>complete round</q> of the spiral,
comprises four stages, as elaborated next (see also the following
figure):</p>
<ol type="1">
<li>Defining objectives and constraints, including costs, schedules, and
so on.</li>
<li>Evaluating alternatives and conducting risk analysis. For instance,
considering whether it is more cost-effective to purchase a system
instead of developing it in-house.</li>
<li>Development and testing, potentially utilizing the Waterfall model.
By the end of this stage, a prototype should be produced for
demonstration to users.</li>
<li>Planning for the next iteration or deciding to conclude the project
if the current implementation already attends the organization‚Äôs
needs.</li>
</ol>
<figure>
<img src="figs/cap2/spiral-en.png" style="width:75.0%"
alt="Spiral Model. Each iteration is divided into four stages." />
<figcaption aria-hidden="true">Spiral Model. Each iteration is divided
into four stages.</figcaption>
</figure>
<p>The Spiral Model generates a more comprehensive version of a system
after each iteration. Despite this, each iteration, encapsulating all
four phases, can take anywhere from 6 to 24 months‚Äîwhich is
significantly longer than in XP and Scrum. Another interesting feature
of this model is the risk analysis phase, where concrete steps to
mitigate project risks are considered.</p>
<p> The <strong>Unified Process (UP)</strong>, proposed in the late 90s,
is another example of an iterative method. Proposed by professionals
affiliated with Rational, a software consulting and development company,
which IBM later acquired in 2003, UP has also a specific version known
as the <strong>Rational Unified Process (RUP)</strong>.</p>
<p>Due to its origins, RUP is intrinsically associated with two
technologies:</p>
<ul>
<li><p>Unified Modeling Language (UML), as many of the RUP outcomes are
documented and represented using UML diagrams. We will delve into UML in
detail in Chapter 4. However, it‚Äôs worth noting that both UML and RUP
were proposed by the same group of professionals who intended to define
a unified process and modeling language.</p></li>
<li><p>CASE (Computer-Aided Software Engineering) tools, which are
analogous to CAD (Computer-Aided Design) tools used in other fields such
as Civil Engineering, Mechanical Engineering, and Architecture. RUP
proposes that the design of a software should heavily rely on UML
diagrams. However, these diagrams aren‚Äôt drawn on paper, but using CASE
tools, as illustrated in the following figure. Thus, besides proposing
the method, Rational was also responsible for its supporting CASE
tools.</p></li>
</ul>
<figure>
<img src="figs/cap2/case.png" style="width:70.0%"
alt="Project using a CASE tool. Reproduction kindly authorized by the developers of ArgoUML." />
<figcaption aria-hidden="true">Project using a CASE tool. Reproduction
kindly authorized by the developers of ArgoUML.</figcaption>
</figure>
<p>When using RUP, development is divided into the following phases:</p>
<ul>
<li><p>Inception: this phase encompasses tasks such as feasibility
analysis, budget definition, risk assessment, and system scope
determination. At the end of this phase, the business case for the
system should be well established. We can also conclude that it is more
cost-effective to purchase a system in the market than to build
one.</p></li>
<li><p>Elaboration: this phase involves tasks such as requirements
specification (which may be achieved using UML use case diagrams),
system architecture definition, and the proposal of a development plan.
Upon completion of this phase, the risks identified during the inception
phase should be effectively managed and mitigated.</p></li>
<li><p>Construction: this phase deals with lower-level design,
implementation, and testing. Upon its completion, a working system,
including documentation and manuals, should be available.</p></li>
<li><p>Transition: in this phase, the system is moved to production.
Thus, it includes defining all necessary deployment procedures, such as
data backup policies, data migration from legacy systems, and training
the operations team.</p></li>
</ul>
<p>Similar to the Spiral Model, the phases described above are performed
repeatedly, making the development incremental with each cycle resulting
in the delivery of new features. Furthermore, each phase can be
iterated. For instance, the construction phase can be divided into two
iterations, each giving shape to a part of the project. The following
figure illustrates this iterative characteristic of RUP:</p>
<figure>
<img src="figs/cap2/rup1-en.svg" style="width:70.0%"
alt="RUP phases and iterations. Iterations can occur at any phase (as indicated by the self-loops). Product increments are created by going through the whole cycle again (as indicated by the outer loop)." />
<figcaption aria-hidden="true">RUP phases and iterations. Iterations can
occur at any phase (as indicated by the self-loops). Product increments
are created by going through the whole cycle again (as indicated by the
outer loop).</figcaption>
</figure>
<p>RUP also defines various engineering disciplines, including business
modeling, requirement definition, design analysis, implementation,
testing, and deployment. These disciplines, also referred to as process
workflows, can take place in any phase. However, certain disciplines are
more important during specific phases, as illustrated in the next
figure. In this example, business modeling tasks are primarily performed
during the initial phases (inception and elaboration). Conversely, most
of the implementation happens during the construction phase.</p>
<figure>
<img src="figs/cap2/rup2.png" style="width:65.0%"
alt="Phases (depicted horizontally) and disciplines (depicted vertically) in a project developed using RUP. The area under the curve represents the intensity of the discipline during each phase (image from Wikipedia, license: public domain)." />
<figcaption aria-hidden="true">Phases (depicted horizontally) and
disciplines (depicted vertically) in a project developed using RUP. The
area under the curve represents the intensity of the discipline during
each phase (image from Wikipedia, license: public domain).</figcaption>
</figure>
<h2 class="unnumbered" id="bibliography">Bibliography <a
href="#bibliography" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Kent Beck, Cynthia Andres. Extreme Programming Explained: Embrace
Change. Addison-Wesley, 2nd edition, 2004.</p>
<p>Kent Beck. Embracing Change with Extreme Programming. IEEE Computer,
vol.¬†32, issue 10, p.¬†70-77, 1999.</p>
<p>Kent Beck, Martin Fowler. Planning Extreme Programming.
Addison-Wesley, 2000.</p>
<p>Ken Schwaber, Jeff Sutherland. The Scrum Guide, 2017.</p>
<p>Kenneth Rubin. Essential Scrum: A Practical Guide to the Most Popular
Agile Process. Addison-Wesley, 2012</p>
<p>Eric Brechner. Agile Project Management with Kanban. Microsoft Press,
2015.</p>
<p>David Anderson. Kanban. Blue Hole Press, 2013.</p>
<p>Ian Sommerville. Software Engineering. Pearson, 10th edition,
2019.</p>
<p>Hans van Vliet. Software Engineering: Principles and Practice. 3rd
edition. Wiley, 2008.</p>
<p>Armando Fox, David Patterson. Engineering Software as a Service: An
Agile Approach Using Cloud Computing. 1st edition, 2014.</p>
<h2 class="unnumbered" id="exercises">Exercises <a href="#exercises"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<ol type="1">
<li><p>How does XP recommend software development contracts be
structured?</p></li>
<li><p>Describe the key differences between XP and Scrum.</p></li>
<li><p>Scrum teams are known to be cross-functional and self-organizing.
Define these terms.</p></li>
<li><p>In Scrum, what is the difference between the <q>top</q> and
<q>bottom</q> stories in the Product Backlog?</p></li>
<li><p>What are story points and what are they used for?</p></li>
<li><p>In Scrum, what is the difference between a sprint review and a
retrospective?</p></li>
<li><p>Can a sprint be canceled? If so, by whom and for what reasons?
For some insights to answer this question, checkout the Scrum Guide (<a
href="https://www.scrum.org/resources/scrum-guide">link</a>).</p></li>
<li><p>Consider a system within your area of expertise. (a) Propose a
user story for this system (b) Subsequently, break this story you
created into tasks, akin to what we did with the Questions &amp; Answer
forum in the section about XP. (c) Do these tasks have dependencies or
can they be completed in any sequence?</p></li>
<li><p>Suppose two teams, A and B, working in different projects,
employed by separate companies with no interconnections. Both teams
follow 15-day sprint cycles and both have five developers. In their
respective projects, team A estimates their velocity as 24 points, while
team B assumes theirs at 16 points. Can we conclude that team A is 50%
more efficient than team B? Please justify your answer.</p></li>
</ol>
<p>10. Describe the primary differences between Scrum and Kanban.</p>
<p>11. What are the differences between a Scrum Board and a Kanban
Board?</p>
<p>12. What error exists in the following Kanban board?</p>
<p><img src="figs/cap2/kanban4-en.png" style="width:80.0%" /></p>
<p>13. Consider the following Kanban board. At this moment, the team
cannot work on the specification of new stories, as the WIP of this step
is filled by items waiting to move to the next step (Implementation).
What is more recommended at this moment: Bypass the WIP limit and pull a
new story from the Backlog to Specification? Or handle the tasks in
Validation, in order to unlock the process flow?</p>
<p><img src="figs/cap2/kanban5-en.png" style="width:80.0%" /></p>
<ol start="14" type="1">
<li><p>Why is it usually suggested to increase the WIP (Work In
Progress) limits calculated using Little‚Äôs Law, for example, by 50%?
What circumstances can lead to errors when computing the WIP
limits?</p></li>
<li><p>Describe the instruments provided by the Waterfall, Scrum, and
Kanban for managing risk and promoting a workflow that encourages the
development of high-quality software.</p></li>
<li><p>Consider a Kanban board with four stages. The table below
provides the <em>lead time</em> for each stage and the throughput for
stage C, which is the slowest one. Using these values, calculate the WIP
for each stage (displayed in the last column).</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>Step</strong></th>
<th style="text-align: right;"><strong>Lead Time</strong> (average,
days)</th>
<th style="text-align: center;"><strong>Throughput</strong>
(tasks/day)</th>
<th style="text-align: center;"><strong>WIP</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: right;">4</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: right;">3</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: right;">10</td>
<td style="text-align: center;">0.5</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: right;">5</td>
<td style="text-align: center;">-</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<ol start="17" type="1">
<li>Consider the following chart, which illustrates how the costs of
changes vary according to the development phase in which they occur for
a particular system. (a) Which development methodology would you
recommend for this system, and why? Give examples of systems that might
have a similar change cost curve.</li>
</ol>
<p><img src="figs/cap2/cost-of-changes.png" style="width:55.0%" /></p>
<ol start="18" type="1">
<li>The article <em>Development and Deployment at Facebook</em> (<a
href="https://doi.org/10.1109/MIC.2013.25">link</a>) presents the
software development practices employed at Facebook. In the first
section (pages 2-3; figure 2), the authors distinguish between several
development methods based on their release frequency. Fill the following
table with the release frequency for some methods and policies discussed
in the article.</li>
</ol>
<table>
<thead>
<tr class="header">
<th><strong>Method</strong></th>
<th style="text-align: left;"><strong>Frequency of new
releases</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Waterfall</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td>Evolutionary</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td>Agile</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td>Facebook</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td>Continuous Deployment</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<ol start="19" type="1">
<li>Why are the Unified Process (UP) and Spiral not categorized as agile
methods? How do they differ from the Waterfall Model?</li>
</ol>
</div>
</div>
</div>

<footer>
All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>.
</footer>
</body>
</html>
