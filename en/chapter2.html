<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Chapter 2: Processes ‚Äì Software Engineering: A Modern Approach</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <meta name="robots" content="noindex">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p> <h4>Disclaimer: This chapter is a beta version subjected to proofreading. </h4> </p>
<header id="title-block-header">
<h1 class="title">Software Engineering: A Modern Approach</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="2" id="process"><span
class="header-section-number">2</span> Process <a href="#process"
class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p>In software development, perfect is a verb, not an adjective. There
is no perfect process. There is no perfect design. There are no perfect
stories. You can, however, perfect your process, your design, and your
stories. ‚Äì Kent Beck</p>
</blockquote>
<p> This chapter starts with a discussion on the importance of software
process (Section 2.1). Next, we discuss general and foundational aspects
of agile software development processes (Section 2.2), including a
discussion into the historical context that motivated the emergence of
these processes. The next sections focus on three agile methods: Extreme
Programming (Section 2.3), Scrum (Section 2.4), and Kanban (Section
2.5). Following that, we comment on scenarios where agile methods might
not be the most recommended processes (Section 2.6). Lastly, in Section
2.7, we briefly present some traditional processes, such as the Unified
Process.</p>
<h2 data-number="2.1" id="importance-of-process"><span
class="header-section-number">2.1</span> Importance of Process <a
href="#importance-of-process" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>Consider the production of a car in an automobile factory, which
follows a well-defined process. In simple terms, sheets of steel are
initially cut and pressed to shape doors, roofs, and hoods. Next, the
car is painted and components like the dashboard, seats, seat belts, and
wiring are installed. Finally, the mechanical parts, including the
engine, suspension, and brakes, are fitted.</p>
<p>Analogously, software production also follows a
<strong>process</strong>, although less mechanized and more dependent on
intellectual endeavor. A software development process defines a series
of steps, tasks, events, and practices that developers must observe
while developing a software system.</p>
<p> There are some who critique software processes and question their
need, often asking: <q>Why must I follow a process?</q> or <q>What
process did Linus Torvalds or Donald Knuth used when implementing the
Linux operating system or the TeX text formatter?</q></p>
<p>In reality, the second questions above do not apply to our context as
both Linux (in its initial versions) and TeX were individual projects
led by a single developer. In such scenarios, following a process is
less important. Stated in better terms, the process followed in those
projects was a personal one, reflecting the principles, practices, and
experience of a single developer.</p>
<p>However, contemporary software systems are too complex to be
developed by a single developer. Thus, systems implemented by solitary
heroes are increasingly rare nowadays. In practice, modern systems ‚Äî the
focus of this book ‚Äî are developed by <strong>teams</strong>.</p>
<p>However, these teams require a minimal set of rules to produce
quality software efficiently. That‚Äôs why software companies invest so
much in software processes. They serve as instruments for companies to
coordinate, motivate, organize, and evaluate their developers, ensuring
at the same time productivity and alignment with the organization‚Äôs
goals. Without a process ‚Äî even a light and simplified one, such as the
agile methods we will study in this chapter ‚Äî there is a risk that teams
will work in a uncoordinated way, creating products with no business
value. Finally, processes not only benefit the company, but they also
serve developers by clarifying expected tasks and outcomes, thus
reducing misalignment among team members.</p>
<p>In this chapter, we explore various software processes. In fact, in
Chapter 1, we already presented a first introduction to Waterfall and
Agile methods. In the following sections, we will continue this
discussion and present three well-known Agile methods.</p>
<h2 data-number="2.2" id="agile-manifesto"><span
class="header-section-number">2.2</span> Agile Manifesto <a
href="#agile-manifesto" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> The earliest software development process ‚Äî as the Waterfall
process, proposed in the 1970s ‚Äî followed a sequential approach.
Usually, projects began with a requirement specification phase and ended
with the implementation, testing, deployment, and maintenance
phases.</p>
<p>Given the historical context, this strictly sequential approach was
understandable. Traditional engineering projects are<br />
developed sequentially and are based on detailed and upfront planning.
Therefore, it‚Äôs not a surprise that the emerging Software Engineering
field mirrored the processes of longer-established domains like
Electronics, Civil, Mechanical, and Aeronautical Engineering, among
others.</p>
<p>However, by the 80s, the industry began to recognize that software is
different from other engineering products. The recurrent problems faced
by software projects at his time reinforced this conclusion. For
instance, such projects routinely overshot schedules and budgets. Some
were even abandoned after years of effort without delivering a
functioning system to customers.</p>
<p> The CHAOS Report published in 1994 by the Standish Group consulting
firm provided more details about the state of software projects at the
time. This report (<a
href="https://www.standishgroup.com/sample_research_files/chaos_report_1994.pdf">link</a>),
revealed that over 55% of projects surpassed their<br />
deadlines by 51% to 200%; and at least 12% exceeded the deadlines by
more than 200%, as shown in the next figure.</p>
<figure>
<img src="figs/cap2/chaos2-en.svg" style="width:90.0%"
alt="CHAOS Report (1994): percentage of projects exceeding their deadlines (for each range of overrun)." />
<figcaption aria-hidden="true">CHAOS Report (1994): percentage of
projects exceeding their deadlines (for each range of
overrun).</figcaption>
</figure>
<p>In terms of costs, almost 40% of the studied projects overshot their
budgets by 51% to 200%, as indicated in the following figure:</p>
<figure>
<img src="figs/cap2/chaos1-en.svg" style="width:90.0%"
alt="CHAOS Report (1994): percentage of projects exceeding their budgets (for each range of overrun)." />
<figcaption aria-hidden="true">CHAOS Report (1994): percentage of
projects exceeding their budgets (for each range of
overrun).</figcaption>
</figure>
<p>Therefore, in 2001, some industry professionals gathered in Snowbird,
Utah, to discuss and propose an alternative to the prevailing
Waterfall-based processes. They argued that, being different from
traditional engineering products, software requires a distinct
development process.</p>
<p>For instance, software requirements change more frequently than those
of a computer, airplane, or bridge. Moreover, customers often lack a
clear understanding of their needs. Thus, there is always a risk of
designing a product that will be obsolete by the time it‚Äôs finished due
to changing circumstances or customer needs. The professionals that met
at Utah also identified issues with the document-centric approach
advocated by Waterfall. At the time, requirements documents were
detailed, heavy, and dense, which contributes to making them obsolete
very quickly as developers would not update the documentation to reflect
requirement changes.</p>
<p>In response, the group proposed a new type of software process, which
was described in a document they named the <strong>Agile
Manifesto</strong>. The manifesto reads:</p>
<blockquote>
<p>Through this work, we have come to value:</p>
<p><strong>Individuals and interactions</strong> over processes and
tools</p>
<p><strong>Working software</strong> over comprehensive
documentation</p>
<p><strong>Customer collaboration</strong> over contract negotiation</p>
<p><strong>Responding to change</strong> over following a plan.</p>
</blockquote>
<p> Agile processes are characterized by short and iterative development
cycles. Systems are built incrementally, starting with the most relevant
features, according to customers. Initially, a first version of the
system is created, which implements only high-priority functionalities.
This version is then validated by the customer. If approved, a new cycle
‚Äî also callled <strong>iteration</strong> or <strong>sprint</strong> ‚Äî
begins, adding a few more features as prioritized by the customer.
Typically, these cycles are short, having two weeks, for example. This
allows the systems to be incrementally built, with each feature
increment receiving explicit approval by the customer. The development
ends when all the customer‚Äôs requests have been implemented.</p>
<p> The following figures present a comparison between Waterfall and
Agile methods:</p>
<figure>
<img src="figs/cap2/waterfall2-en.svg" style="width:90.0%"
alt="Development using a Waterfall process. The software is finished only at the end." />
<figcaption aria-hidden="true">Development using a Waterfall process.
The software is finished only at the end.</figcaption>
</figure>
<figure>
<img src="figs/cap2/agile-en.svg" style="width:90.0%"
alt="Development using an Agile process. Each iteration (represented by the rectangles) produces a product increment (S++), which is validated and tested by customers." />
<figcaption aria-hidden="true">Development using an Agile process. Each
iteration (represented by the rectangles) produces a product increment
(S++), which is validated and tested by customers.</figcaption>
</figure>
<p>However, the previous figures may suggest that in agile development,
each iteration replicates a mini-Waterfall process, encompassing all the
Waterfall phases. This isn‚Äôt accurate; generally, iterations in agile
methods aren‚Äôt a series of tasks like in Waterfall (more details in the
following sections). The figure may also suggest that a system must be
put into production at the end of each iteration. This is also
incorrect. Indeed, the objective is to deliver a functional system that
performs useful tasks. However, the decision to launch the software
involves other variables such as business risks, hardware resources
availability, marketing campaigns, user training, etc.</p>
<p>Other agile process characteristics include:</p>
<ul>
<li><p>Minimal emphasis on documentation: Only vital information should
be documented.</p></li>
<li><p>Less emphasis on detailed plans: At the start of a project, often
neither the customer nor the developers have a clear understanding of
all requirements that should be implemented. Such understanding
gradually unfolds as sprints are finished and validated. In other words,
the essence of agile development is to advance even when we have
incomplete, partial, and changing requirements.</p></li>
<li><p>No dedicated design phase (<em>Big Design Up Front</em>): The
design of the software system is also incremental, evolving on each
iteration.</p></li>
<li><p>Small team development: Teams typically comprise about a dozen
developers or, as Amazon CEO Jeff Bezos phrased it, <q>teams that can be
fed with two pizzas</q>. We also like to say that the size of agile
teams varies between the size of a basketball team (5 members) to the
one of a soccer team (11 members).</p></li>
<li><p>Emphasis on novel programming practices (as in the early 2000s),
such as pair programming, automated testing, refactoring, and continuous
integration.</p></li>
</ul>
<p>As result, agile processes are considered <strong>light
processes</strong>, having few prescriptions and documents.</p>
<p>However, the characteristics we presented above are still generic and
broad. Thus, to make agile principles more concrete and actionable,
several methods were proposed. Interestingly, they were all initially
proposed before the 2001 Agile Manifesto‚Äôs meeting. Particularly, in
this chapter, we will study three agile methods:</p>
<ul>
<li><p>Extreme Programming (XP): Kent Beck proposed this method in a
1999 book (<a
href="https://dl.acm.org/citation.cfm?id=318762">link</a>). A second and
heavily revised edition was also released in 2004.</p></li>
<li><p>Scrum: This agile method was introduced by Jeffrey Sutherland and
Ken Schwaber in a 1995 article (<a
href="https://dl.acm.org/citation.cfm?id=260274">link</a>).</p></li>
<li><p>Kanban: This method originated from a production control system
implemented in Toyota‚Äôs factories in the 1950s (<a
href="https://hbr.org/1986/01/the-new-new-product-development-game">link</a>).
Over the past years, Kanban has been gradually adapted for software
development.</p></li>
</ul>
<p>It‚Äôs also important to understand that all development methods are
essentially a set of recommendations. Every organization should analyze
each one and decide if it‚Äôs suitable for their particular context.
Consequently, organizations might need to adapt any existing method to
their needs. For this reason, it‚Äôs rare to see two organizations that
follow exactly the same development process. For instance, even if they
say they‚Äôre using Scrum.</p>
<p><strong>In-Depth</strong>: The terms process and methods are often
used interchangeably. However, there are also subtle differences between
them. In our context, a process is a set of steps, events, and tasks
used to construct software. Every organization employs a process to
develop its systems, which can be agile, Waterfall, or even a
<q>chaotic</q> one. However, a process always exists. On the other hand,
a method specifies a particular development process (the term originates
from Greek, meaning <q>the means to achieve a goal</q>). Therefore, XP,
Scrum, and Kanban are agile methods or, put another way, they define
practices, activities, events, and techniques compatible with agile
principles.</p>
<p></p>
<p><strong>Real World Insight</strong>: The widespread success and
impact of agile methods are noteworthy. At present, an overwhelming
majority of organizations, irrespective of their size or business
domain, follow agile principles to varying degrees. Here‚Äôs an
interesting statistic: in 2018, the Stack Overflow survey included a
question about the most used development methods (<a
href="https://insights.stackoverflow.com/survey/2018/#career-values">link</a>).
Over 57 thousand professional developers responded, and a majority
identified with agile methods or practices. This includes methodologies
we will study in this chapter ‚Äî such as Scrum (63% responses), Kanban
(36%), and Extreme Programming (16%). Only 15% of participants answered
Waterfall as their development method.</p>
<h2 data-number="2.3" id="extreme-programming"><span
class="header-section-number">2.3</span> Extreme Programming <a
href="#extreme-programming" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> Extreme Programming (XP) is a lightweight method proposed for
developing software with ever-changing or unclear requirements, such as
the Type B systems (Business), according to the classification described
in Chapter 1. As an agile method, XP embodies characteristics like short
iterative development cycles, less emphasis on comprehensive
documentation, incremental design, and small development teams.</p>
<p>In other words, XP is not a prescriptive method providing a detailed
step-by-step plan for software construction. Instead, XP is defined by a
set of <strong>values</strong>, <strong>principles</strong>, and
<strong>practices</strong>. This means XP is initially defined
abstractly, using values and principles that should be part of the
culture and habits of software development teams. Then, these values and
principles are materialized into a list of development practices. Often,
when deciding to adopt XP, developers and organizations focus on the
practices. However, the values and principles are also key components of
the method, as they give meaning to the proposed XP practices. To be
clear, if an organization is unprepared to embrace the XP
mindset‚Äîrepresented by its values and principles‚Äîit‚Äôs also advisable to
avoid adopting its practices.</p>
<p>In this chapter, we will first present the values and principles of
XP. Here is a list of them:</p>
<ul>
<li><p><strong>Values</strong>: Communication, simplicity, feedback,
courage, respect, and quality of life.</p></li>
<li><p><strong>Principles</strong>: Humanity, economics, mutual
benefits, continuous improvements, acknowledging failures, baby steps,
and personal responsibility.</p></li>
</ul>
<p>Next, we will describe the practices. To ease their explanation, we
decided to group them into three categories: practices about development
process, programming practices, and project management practices. Here
is a list of the practices within each group:</p>
<ul>
<li><p><strong>Development Process Practices</strong>: Customer
representative, user stories, iterations, releases, release planning,
iteration planning, planning poker, slack.</p></li>
<li><p><strong>Programming Practices</strong>: Incremental design, pair
programming, test-driven development (TDD), automated build, continuous
integration.</p></li>
<li><p><strong>Project Management Practices</strong>: Metrics, working
environment, open-scope contracts.</p></li>
</ul>
<h3 data-number="2.3.1" id="values"><span
class="header-section-number">2.3.1</span> Values <a href="#values"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> XP strongly aligns software development with three core societal
values: communication, simplicity, and feedback. Good
<strong>communication</strong> fosters learning from mistakes in every
project while <strong>simplicity</strong> underlines the existence of
simpler subsystems within complex systems. Lastly,
<strong>feedback</strong> from stakeholders counterbalances risks like
changing requirements and technology alterations. To quote Frederick
Brooks:</p>
<blockquote>
<p><q>Plan to throw away parts of your system, because you will.</q></p>
</blockquote>
<p>Effective feedback helps identify disposable components or versions
early, preventing delays and cost overruns. Additional XP values include
<strong>courage</strong>, <strong>respect</strong>, and <strong>quality
of life</strong>.</p>
<h3 data-number="2.3.2" id="principles"><span
class="header-section-number">2.3.2</span> Principles <a
href="#principles" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> While XP‚Äôs values are abstract, its practices are concrete and
pragmatic. To bridge this gap, XP encourages following specific
principles. Picture it as a river with values on one side and practices
on the other. Principles act as a bridge:</p>
<ul>
<li><p><strong>Humanity</strong>: Software development primarily draws
from human resources rather than physical assets. Successfully managing
people‚Äîencompassing expectations, growth, motivation, transparency, and
responsibility‚Äîis critical for project success.</p></li>
<li><p><strong>Economics</strong>: Software development requires
substantial financial investment. Hence, it‚Äôs not merely an intellectual
pursuit; it must deliver economic results.</p></li>
<li><p><strong>Mutual Benefits</strong>: XP asserts all decisions should
mutually benefit stakeholders. For instance, good working environments
benefit software clients and the developing team, and writing tests
benefits the initial coder and other developers working on the
project.</p></li>
<li><p><strong>Continuous Improvements</strong>: Constant improvement
trumps aiming for perfection in software development. XP encourages
routinely refining the system with iteration-by-iteration feedback and
does not advocate extensive initial planning. Building time for
reflection on practices is essential.</p></li>
<li><p><strong>Failures Happen</strong>: Accepting failures, such as
bugs and feature mismatches, is integral to quick software delivery; XP
advises not to punish developers for failures.</p></li>
<li><p><strong>Baby Steps</strong>: Secure and validated small
progressions are preferable to extensive implementations with high
discard potential.</p></li>
<li><p><strong>Personal Responsibility</strong>: Developers should
clearly comprehend their roles and responsibilities in XP, indicating
that the implementer of a requirement, or a <em>story</em>, should
handle its testing and maintenance as well.</p></li>
</ul>
<p></p>
<p><strong>Real World</strong>: One of the first systems to embrace XP
was the Chrysler Comprehensive Compensation (C3), a payroll system for
the automaker Chrysler (<a
href="https://doi.org/10.1109/2.796139">link</a>). The project initiated
in 1995 but was rebooted the following year by Kent Beck due to a lack
of tangible results. Renowned agile community member Martin Fowler
served as a consultant. While building the C3 system, many facets of the
soon-to-be-named XP method were implemented and experimented with.</p>
</div>
</div>
</div>

<footer>
All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>.
</footer>
</body>
</html>
