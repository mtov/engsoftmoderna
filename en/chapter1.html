<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Chapter 1: Introduction ‚Äì Software Engineering: A Modern Approach</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <meta name="robots" content="noindex">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p> <h4>Disclaimer: This chapter is a beta version subjected to proofreading. </h4> </p>
<header id="title-block-header">
<h1 class="title">Software Engineering: A Modern Approach</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction <a
href="#introduction" class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>Our civilization runs on software.</em> ‚Äì Bjarne Stroustrup</p>
</blockquote>
<p>In this first chapter, we outline the objectives and challenges
addressed in Software Engineering (Section 1.1). We also present and
explore the primary topics studied in this field of Computer Science
(Section 1.2). Our goal is to provide a comprehensive understanding of
the field before diving into specific topics. As Software Engineering is
a broad domain, we discuss the types of software systems that can
benefit from the principles and practices presented in this book
(Section 1.3). This is done to avoid misconceptions concerning the scope
of our work. After that, we present the topics addressed in the
remaining chapters of the book (see Section 1.4).</p>
<h2 data-number="1.1" id="definition-and-historical-context"><span
class="header-section-number">1.1</span> Definition and Historical
Context <a href="#definition-and-historical-context" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>In today‚Äôs world, virtually everything operates via software. Various
organizations, including businesses of every scale and governmental
entities, depend on software systems to deliver their services
effectively. Governments often interact with citizens through software
applications like public service delivery platforms and tax collection
systems. Many businesses sell a wide range of products directly to
consumers via e-commerce platforms. Software is also in physical
products, including cars, airplanes, satellites, and robots.
Furthermore, software is revitalizing traditional industries such as
telecommunications, transportation in large urban centers, and
advertising.</p>
<p>Given the crucial role software plays in our society, it‚Äôs
unsurprising that there is a field of Computer Science focusing on
proposing solutions for the development of software systems,
particularly large and complex ones. This field is known as
<strong>Software Engineering</strong>.</p>
<p>Software Engineering is concerned with systematic, disciplined, and
quantifiable approaches to develop, operate, maintain, and evolve
software systems. As mentioned, this field is central to Computer
Science and involves applying engineering principles in software
construction.</p>
<p>Historically, Software Engineering as a field emerged in the late
1960s when the first generation of computers began to be used for
problem-solving. However, at that time, software took a back seat, as
the primary focus was building machines capable of solving a limited set
of scientific or mathematical problems.</p>
<p>However, advancements in hardware technologies changed this scenario.
By the end of the ‚Äô60s, computers had become more common, were present
in many universities, and businesses were beginning to envision the
benefits of their use. Consequently, a new set of challenges surfaced,
as users demanded more complex and diverse applications, including
commercial systems for tasks such as payroll, accounting, and inventory
management.</p>
<p> <strong>NATO Conference</strong>: In October 1968, around 50 eminent
Computer Scientists gathered for a week in Garmisch, Germany, for a
NATO-sponsored conference. The purpose of this meeting was to discuss a
<q>crucial problem of computer usage, the so-called software</q>. The
conference concluded with a 130-page report advocating the construction
of software based on practical and theoretical principles, akin to other
branches of engineering. In light of this proposition, the participants
coined the term Software Engineering, effectively establishing this
field in Computer Science.</p>
<figure>
<img src="figs/cap1/otan.jpg" style="width:45.0%"
alt="Scientists at the 1968 NATO conference on Software Engineering. Reproduction kindly authorized by Prof.¬†Robert McClure." />
<figcaption aria-hidden="true">Scientists at the 1968 NATO conference on
Software Engineering. Reproduction kindly authorized by Prof.¬†Robert
McClure.</figcaption>
</figure>
<p>One of the participants of the NATO Conference summarized the
challenges faced by the new research field:</p>
<blockquote>
<p><em>The basic problem is that certain classes of systems are placing
demands on us which are beyond our capabilities and our theories and
methods of design and production at this time. There are many areas
where there is no such thing as a crisis‚Äîsort routines, payroll
applications, for example. It is large systems that are encountering
great difficulties. We should not expect the production of such systems
to be easy</em>.</p>
</blockquote>
<p>More than half a century after the NATO Conference, techniques and
methods for software construction have improved remarkably. It‚Äôs now
widely recognized that software, in most instances, should not be built
in sequential phases, as happens with traditional engineering products.
Many patterns can assist software engineers in their work, avoiding the
need to reinvent the wheel for every new design problem. Libraries and
frameworks for various purposes are available, allowing developers to
reuse code without delving into the details of tasks such as
implementing graphical interfaces, manipulating data structures,
accessing databases, and encrypting messages. Several automated testing
techniques can‚Äîand should‚Äîbe deployed to ensure that the produced code
works as expected when used by actual customers. Like other engineering
products, software also deteriorates over time and therefore require
maintenance, not only for bug fixing but also to ensure their long-term
maintainability and comprehension.</p>
<h3 class="unnumbered" id="no-silver-bullet">No Silver Bullet <a
href="#no-silver-bullet" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Software development has unique characteristics when compared to
other engineering products, especially hardware. Frederick Brooks, a
recipient of 1999 Turing Award and a pioneer in Software Engineering,
was among the first to underscore this fact. In 1987, he wrote an essay
titled <em>No Silver Bullet: Essence and Accident in Software
Engineering</em> (<a
href="https://doi.org/10.1109/MC.1987.1663532">link</a>) where he
highlights the peculiarities of Software Engineering.</p>
<p>According to Brooks, there are two types of difficulties in software
engineering: <strong>essential difficulties</strong> and
<strong>accidental difficulties</strong>. Essential ones are intrinsic
to the field and are unlikely to be solved by any novel technology or
method.</p>
<p>Indeed, the term silver bullet, as used in Brooks‚Äôs essay title,
refers to a magical solution to a complex problem. Brooks argued that
due to the essential difficulties, we should not anticipate the
existence of silver bullets in the field. Nonetheless, many new software
technologies are often marketed as if they were, in fact, silver
bullets.</p>
<p>Brooks described the following essential difficulties:</p>
<ol type="1">
<li><p>Complexity: Of all human-made constructions, software stands out
as one of the most intricate and complex. Even traditional engineering
constructs, like satellites, nuclear power plants, or rockets, are
increasingly relying on software.</p></li>
<li><p>Conformity: Software must adapt continuously to its ever-changing
environment. For instance, changes in tax legislation require prompt
adaptations by all related software. This level of adaptability is not
required in other fields like Physics, where natural laws do not change
due to human decisions.</p></li>
<li><p>Changeability: There is constant pressure for software to evolve
and incorporate new features. In fact, the more successful a software
system, the more it is likely to attract requests for
modifications.</p></li>
<li><p>Invisibility: It is inherently challenging to visualize the size
and effort required to create software due to its abstract
nature.</p></li>
</ol>
<p>Challenges (2), (3), and (4) are exclusive to software systems; they
do not exist in other engineering products, at least not with the same
intensity. When environmental laws change, car manufacturers have years
to comply with the new legislation. Also, cars, once manufactured, do
not usually receive new functionalities. Furthermore, a car‚Äôs physical
properties, such as weight, height, width, seats, and geometric shape,
facilitate valuation by consumers.</p>
<p>Software development also faces accidental difficulties, but they can
be solved by engineers given adequate training and access to existing
technologies and resources. Examples of such difficulties include an IDE
that frequently crashes, a compiler that has cryptic error messages, a
framework missing documentation, or a web application with a confusing
interface.</p>
<p> </p>
<p><strong>Real World Insight</strong>: The complexity involved in
building software systems can be illustrated by considering their size.
For instance, as of 2017, the Linux operating system (version 4.1.3)
comprised about 25 million lines of code, which were produced by nearly
1,700 engineers (<a
href="https://www.linuxfoundation.org/2017-linux-kernel-report-landing-page">link</a>).
Another example is Google‚Äôs applications which, as of January 2015,
contained over two billion lines of code, distributed across nine
million files (<a href="https://doi.org/10.1145/2854146">link</a>). At
that time, Google‚Äôs software engineers submitted about 40,000 code
change requests per day on average.</p>
<h2 data-number="1.2" id="topics-of-study"><span
class="header-section-number">1.2</span> Topics of Study <a
href="#topics-of-study" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> To present the topics of study in software engineering, we refer to
the <em>Guide to the Software Engineering Body of Knowledge</em>, also
known as the SWEBOK (<a href="http://www.swebok.org">link</a>). This
comprehensive report is organized by the IEEE Computer Society, an
internationally recognized scientific society. It is crafted with the
expertise of multiple researchers and industry professionals. The aim of
the report is to document and compile the body of knowledge indicative
of the field we now recognize as Software Engineering.</p>
<p>The SWEBOK defines the following key areas of Software
Engineering:</p>
<ol type="1">
<li>Software Requirements</li>
<li>Software Design</li>
<li>Software Construction</li>
<li>Software Testing</li>
<li>Software Maintenance</li>
<li>Software Configuration Management</li>
<li>Software Project Management</li>
<li>Software Processes</li>
<li>Software Models</li>
<li>Software Quality</li>
<li>Software Engineering Professional Practice</li>
<li>Software Engineering Economics</li>
</ol>
<p>The report also outlines three additional knowledge areas: Computing
Foundations, Mathematical Foundations, and Engineering Foundations.
However, given that they overlap with other scientific domains, they
won‚Äôt be featured in this book.</p>
<p>In the remainder of this section, we summarize each of the twelve key
areas identified above. Our objective is to give an overview of the
knowledge accumulated over the years in Software Engineering and,
consequently, shed light on what is studied in this field.</p>
<h3 data-number="1.2.1" id="requirements"><span
class="header-section-number">1.2.1</span> Requirements <a
href="#requirements" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> Requirements define <em>what</em> a system should do and
<em>how</em> it should operate. Thus, Requirements Engineering
designates the activities carried out to analyze, document, and validate
a system‚Äôs requirements.</p>
<p> Requirements can be <strong>functional</strong> or
<strong>non-functional</strong>. Functional requirements provide a
definition of the features or services a system should provide. On the
other hand, non-functional requirements outline <em>how</em> a system
should operate, including any constraints and the expected quality of
service. Examples of non-functional requirements include, but are not
limited to, performance, availability, fault tolerance, security,
privacy, interoperability, capacity, maintainability, and usability.</p>
<p>Let‚Äôs consider a banking application as an example. The functional
requirements of this application may include account balance display,
statement generation, transfers between accounts, and debit card
cancellation, among others. Meanwhile, the non-functional requirements
might be as follows:</p>
<ul>
<li>Performance: The application must be able to provide an account
balance within two seconds.</li>
<li>Availability: The application must be online 99% of the time.</li>
<li>Fault tolerance: The application must continue functioning even if a
specific data center fails.</li>
<li>Security: The application must encrypt all data to be exchanged with
branches.</li>
<li>Privacy: Customer data must be maintained confidential and not be
leaked to third parties.</li>
<li>Interoperability: The application has to integrate with Central Bank
systems.</li>
<li>Capacity: The application should have the capacity to store and
handle data for one million banking customers.</li>
<li>Usability: The application must be accessible for visually impaired
individuals.</li>
</ul>
<h3 data-number="1.2.2" id="design"><span
class="header-section-number">1.2.2</span> Design <a href="#design"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> Software design involves determining the primary code units of a
software system. However, this process only gets to the level of
interfaces, which include <strong>provided interfaces</strong> and
<strong>required interfaces</strong>. Provided interfaces are the
services that a code unit makes public for other parts of the system,
while required interfaces are those that a code unit depends on for
operation.</p>
<p>Therefore, during software design, the implementation details of each
code unit, such as the specifics of method implementations, are not
addressed. For instance, when designing a banking system, a class to
represent bank accounts might be defined as follows:</p>
<pre><code>class BankAccount {
  private Customer customer;
  private double balance;
  public double getBalance() { ... }
  public String getCustomerName() { ... }
  public String getStatement (Date start) { ... }
  ...
}</code></pre>
<p>It‚Äôs important to note that this is a simplified implementation, used
only for illustrative purposes. The <code>BankAccount</code> class
provides an interface to other classes through its public methods, thus
constituting the provided interface. However, <code>BankAccount</code>
also relies on the <code>Customer</code> class, making the
<code>Customer</code> interface a required one for
<code>BankAccount</code>. In this case, we say that
<code>BankAccount</code> depends on <code>Customer</code>.</p>
<p> When design gets more abstract and involves larger units like
packages or folders, it is called architectural design. Essentially,
<strong>software architecture</strong> refers to the organization of a
system at a higher level of abstraction than the one involving classes
or comparable code units.</p>
<h3 data-number="1.2.3" id="construction"><span
class="header-section-number">1.2.3</span> Construction <a
href="#construction" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p>Construction refers to the implementation phase, otherwise known as
coding the system. This involves making crucial choices, such as
deciding on the algorithms and data structures to use, installing and
configuring third-party frameworks and libraries, defining exception
handling policies, reaching a consensus on standards for names,
indentation, and code documentation, and also selecting the development
tools, such as compilers, integrated development environments (IDEs),
debuggers, database managers, and interface building tools.</p>
<h3 data-number="1.2.4" id="testing"><span
class="header-section-number">1.2.4</span> Testing <a href="#testing"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p>Testing involves executing a program with a finite set of cases and
checking whether it delivers the expected results. As 1982 Turing Award
recipient Edsger W. Dijkstra succinctly put it:</p>
<blockquote>
<p>Software testing can reveal the presence of bugs, but not their
absence.</p>
</blockquote>
<p>There are at least three relevant points we would like to address
about testing in this first chapter. First, we should mention that there
are many types of tests, including <strong>unit tests</strong> (testing
small code units like a class), <strong>integration tests</strong>
(testing larger units like a set of classes), <strong>performance
tests</strong> (checking system performance under specific loads), and
<strong>usability tests</strong> (evaluating the system‚Äôs user
interface‚Äôs usability).</p>
<p>Second, testing serves both verification and validation purposes.
Verification ensures a system conforms to its specifications, while
validation checks if the system meets the customer needs. The two
concepts are distinct because specifications may at times fail to meet
customer needs. This might be due to misunderstandings between
developers and users or due to poor explanations by users.</p>
<p>Two commonly used phrases help to distinguish verification and
validation:</p>
<ul>
<li>Verification: Are we correctly implementing the system according to
its specification?</li>
<li>Validation: Are we implementing the correct system‚Äîthe one that
meets customer or market needs?</li>
</ul>
<p>For instance, running a method to check whether it returns the
specified result is a verification activity, while conducting an
acceptance meeting to show the system to customers is a validation
activity.</p>
<p>It‚Äôs also necessary to distinguish between three<br />
testing-related terms: <strong>defects</strong>, <strong>bugs</strong>,
and <strong>failures</strong>. For illustration purposes, take the
following code that computes the area of a circle depending on a certain
condition:</p>
<pre><code>if (condition)
    area = pi * radius * radius * radius; </code></pre>
<p>This code has a defect, as the area of a circle should be <q>pi times
radius squared,</q> not cubed. The term <em>bug</em> is used informally
with the same meaning.</p>
<p>A failure occurs when the defective code is executed‚Äì‚Äìfor instance,
when the <code>if</code> condition above is true, and as a result, the
program delivers an incorrect result. Consequently, not every defect or
bug results in a failure since the defective code might never be
executed.</p>
<p>In summary: defective (or buggy) code is the one that does not
conform to its specification. If this code is executed and yields
incorrect results, we say that a failure has happened.</p>
<p><strong>In-Depth:</strong> The literature on testing sometimes also
mention the <strong>error</strong> and <strong>fault</strong> terms.
These terms carry the same meaning we attributed to defects. For
instance, the IEEE Standard Glossary of Software Engineering Terminology
(<a href="https://doi.org/10.1109/IEEESTD.1990.101064">link</a>) defines
a fault as an <q>incorrect step, process, or data definition in a
computer program; the terms error and bug are [also] used to express
this meaning.</q> In essence, <em>defect</em>, <em>error</em>,
<em>fault</em>, and <em>bug</em> are synonymous.</p>
<p><strong>Real World Insight:</strong> There are many software failures
that had serious financial and human consequences. A prominent example
is the 1996 explosion of French rocket Ariane 5 shortly after its launch
from Kourou, in French Guiana. About 30 seconds after the launch, the
rocket exploded due to an unexpected behavior of one of its onboard
systems. This resulted in a financial loss of approximately half a
billion dollars. Curiously, the defect that caused the failure was
confined to a few lines of an ADA function (which is a programming
language widely used in military and space software). The defective
lines were responsible for converting a 64-bit floating-point value to a
16-bit integer. During testing and likely previous Ariane launches, the
conversion always succeeded‚Äì-‚Äìthe real number always fits into an
integer. However, on the fatal launch day, a previously untested
condition required the conversion of a larger real number than the
largest 16-bit integer could accommodate. This generated an erroneous
result, causing the rocket‚Äôs control system to malfunction and
subsequently result in its explosion.</p>
<h3 data-number="1.2.5" id="maintenance-and-evolution"><span
class="header-section-number">1.2.5</span> Maintenance and Evolution <a
href="#maintenance-and-evolution" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Software systems, like traditional engineering systems, require
maintenance. In this book, we categorize the types of maintenance that
can be performed in software into the following categories:
<strong>corrective</strong>, <strong>preventive</strong>,
<strong>adaptive</strong>, <strong>refactoring</strong>, and
<strong>evolutionary</strong>.</p>
<p> Corrective maintenance aims to address bugs reported by users or
other developers. Preventive maintenance, on the other hand, focuses on
addressing latent bugs in the code that haven‚Äôt yet caused failures
observed by the users.</p>
<p></p>
<p><strong>Real World Insight</strong>: An example of preventive
maintenance are the actions taken by many companies before the turn of
the millennium, from 1999 to 2000. At this time, a significant number of
applications used two digits to represent the year in date values, i.e.,
dates were in the DD-MM-AA format. This led to concerns that date
operations in 2000 and beyond could produce incorrect results. For
instance, the calculation 00 - 99 might return an unexpected result. To
prevent this, companies created special task groups to convert all date
variables and expressions in their systems to the DD-MM-YYYY format, an
action that was therefore a prime example of preventive maintenance.</p>
<p> Adaptive maintenance aims to adjust a system in response to changes
in its environment, including technological changes, new legislative
rules, integration requirements with other systems, or customization
demands from new clients. Examples include:</p>
<ul>
<li>Updating a system from Python 2.7 to Python 3.0.</li>
<li>Customizing a system to meet the requirements of a new
customer.</li>
<li>Modifying a system to comply with changes in legislation or other
contextual changes.</li>
</ul>
<p>Refactorings are changes in a program that don‚Äôt change its external
behavior but improve its design and ease of maintenance. Refactoring
operations include renaming a method or variable, breaking a large
method into smaller ones, or moving a method to a more suitable
class.</p>
<p> Finally, evolutionary maintenance is performed to add new features
to a system or to significantly improve existing features. Its purpose
is to preserve the system‚Äôs value to the customers. For instance, many
banking systems developed in the 70s and 80s have been continually
updated and improved, ensuring their ongoing relevance and value.</p>
<p> Legacy Systems are older systems built on outdated languages,
operating systems, and databases. Despite being obsolete in
technological terms, most legacy systems remain vital due to the
critical operations they perform.</p>
<p><strong>In-Depth:</strong> Some alternative classifications for
software maintenance can be found in the literature. One proposed by
Lientz &amp; Swanson in 1978 (<a
href="https://dl.acm.org/citation.cfm?id=601062">link</a>), organizes
maintenance activities into four categories: corrective, perfective
(adding new functionalities), adaptive (changes in the software‚Äôs
operational environment), and preventive (changes aimed at enhancing a
system‚Äôs maintainability).</p>
<h3 data-number="1.2.6" id="configuration-management"><span
class="header-section-number">1.2.6</span> Configuration Management <a
href="#configuration-management" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Version control systems, such as Git, are an integral part of modern
software development. These systems store all versions of a software
project, whether it‚Äôs source code, documentation, manuals, web pages, or
reports. If a change introduces a critical bug, these systems facilitate
the restoration of a specific previous version.</p>
<p> Configuration management, however, is more than just using a system
like Git. It also includes the definition of policies to handle system
versions. For example, a team might decide on an
<em>x</em>.<em>y</em>.<em>z</em> format to identify the versions of a
library they‚Äôre working on, with <em>x</em>, <em>y</em>, and <em>z</em>
being integers. A change in <em>x</em> indicates a major version launch
with substantial new features, changes in <em>y</em> denote a minor
version with small updates, while changes in <em>z</em> point to a patch
release with only bug fixes. This scheme is often referred to as
<strong>semantic versioning</strong>.</p>
<h3 data-number="1.2.7" id="project-management"><span
class="header-section-number">1.2.7</span> Project Management <a
href="#project-management" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Project management plays a relevant role in software development. It
involves activities ranging from negotiating contracts (which define
deadlines, prices, schedules, etc.) with clients, human resource
management (hiring, training, and setting promotion policies and
remuneration values), to risk management, monitoring competition,
finance, and marketing. In this context, <strong>stakeholders</strong>
is a term that refers to all parts with a vested interest in the
project. This includes individuals or organizations that affect or are
affected by the project, such as developers, project managers,
contracted companies, supply vendors, and in some cases, government
entities.</p>
<p> Brooks‚Äô Law, stated by Frederick Brooks, is a well-known adage in
the are of software project management:</p>
<blockquote>
<p>Adding manpower to a late software project makes it later.</p>
</blockquote>
<p>The rationale is that new developers need time to understand the
codebase, architecture, and design before becoming productive. Moreover,
larger teams need more communication and coordination to facilitate
decision-making. For instance, a team with three developers
(d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>) would have three
communication channels (d<sub>1</sub>-d<sub>2</sub>,
d<sub>1</sub>-d<sub>3</sub>, and d<sub>2</sub>-d<sub>3</sub>). If the
team expands to four members, the channels double to six. With ten
developers, the communication channels increase to 45. For this reason,
software is typically developed in small teams of at most a dozen
engineers.</p>
<p><strong>In-Depth:</strong> Brooks‚Äô Law is drawn from a classic
software project management book, <em>The Mythical Man-Month</em>. The
first edition was published in 1975 (<a
href="https://dl.acm.org/citation.cfm?id=207583">link</a>), with Brooks
documenting the lessons learned from his time as an IBM project manager.
The 20th-anniversary edition includes a new chapter featuring the
article <em>No Silver Bullet ‚Äî Essence and Accidents of Software
Engineering</em>, originally published in 1987. In 1999, Frederick
Brooks received the Turing Award, the highest honor in Computer Science,
akin to a Nobel Prize.</p>
<h3 data-number="1.2.8" id="process"><span
class="header-section-number">1.2.8</span> Process <a href="#process"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> A software process defines the sequence of activities and events
necessary to build and deliver software. Indeed, software construction
can be compared to the construction of buildings, which need to follow a
particular sequence of activities: foundation, masonry, roofing,
plumbing installations, electrical installations, painting, among
others.</p>
<p>There are two main types of processes that are used in the
construction of software:</p>
<ul>
<li>Waterfall processes</li>
<li>Agile processes</li>
</ul>
<p> Originating in the 70s as software engineering began to gain
recognition, Waterfall processes were the first to be proposed. Taking
inspiration from traditional engineering processes, they are centered on
sequential activities, similar to the order of activities in the
building construction analogy we mentioned before. The usage of
Waterfall was very common until the 1990s, largely due to a
standardization issued by the US Department of Defense in 1985. Around
this period, all software contracted by the Department of Defense had to
be built using Waterfall.</p>
<p>Also known as <strong>plan-driven processes</strong>, Waterfall
proposes a construction sequence where each stage flows sequentially
like a waterfall. As illustrated in the next figure, these stages are
requirement specification, analysis, detailed design, implementation,
and testing. The implemented system is released for production use upon
the waterfall‚Äôs completion.</p>
<figure>
<img src="./figs/cap1/waterfall-en.svg" style="width:87.0%"
alt="Phases of a Waterfall process" />
<figcaption aria-hidden="true">Phases of a Waterfall
process</figcaption>
</figure>
<p> However, Waterfall faced severe criticism in the late 90s due to
frequent project delays and cost overruns. These issues usually happen
because Waterfall requires a full requirements gathering phase, a
complete design phase, followed by a a full implementation and testing
phase before deploying the system to users. Therefore, users may have to
wait years to see a piece of software running. By then, the world may
have changed, as well as the needs of the customers, who no longer need
the system they demanded years before.</p>
<p>To address these challenges, a group of 17 software engineers
proposed an alternative approach, called Agile, at a meeting in Utah,
United States, in February 2001. They also published a manifesto
detailing the new approach, which they called the Agile Manifesto (<a
href="https://agilemanifesto.org">link</a>). Contrary to the Waterfall
approach, Agile recommends building a system incrementally and
iteratively with validation by users at every iteration.</p>
<p>The concepts behind Agile have significantly impacted the software
industry and are used today across organizations of many sizes. Various
methods derived from these principles, such as <strong>XP</strong>,
<strong>Scrum</strong>, and <strong>Kanban</strong>. Agile methods also
promoted the adoption of various development practices, such as
<strong>automated testing</strong>, <strong>test-driven
development</strong> (i.e., writing the tests before the actual code),
and <strong>continuous integration</strong>. This last practice
recommends that developers integrate the code they produce immediately.
If possible, every day, for example. The goal is to avoid integration
conflicts, which occur when two developers change the same lines of code
in parallel.</p>
<h3 data-number="1.2.9" id="models"><span
class="header-section-number">1.2.9</span> Models <a href="#models"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> Software models provide a higher-level representation of a system
than its source code, enabling developers to analyze a system‚Äôs
essential properties and characteristics without deep-diving into the
source code details. These models can be created before the code, when
they are used to support <strong>Forward Engineering</strong>, or they
can be created for understanding an existing code base, in which case
they aid in <strong>Reverse Engineering</strong>.</p>
<p> Typically, software models use graphical notations‚Äîfor instance,
<strong>UML</strong> (Unified Modeling Language), a notation featuring
more than a dozen graphical diagrams proposed to model structural and
behavioral properties of a software project. The next figure shows a UML
diagram‚Äîcalled a Class Diagram‚Äîfor the code used in the section on
Software Design. In this diagram, the rectangular boxes represent
classes, including their attributes and methods. Arrows denote
relationships between classes. There are also editors for creating UML
diagrams, which can be used, for example, in forward engineering
scenarios.</p>
<figure>
<img src="figs/cap1/uml-intro-en.svg" style="width:85.0%"
alt="Example of UML Class Diagram" />
<figcaption aria-hidden="true">Example of UML Class Diagram</figcaption>
</figure>
<h3 data-number="1.2.10" id="quality"><span
class="header-section-number">1.2.10</span> Quality <a href="#quality"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> Quality is a prominent goal in the engineering of products,
reflected across various industries, such as automobile manufacturing,
cell phone production, computer companies, and construction. Similarly,
quality is of utmost importance in software engineering. A
classification proposed by Bertrand Meyer (<a
href="https://dl.acm.org/citation.cfm?id=261119">link</a>) suggests that
software quality can be evaluated in two dimensions: <strong>external
quality</strong> and <strong>internal quality</strong>.</p>
<p> External quality refers to factors that can be assessed without
delving into the source code. Thus, these factors can be evaluated by
end-users who are not necessarily experts in software engineering. Some
examples of external quality factors (or attributes) are:</p>
<ul>
<li>Correctness: Does the software align with its specification and
perform as expected under normal conditions?</li>
<li>Robustness: Can the software continue to function appropriately
during exceptional circumstances, such as communication or disk
failures? A robust software implementation should not crash due to such
events, instead, it should alert users about the abnormal
operation.</li>
<li>Efficiency: Does the software optimally use the available
computational resources?</li>
<li>Portability: Is the software adaptable to other platforms and
operating systems? Is it available for major operating systems such as
Windows, Linux, and macOS or, in the case of mobile apps, does it
support Android and iOS?</li>
<li>Ease of Use: Does the software have a user-friendly interface, clear
error messages, and support multiple languages? Can users with
disabilities, such as visual or auditory impairments use it?</li>
<li>Compatibility: Does the software support primary data formats common
in its domain? For instance, a spreadsheet should import files in XLS
and CSV formats.</li>
</ul>
<p> In contrast, internal quality relates to properties associated to
the system‚Äôs implementation. Assessment of internal quality requires
expertise in software engineering and it isn‚Äôt typically something for
end-users. Examples of internal quality factors (or attributes) include
modularity, code readability, maintainability, and testability.</p>
<p>The assurance of software quality can be achieved via several
strategies. Firstly, <strong>metrics</strong> can be used to track the
development process, including source code metrics and process metrics.
Code metric examples include the number of lines in a program, which
provides an indication of its size. Process metrics include, for
example, the number of bugs reported by end-users over a specific
period.</p>
<p> There are also practices that support the production of high-quality
software. Notably, many organizations implement <strong>code
reviews</strong>, where the code written by one developer only moves to
production after another team member reviews and approves it. This
practice aids in early bug detection (before the system enters
production) and improves the internal quality of the code (i.e., its
maintainability, readability, modularity, etc.). It also encourages the
dissemination of good software engineering practices within the
team.</p>
<p>The next figure shows an example of code review, referring to an
example we used in the Software Testing section. As we can see, this
code was reviewed by another developer, called the reviewer, before
being put into production. In the case, the reviewer noticed a bug and
reported it in a comment. After that, the developer responsible for the
code should fix the bug and resubmit the new code for review and
approval. There are several tools to support code review practices. In
the example, we used the tool provided by GitHub.</p>
<figure>
<img src="figs/cap1/github.png" style="width:65.0%"
alt="Example of code review." />
<figcaption aria-hidden="true">Example of code review.</figcaption>
</figure>
<h3 data-number="1.2.11" id="professional-practice"><span
class="header-section-number">1.2.11</span> Professional Practice <a
href="#professional-practice" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> The opening quote of this chapter by Bjarne Stroustrup states that
<em>our civilization runs on software</em>. For this reason, there are a
myriad of opportunities for software professionals. However, the
prevalence of software today also implies in challenges and
responsibilities. For example, questions surrounding the professional
practice of software engineering start to arise when formulating
undergraduate curricula. Courses in the area should offer a solid
foundation in fundamental aspects of Computer Science, such as
algorithms and data structures, while also covering concepts,
methodologies, and techniques that are widely used by professionals.</p>
<p> Equally important is the discussion about the <strong>ethical
responsibility</strong> of software engineers, particularly in a society
where human interactions are increasingly mediated by software and
algorithms. Scientific societies within the field have formulated codes
to guide computing professionals in exercising their profession
ethically. For instance, the ACM‚Äôs Code of Ethics (<a
href="https://www.acm.org/code-of-ethics">link</a>) and the IEEE
Computer Society‚Äôs Code of Ethics (<a
href="https://www.computer.org/education/code-of-ethics">link</a>). The
latter puts special emphasis on the practice of software engineering,
asserting that:</p>
<blockquote>
<p>Software engineers shall commit themselves to making the analysis,
specification, design, development, testing, and maintenance of software
a beneficial and respected profession.</p>
</blockquote>
<p><strong>Real World Insight:</strong> Stack Overflow holds an annual
survey, which in 2018 received responses from over 100,000 developers
worldwide. A section of the survey focused on ethical considerations (<a
href="https://insights.stackoverflow.com/survey/2018#ethics">link</a>).
One question asked if developers felt obligated to consider the ethical
implications of the code they create‚Äîalmost 80% responded positively.
Another question asked who should hold the responsibility for code that
leads to unethical behavior, to which 57% pointed to the company‚Äôs top
management and 23% felt it was the developers themselves. When asked if
they would agree to write code with ethical issues, 58% said no, while
37% responded that it would depend on the code‚Äôs requirements.</p>
<h3 data-number="1.2.12" id="economics"><span
class="header-section-number">1.2.12</span> Economics <a
href="#economics" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> Numerous economic factors are interlaced with software development.
For instance, software startups must select their monetization
model‚Äîperhaps a subscription-based or advertisement-supported model.
Mobile app developers must decide how much to charge for their apps, a
decision that requires understanding their competitors‚Äô pricing among
other variables. With such complex and relevant economic considerations,
it‚Äôs no surprise that large software companies nowadays hire economists
to evaluate these factors related to their products.</p>
<p>As a practical example, economists frequently discuss the opportunity
costs of a decision. These costs represent the missed opportunities
associated with discarded solutions or choices. If you choose decision X
over Y, the benefits of Y become your missed opportunities. For
instance, imagine your company‚Äôs main product has a list of bugs. Sure,
fixing these bugs will satisfy customers and potentially prevent churn.
However, this decision also has an opportunity cost. Instead of bug
fixing, the company could invest in new features, which would contribute
to expand the customer base. Thus, deciding between bug fixes or new
features ultimately becomes an economic decision.</p>
<h2 data-number="1.3" id="classification-of-software-systems"><span
class="header-section-number">1.3</span> Classification of Software
Systems <a href="#classification-of-software-systems"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> Software is part of a wide array of human activities. It comes in
different sizes and types, fulfilling a variety of functional and
non-functional requirements. As such, it‚Äôs important to avoid the
misconception that there is a single and universal method for software
development. In other words, we should not assume that all software must
follow the same processes, design guidelines, architectural patterns, or
quality assurance practices.</p>
<p> Bertrand Meyer proposed a classification (<a
href="https://bertrandmeyer.com/2013/03/25/the-abc-of-software-engineering/">link</a>)
that assists in distinguishing between the types of software that can be
developed and in identifying the most recommended software engineering
practices for each one. According to Meyer, there are three primary
types of software: Acute Systems (A), Business Systems (B), and Casual
Systems (C). We discuss Casual and Acute systems first, followed by
Business systems.</p>
<p> Casual systems, or Type C systems, are not under much pressure for
high-quality performance. They can tolerate minor bugs without
jeopardizing their operation. As examples, we can mention an academic
project script, a data migration program for one-time-use, or a system
to manage a student association‚Äôs membership. These systems do not
necessarily require high internal quality standards, optimal runtime
performance, or sophisticated user interfaces. They are typically
implemented by a single developer and are non-critical and lightweight.
As a result, they do not benefit that much from the practices,
techniques, and processes discussed in this book. In fact,
<strong>over-engineering</strong> is a risk for such systems, as there‚Äôs
no need for advanced techniques.</p>
<p> On the other end of the spectrum, we have Acute systems, or Type A
systems, where a single failure can have devastating consequences,
including the loss of human lifes. Notable examples include control
systems used in autonomous vehicles, nuclear power plants, airplanes,
ICU equipment, and subway trains. The software that controlled the
Ariane 5 rocket is an illustrative sample. Developing these systems
requires rigorous processes, including comprehensive code review and
external certification. It‚Äôs common to have hardware and software
redundancies‚Äîfor example, two systems running in parallel that only
makes a decision when both agree. Sometimes, Type A systems are designed
using a formal language based on logic or set theory.</p>
<p><strong>Alert:</strong> In this book, we will not cover Type A
(Acute) or mission-critical systems.</p>
<p>Lastly, we have Business Systems, or Type B systems. These systems
are the ones that benefit the most from the principles and practices
discussed in this book. They cover a wide array of corporate
applications (like finance, HR, logistics, sales), various web-based
systems, software libraries and frameworks, general-purpose applications
(such as text editors, spreadsheets), and basic software systems (like
compilers, IDEs). The practices presented in this book were proposed to
make the development of Type B systems more productive and to contribute
to their quality, both internally (for example, resulting in systems
that are easier to maintain) and externally (producing systems with
fewer bugs, for example).</p>
<h2 data-number="1.4" id="upcoming-chapters"><span
class="header-section-number">1.4</span> Upcoming Chapters <a
href="#upcoming-chapters" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>This book has 10 chapters and one appendix:</p>
<p><strong>Chapter 2: Processes</strong> focuses on agile development
processes, specifically XP, Scrum, and Kanban. Our decision to focus on
agile methods derives from their wide usage in modern software
development nowadays. However, we also briefly cover traditional
processes like Waterfall and the Unified Process.</p>
<p><strong>Chapter 3: Requirements</strong> begins with a discussion on
the importance and the main types of requirements. Then, we introduce
two techniques for requirements elicitation and specification: user
stories for agile methods, and use cases for more traditional and
documentation-driven methods. The chapter also covers novel topics like
Minimum Viable Products (MVP) and A/B Tests, whose importance nowadays
extends beyond startups.</p>
<p><strong>Chapter 4: Models</strong> focuses on the use of UML to
create sketches during software development projects. Indeed, UML is no
longer widely used for creating detailed software models, which was its
initial goal. Despite that, we decided to cover UML in the book to
ensure a basic understanding of its diagrams, as software developers
often use them as sketches when discussing or documenting design
ideas.</p>
<p><strong>Chapter 5: Design Principles</strong>, which covers two
topics that every software engineer needs to know. They are: (1)
important properties (or considerations) in software design, including
conceptual integrity, information hiding, cohesion, and coupling; (2)
design principles, which are specific recommendations for building
software projects, such as the widely commented SOLID principles.</p>
<p><strong>Chapter 6: Design Patterns</strong> summarizes the main
design patterns defined in the literature. Essentially, design patterns
are solutions for common problems faced when designing software systems.
The discussion of each pattern is divided into three parts: (1) a
context, that is, a system in which the pattern can be useful; (2) a
problem faced when designing this system; (3) a solution to this problem
using design patterns. We also provide several code examples to
facilitate comprehension.</p>
<p><strong>Chapter 7: Architecture</strong> starts with a discussion on
the importance of software architecture. After that, we present and
discuss five architectural patterns, including: layered architectures
(such a 3-tier architectures), MVC (Model-View Controller),
Microservices, Message Queues, and Publish-Subscribe. To conclude, we
also present an architectural anti-pattern, called <em>big ball of
mud</em>, which designates systems with no architectural organization at
all. These systems might have had some architecture in the past, but it
was progressively abandoned, turning them into a spaghetti of
inter-module dependencies.</p>
<p><strong>Chapter 8: Tests</strong> has emphasis on unit tests, which
are usually implemented using frameworks like JUnit. The chapter
includes dozens of unit test examples and discuss various aspects of
these tests. For instance, we discuss good principles for writing unit
tests and also test smells, which are patterns of tests that are not
recommended. Then, we address testability, i.e., the importance of
designing and writing code that can be easily tested. The chapter also
includes a section on mocks and stubs, which are objects that enable
unit testing of code with complex dependencies, such as dependencies on
databases and other external services. After the discussion on unit
tests, we comment on two other types of tests: integration tests and
end-to-end tests. These tests verify the properties of larger code
units, like the classes that implement a given service (integration
tests) or even all the classes in a system (end-to-end test). To
conclude, we include a brief discussion about other tests, such as
black-box tests (or functional tests), white-box tests (or structural
tests), acceptance tests and tests to check non-functional requirements,
like performance.</p>
<p><strong>Chapter 9: Refactoring</strong> presents the main code
transformations that can be performed to improve the internal quality of
a software system. The presentation includes several source code
examples, some of them from actual refactorings performed on open source
systems. The aim is to provide a practical refactoring experience to the
readers and thus to help them to develop the habit of frequently
improving the design of their code. In the chapter, we conclude with a
presentation of code smells, i.e., indicators that a code structure is
not <q>smelling good</q> and therefore should be the subject of a
refactoring.</p>
<p><strong>Chapter 10: DevOps</strong> describes the movement to bring
the development (Devs) and operations (Ops) teams of a software
organization closer together. The operations team is responsible for
keeping the software up and running, and consists of network
administrators, database administrators, Site Reliability Engineers
(SRE), among others. In a traditional culture, these two teams tend to
operate independently. That is, the development team implements the
system and then <q>throws it over the wall</q> to the operations
department. To solve this problem, DevOps proposes a constant
interaction between Devs and Ops teams, from the early days of
development. The aim is to reduce the friction involved in the release
of new features. In addition to an introduction to DevOps, we will study
important practices when embracing this culture, including Version
Control, Continuous Integration, and Continuous Deployment/Delivery.</p>
<p><strong>Appendix A: Git</strong> covers the essential Git commands,
given that version control is an indispensable practice in today‚Äôs
development world.</p>
<h2 class="unnumbered" id="bibliography">Bibliography <a
href="#bibliography" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Pierre Bourque, Richard Fairley. Guide to the Software Engineering
Body of Knowledge, Version 3.0, IEEE Computer Society, 2014.</p>
<p>Armando Fox, David Patterson. Engineering Software as a Service: An
Agile Approach Using Cloud Computing. 1st edition, 2014.</p>
<p>Frederick Brooks. The Mythical Man-Month: Essays on Software
Engineering. Addison-Wesley, anniversary edition, 1995.</p>
<h2 class="unnumbered" id="exercises">Exercises <a href="#exercises"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>1. According to Frederick Brooks, software development faces
essential difficulties (for which there is no silver bullet) and
accidental ones (for which there is a solution). Give an example of an
accidental difficulty you have experienced while implementing programs,
even small ones. Suggestion: they can be related to tools you have used,
such as compilers, IDEs, databases, operating systems, etc.</p>
<p>2. Describe the differences between functional and non-functional
requirements.</p>
<p>3. Explain why tests can be considered both a software verification
and validation activity. Which tests are best suited for verification?
And which tests are recommended for validating a software system?</p>
<p>4. Why can‚Äôt tests prove the absence of bugs?</p>
<p>5. Suppose a program has only one input: a 64-bit integer. Exhaustive
testing tests a program with all possible inputs (thus, 2^64 integers,
in our case). If each test requires 1 nanosecond (10^-9 seconds),
calculate the total time required for exhaustively testing this simple
program.</p>
<p>6. Considering the historical context, explain why the first software
development processes were sequential and based on detailed planning and
documentation.</p>
<p>7. Several studies show that maintenance and evolution costs
constitute 80% or more of a software system‚Äôs total costs over its
lifecycle. Explain why this value is so high.</p>
<p>8. Refactoring is a code transformation that preserves behavior. What
is the meaning of the expression <em>preserve behavior</em>? In
practice, what restriction does it impose on refactoring activities?</p>
<p>9. Give examples of Type A (<em>Acute</em> or critical) and Type B
(<em>Business</em>) systems that you‚Äôve interacted with.</p>
<p>10. Give examples of Type C (Casual) systems that you‚Äôve
developed.</p>
<p>11. In 2015, it was discovered that millions of cars manufactured by
a major automobile company emitted pollutants within legal standards
only during laboratory tests. Under normal usage conditions, the cars
released higher levels of pollutants to enhance performance. That is,
the code possibly included a decision command like the following one
(merely illustrative, for the purpose of this exercise):</p>
<pre><code>if &quot;car being tested in a laboratory&quot;
   &quot;comply with emission standards&quot;
else 
   &quot;exceed emission standards&quot;</code></pre>
<p>What would you do if your boss asks you to write an <em>if</em> like
the one above? For more information on this episode, consult this
Wikipedia page (<a
href="https://en.wikipedia.org/wiki/Volkswagen_emissions_scandal">link</a>
page).</p>
</div>
</div>
</div>

<footer>
All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>.
</footer>
</body>
</html>
