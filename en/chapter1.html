<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Chapter 1: Introduction ‚Äì Software Engineering: A Modern Approach</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <meta name="robots" content="noindex">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p> <h4>Disclaimer: This chapter is a beta version subjected to copyediting and proofreading. </h4> </p>
<header id="title-block-header">
<h1 class="title">Software Engineering: A Modern Approach</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction <a
href="#introduction" class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>Our civilization runs on software.</em> ‚Äì Bjarne Stroustrup</p>
</blockquote>
<p>In this initial chapter, we outline the objectives and challenges
tackled in Software Engineering (see Section 1.1). We additionally
provide an overview of the primary subjects investigated in this field
of Computer Science (see Section 1.2). Our goal is to provide a
comprehensive understanding of the field before diving into specific
issues and techniques. As Software Engineering is a broad domain, we
also discuss the types of software systems that can make use of the
principles and practices presented in this book (see Section 1.3). This
is done to avoid any misconceptions concerning the scope of our work. In
conclusion, we present the topics addressed in the remaining chapters of
the book (see Section 1.4).</p>
<h2 data-number="1.1" id="definition-context-and-history"><span
class="header-section-number">1.1</span> Definition, Context, and
History <a href="#definition-context-and-history" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>In today‚Äôs world, virtually everything operates via software. Various
organizations, including businesses of every scale and governmental
entities, depend on software systems to deliver their services
effectively. Governments often interact with citizens through software
applications like public service delivery platforms and tax collection
systems. Many businesses sell a wide range of products directly to
consumers via e-commerce platforms. Software is also in physical
products, including cars, airplanes, satellites, and robots.
Furthermore, software is revitalizing traditional industries such as
telecommunications, transportation in large urban centers, and
advertising.</p>
<p>Given the crucial role software plays in our society, it‚Äôs
unsurprising that a subfield of Computer Science focuses on finding
solutions for the development of software systems, particularly large
and complex ones. This subfield is known as <strong>Software
Engineering</strong>.</p>
<p>Software Engineering is concerned with the systematic, disciplined,
and quantifiable approaches to develop, operate, maintain, and evolve
software systems. As mentioned, this field is central to Computer
Science and is engaged with applying engineering principles in software
construction.</p>
<p>Historically, Software Engineering as a field emerged in the late
1960s when the first generation of computers began to be used for
problem-solving. However, at that time, software took a back seat, as
the primary focus was building machines capable of solving a limited set
of scientific or mathematical problems.</p>
<p>However, advancements in hardware technologies changed this scenario.
By the end of the ‚Äô60s, computers had become more common, were present
in many universities, and businesses were beginning to reap the benefits
of their use. Consequently, a new set of challenges surfaced, as users
demanded more complex and diverse applications, including commercial
systems for tasks such as payroll, accounting, and inventory
management.</p>
<p> <strong>NATO Conference</strong>: In October 1968, around 50 eminent
Computer Scientists gathered for a week in Garmisch, Germany, for a
NATO-sponsored conference. The purpose of this meeting was to discuss a
<q>crucial problem of computer usage, the so-called software</q>. The
conference concluded with a 130-page report advocating the construction
of software based on practical and theoretical principles, similar to
other branches of engineering. In light of this proposition, the
participants coined the term Software Engineering, effectively
establishing this field in Computer Science. For this reason, the NATO
Conference is considered the historical genesis of the Software
Engineering research field.</p>
<figure>
<img src="figs/cap1/otan.jpg" style="width:45.0%"
alt="Scientists at the 1968 NATO conference on Software Engineering. Reproduction kindly authorized by Prof.¬†Robert McClure." />
<figcaption aria-hidden="true">Scientists at the 1968 NATO conference on
Software Engineering. Reproduction kindly authorized by Prof.¬†Robert
McClure.</figcaption>
</figure>
<p>One of the participants of the NATO Conference summarized the
challenges faced by this new research field:</p>
<blockquote>
<p>The basic problem is that certain classes of systems are placing
demands on us which are beyond our capabilities and our theories and
methods of design and production at this time. There are many areas
where there is no such thing as a crisis‚Äîsort routines, payroll
applications, for example. It is large systems that are encountering
great difficulties. We should not expect the production of such systems
to be easy.</p>
</blockquote>
<p>More than half a century after the NATO Conference, techniques and
methods for software construction have improved remarkably. It‚Äôs now
widely recognized that software, in most instances, should not be built
in strictly sequential phases as happens with traditional engineering
products. Many patterns can assist software engineers in their work,
avoiding the need to reinvent the wheel for every new design problem.
Libraries and frameworks for various purposes are available, allowing
developers to reuse code without delving into the details of tasks such
as implementing graphical interfaces, manipulating data structures,
accessing databases, and encrypting messages. A multitude of testing
techniques can‚Äîand should‚Äîbe deployed to ensure that the produced code
functions as expected when used by actual customers. Like other
engineering products, software also deteriorates over time and therefore
require maintenance, not only for bug fixing but also to ensure their
long-term maintainability and comprehension.</p>
<h3 class="unnumbered" id="no-silver-bullet">No Silver Bullet <a
href="#no-silver-bullet" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Software development has inherent characteristics when compared to
other engineering products, especially hardware. Frederick Brooks, a
1999 Turing Award recipient and a pioneer in Software Engineering, was
among the first to underscore this uniqueness. In 1987, he wrote an
essay titled <em>No Silver Bullet: Essence and Accident in Software
Engineering</em> (<a
href="https://doi.org/10.1109/MC.1987.1663532">link</a>) where he
highlighted the peculiarities of Software Engineering.</p>
<p>According to Brooks, there are two key types of challenges in
software engineering: <strong>essential difficulties</strong> and
<strong>accidental difficulties</strong>. Essential ones are intrinsic
to the field and are unlikely to be solved by any novel technology or
method.</p>
<p>The term silver bullet, as used in Brooks‚Äôs essay title, refers to a
magical solution to a complex problem. Brooks argued that due to the
innate challenges of Software Engineering, we should not anticipate the
existence of silver bullets in the field. Nonetheless, many new software
technologies are often marketed as if they were, in fact, silver
bullets.</p>
<p>Brooks described the following essential difficulties:</p>
<ol type="1">
<li><p><strong>Complexity</strong>: Of all human-made constructions,
software stands out as one of the most intricate and complex. Even
traditional engineering constructs, like satellites, nuclear power
plants, or rockets, are increasingly relying on software.</p></li>
<li><p><strong>Conformity</strong>: Software must adapt continuously to
its ever-changing environment. For instance, changes in tax legislation
require prompt adaptations by all related software. This level of
adaptability is not required in other fields like Physics where natural
laws do not change due to human decisions.</p></li>
<li><p><strong>Changeability</strong>: There is constant pressure for
software to evolve and incorporate new features. In fact, the more
successful a software system, the more it is likely to attract demands
for modifications.</p></li>
<li><p><strong>Invisibility</strong>: It is inherently challenging to
visualize the size and effort required to create software due to its
abstract nature.</p></li>
</ol>
<p>Challenges (2), (3), and (4) are exclusive to software systems. They
do not exist in other engineering products, at least not with the same
intensity. When environmental laws change, car manufacturers have years
to comply with new legislation. Also, cars, once manufactured, do not
usually receive new functionalities. Furthermore, a car‚Äôs physical
properties, such as weight, height, width, seats, and geometric shape,
facilitate valuation by consumers.</p>
<p>Software development also faces accidental difficulties, which can
typically be solved by engineers given adequate training and access to
existing technologies and resources. Examples of such difficulties
include an IDE that frequently crashes, a compiler that produces cryptic
error messages, a framework missing documentation, or a web application
with a confusing interface.</p>
<p> </p>
<p><strong>Real World Insight</strong>: The complexity involved in
building software systems can be illustrated by considering their scale.
For instance, as of 2017, the Linux operating system (version 4.1.3)
comprised about 25 million lines of code, which were produced by nearly
1,700 engineers (<a
href="https://www.linuxfoundation.org/2017-linux-kernel-report-landing-page">link</a>).
Another example is Google‚Äôs applications which, as of January 2015,
contained over two billion lines of code, distributed across nine
million files (<a href="https://doi.org/10.1145/2854146">link</a>). At
that time, Google‚Äôs software engineers submitted about 40,000 code
change requests per day on average.</p>
<h2 data-number="1.2" id="topics-of-study-in-software-engineering"><span
class="header-section-number">1.2</span> Topics of Study in Software
Engineering <a href="#topics-of-study-in-software-engineering"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> To discuss the core areas of study in software engineering, we refer
to the <em>Guide to the Software Engineering Body of Knowledge</em>,
also known as the SWEBOK (<a href="http://www.swebok.org">link</a>).
This comprehensive report is organized by the IEEE Computer Society, an
internationally recognized scientific society. It is crafted with the
expertise of multiple researchers and industry professionals. The aim of
the SWEBOK is to document and compile the body of knowledge indicative
of the field we now recognize as Software Engineering.</p>
<p>The SWEBOK identifies and categorizes the following twelve key areas
of Software Engineering:</p>
<ol type="1">
<li>Requirements Engineering</li>
<li>Software Design</li>
<li>Software Construction</li>
<li>Software Testing</li>
<li>Software Maintenance</li>
<li>Configuration Management</li>
<li>Project Management</li>
<li>Software Processes</li>
<li>Software Models</li>
<li>Software Quality</li>
<li>Professional Practice</li>
<li>Software Economics</li>
</ol>
<p>The SWEBOK also outlines three additional knowledge areas: Computing
Foundations, Mathematical Foundations, and Engineering Foundations.
However, given that they overlap with other scientific domains, they
won‚Äôt be featured in this book.</p>
<p>In the remainder of this section, we provide a summary of each of the
twelve key areas identified above. Our objective is to give an overview
of the knowledge accumulated over the years in Software Engineering and,
consequently, shed light on what is studied in this field.</p>
<h3 data-number="1.2.1" id="requirements-engineering"><span
class="header-section-number">1.2.1</span> Requirements Engineering <a
href="#requirements-engineering" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Requirements define <em>what</em> a system should do and
<em>how</em> it should operate. Thus, Requirements Engineering
designates the activities carried out to analyze, document, and validate
a system‚Äôs requirements. Requirements can be <strong>functional</strong>
or <strong>non-functional</strong>.</p>
<p> Functional requirements provide a detailed definition of the
functionalities or services a system should provide. On the other hand,
non-functional requirements outline <em>how</em> a system should
operate, including any constraints and the expected quality of service.
Examples of non-functional requirements include, but are not limited to,
performance, availability, fault tolerance, security, privacy,
interoperability, capacity, maintainability, and usability.</p>
<p>Let‚Äôs consider a banking application as an example. The functional
requirements of this application may include account balance display,
statement generation, transfers between accounts, and debit card
cancellation, among others. Meanwhile, the non-functional requirements
might be as follows:</p>
<ul>
<li><strong>Performance</strong>: The application must be able to
provide an account balance within two seconds.</li>
<li><strong>Availability</strong>: The application must be online 99% of
the time.</li>
<li><strong>Fault tolerance</strong>: The application must continue
functioning even if a specific data center fails.</li>
<li><strong>Security</strong>: The application must encrypt all data to
be exchanged with branches.</li>
<li><strong>Privacy</strong>: Customer data must be maintained
confidential and not be leaked to third parties.</li>
<li><strong>Interoperability</strong>: The application has to integrate
with Central Bank systems.</li>
<li><strong>Capacity</strong>: The application should have the capacity
to store and handle data for one million banking customers.</li>
<li><strong>Usability</strong>: The application must be accessible for
visually impaired individuals.</li>
</ul>
<h3 data-number="1.2.2" id="software-design"><span
class="header-section-number">1.2.2</span> Software Design <a
href="#software-design" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Software design involves determining the primary code units of a
software system. However, this process only gets to the level of
interfaces, which include <strong>provided interfaces</strong> and
<strong>required interfaces</strong>. Provided interfaces are the
services that a code unit makes public for other parts of the system,
while required interfaces are those that a code unit depends on for
operation.</p>
<p>Therefore, during software system design, implementation details of
each code unit, such as the specifics of method implementations, are not
addressed. For instance, in designing a banking system, a class to
represent bank accounts might be defined as follows:</p>
<pre><code>class BankAccount {
   private Customer customer;
   private double balance;
   public double getBalance() { ... }
   public String getCustomerName() { ... }
   public String getStatement (Date start) { ... }
   ...
}</code></pre>
<p>It‚Äôs crucial to note that this is a simplified implementation, used
only for illustrative purposes. The <code>BankAccount</code> class
provides an interface to other system classes through its public
methods, thus constituting the provided interface. However,
<code>BankAccount</code> also relies on the <code>Customer</code> class,
making the <code>Customer</code> interface a required one for
<code>BankAccount</code>. This dependency on required interfaces is
often referred to as <q>dependencies</q>. In this case,
<code>BankAccount</code> depends on <code>Customer</code>.</p>
<p> When design gets more abstract and involves larger units like
packages or folders, it steps into the domain of architectural design.
Essentially, <strong>software architecture</strong> refers to the
organization of a system at a higher level of abstraction than the one
involving classes or comparable constructs.</p>
<h3 data-number="1.2.3" id="software-construction"><span
class="header-section-number">1.2.3</span> Software Construction <a
href="#software-construction" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Construction refers to the implementation phase, otherwise known as
coding the system. This involves making crucial choices, such as
deciding on the algorithms and data structures to use, installing and
configuring third-party frameworks and libraries, defining exception
handling policies, reaching a consensus on standards for names,
indentation, and code documentation, and also selecting the development
tools, such as compilers, integrated development environments (IDEs),
debuggers, database managers, and interface building tools.</p>
<h3 data-number="1.2.4" id="software-testing"><span
class="header-section-number">1.2.4</span> Software Testing <a
href="#software-testing" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Testing involves executing a program with a finite set of cases and
checking whether it delivers the expected outcomes. As 1982 Turing Award
recipient Edsger W. Dijkstra succinctly put it:</p>
<blockquote>
<p>Software testing can reveal the presence of bugs, but not their
absence.</p>
</blockquote>
<p>There are at least three critical points to address about testing in
this introductory chapter. First, there are many types of tests,
including <strong>unit tests</strong> (testing small code units like a
class), <strong>integration tests</strong> (testing larger units like a
set of classes), <strong>performance tests</strong> (checking system
performance under specific loads), and <strong>usability tests</strong>
(evaluating the system‚Äôs user interface‚Äôs usability).</p>
<p>Second, testing serves both verification and validation purposes.
Verification ensures a system conforms to its specifications, while
validation checks if the system meets customer needs. The two concepts
are distinct because specifications may at times fail to meet customer
needs. This might be due to an error during the requirements
specification phase. Misunderstandings between developers and users, or
simply poor explanations by users, are typical causes.</p>
<p>Two commonly used phrases succinctly differentiate verification and
validation:</p>
<ul>
<li><strong>Verification</strong>: Are we correctly implementing the
system according with its requirements?</li>
<li><strong>Validation</strong>: Are we implementing the correct
system‚Äîthe one that meets customer or market needs?</li>
</ul>
<p>For instance, running a method to check its return of specified
results is a verification activity, while conducting an acceptance
meeting to demonstrate the system to clients is a validation
activity.</p>
<p>It‚Äôs also necessary to distinguish between three important
testing-related terms: <strong>defects</strong>, <strong>bugs</strong>,
and <strong>failures</strong>. For illustration purposes, take the
following code that computes the area of a circle depending on a certain
condition:</p>
<pre><code>if (condition)
    area = pi * radius * radius * radius; </code></pre>
<p>This code contains a defect, as the area of a circle should be <q>pi
times radius squared,</q> not cubed. The term <em>bug</em> is frequently
used informally and often the same meaning as defects. However, a
failure occurs when the defective code is executed‚Äì‚Äìfor instance, when
the <code>if</code> condition above is true, and as a result, the
program delivers an incorrect result. Consequently, not every defect or
bug results in a failure since the defective code might never be
executed.</p>
<p>In summary: defective (or buggy) code is the one that fails to
conform to its specification. If this code is executed and yields
incorrect output, it is then that we state that a failure has
happened.</p>
<p><strong>For Further Exploration:</strong> Literature on testing may
sometimes mention <strong>error</strong> and <strong>fault</strong>
terms. These terms carry the same meaning we attributed to
<em>defect</em>. For instance, the <em>IEEE Standard Glossary of
Software Engineering Terminology</em>(<a
href="https://doi.org/10.1109/IEEESTD.1990.101064">link</a>) defines a
fault as an <q>incorrect step, process, or data definition in a computer
program; the terms error and bug are [also] used to express this
meaning.</q> In essence, <em>defect</em>, <em>error</em>,
<em>fault</em>, and <em>bug</em> are synonymous.</p>
<p><strong>Real World Insight:</strong> There are many software failures
that have had serious financial and human consequences. A prominent
example is the 1996 explosion of French rocket Ariane 5 shortly after
its launch from Kourou, French Guiana. About 30 seconds after the
launch, the rocket exploded thanks to an unexpected behavior of one of
its onboard systems. This resulted in a financial loss of approximately
half a billion dollars. Curiously, the defect that caused the failure
was minor, specific, and confined only to a few lines of an ADA code
(which is a programming language extensively used in military and space
software development). The defective lines were responsible for
converting a 64-bit floating-point value to a 16-bit integer. During
testing and likely previous rocket launches, the conversion always
succeeded‚Äì‚Äìthe real number always fit into an integer. However, on the
fatal launch day, an untested condition required the conversion of a
larger real number than the largest 16-bit integer could accommodate.
This generated an erroneous result, causing the rocket‚Äôs control system
to malfunction and subsequently result in its explosion.</p>
<h3 data-number="1.2.5" id="software-maintenance-and-evolution"><span
class="header-section-number">1.2.5</span> Software Maintenance and
Evolution <a href="#software-maintenance-and-evolution"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> Software systems, like traditional engineering systems, require
maintenance. In this book we categorize the types of maintenance that
may need to be carried out on a software system into
<strong>corrective</strong>, <strong>preventive</strong>,
<strong>adaptive</strong>, <strong>refactoring</strong>, and
<strong>evolutionary</strong>.</p>
<p> Corrective maintenance aims to address bugs reported by users or
other developers.</p>
<p> Preventive maintenance, on the other hand, focuses on addressing
latent bugs in the code that haven‚Äôt yet caused noticeable failures for
the system‚Äôs users.</p>
<p></p>
<p><strong>Real World Insight</strong>: An example of preventive
maintenance can be seen in the actions taken by many companies before
the turn of the millennium, from 1999 to 2000. At this time, a
significant number of software applications used two digits to represent
the year in date values, i.e., dates were in the DD-MM-AA format. This
led to concerns that date operations in the year 2000 and beyond could
produce incorrect results. For instance, the calculation 00 - 99 might
return an unexpected result. To prevent this, companies created special
task groups to convert all date values in their systems to the
DD-MM-YYYY format, an action that was a prime example of preventive
maintenance.</p>
<p> Adaptive maintenance aims to adjust a system in response to changes
in its environment, including technological changes, new legislative
rules, integration requirements with other systems, or customization
requests from new users. Examples include:</p>
<ul>
<li>Updating a system from Python 2.7 to Python 3.0.</li>
<li>Customizing a system to meet the requirements of a new user.</li>
<li>Modifying a system to comply with changes in legislation or other
contextual changes.</li>
</ul>
<p>Refactorings are changes in the code that don‚Äôt change its external
behavior but improve its design and ease of maintenance. Refactoring
operations include renaming a method or variable, breaking a large
method into smaller ones, or moving a method to a more suitable
class.</p>
<p> Evolutionary Maintenance is performed to add new features to a
system or to significantly improve existing ones. Its purpose is to
preserve the system‚Äôs value to the customers. Many banking systems
developed in the 70s and 80s, for instance, have been continually
updated and improved, ensuring their ongoing relevance and value.</p>
<p> <strong>Legacy Systems</strong> are older systems built on outdated
languages, operating systems, and databases. Despite being obsolete in
technological terms, these systems remain vital due to the critical
operations they perform.</p>
<p><strong>For Further Exploration:</strong>: Some alternative
classifications for software maintenance types can be found in the
literature. One proposed by Lientz &amp; Swanson in 1978 (<a
href="https://dl.acm.org/citation.cfm?id=601062">link</a>), organizes
maintenance activities into four categories: corrective, perfective
(adding new functionalities), adaptive (concerning changes in the
software‚Äôs operational environment), and preventive (changes aimed at
enhancing a system‚Äôs maintainability).</p>
<h3 data-number="1.2.6" id="software-configuration-management"><span
class="header-section-number">1.2.6</span> Software Configuration
Management <a href="#software-configuration-management"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> Version control systems, such as Git, are an integral part of modern
software development. These systems store all versions of a software
project, whether it‚Äôs source code, documentation, manuals, web pages, or
reports. If a change introduces a critical bug, these systems facilitate
the easy restoration of a specific previous version.</p>
<p> Configuration management, however, is more extensive than just using
a system like Git. It encompasses the definition of policies to handle
system versions. For example, a team might decide on an
<em>x</em>.<em>y</em>.<em>z</em> format to identify the versions of a
library they‚Äôre working on, with <em>x</em>, <em>y</em>, and <em>z</em>
being integers. A change in <em>x</em> indicates a major version launch
with substantial new features, <em>y</em> denotes a minor version with
small updates, while <em>z</em> points to a patch release for bug fixes.
This identification scheme is often referred to as <strong>semantic
versioning</strong>.</p>
<h3 data-number="1.2.7" id="software-project-management"><span
class="header-section-number">1.2.7</span> Software Project Management
<a href="#software-project-management" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Project management plays a crucial role in software development. It
involves activities ranging from negotiating contracts (which define
deadlines, prices, schedules, etc.) with clients, human resource
management (hiring, training, and setting promotion policies and
remuneration values), to risk management, monitoring competition,
finance, and marketing. In this context, <strong>stakeholders</strong>
refer to all entities with a vested interest in the project. This
usually includes individuals or organizations that affect or are
affected by the project, such as developers, project managers,
contracted companies, supply vendors, and in some cases, government
entities.</p>
<p> Brooks‚Äô Law, stated by Frederick Brooks, is a well-known adage in
the are of software projects:</p>
<blockquote>
<p>Adding manpower to a late software project makes it later.</p>
</blockquote>
<p>New developers need time to understand the codebase, architecture,
and design before becoming productive. Moreover, larger teams need more
communication and coordination to facilitate decision-making. For
instance, a team with three developers (d<sub>1</sub>, d<sub>2</sub>,
d<sub>3</sub>) would have three communication channels
(d<sub>1</sub>-d<sub>2</sub>, d<sub>1</sub>-d<sub>3</sub>, and
d<sub>2</sub>-d<sub>3</sub>). If the team expands to four members, the
channels double to six. With ten developers, the communication channels
increase to 45. For this reason, software is typically developed in
small teams of at most a dozen engineers.</p>
<p><strong>For Further Exploration:</strong> Brooks‚Äô Law is drawn from a
classic software project management book, <em>The Mythical
Man-Month</em>. The first edition was published in 1975 (<a
href="https://dl.acm.org/citation.cfm?id=207583">link</a>), with Brooks
documenting the lessons learned from his time as an IBM project manager.
The 20th-anniversary edition includes a new chapter featuring the
article, <em>No Silver Bullet ‚Äî Essence and Accidents of Software
Engineering</em>, originally published in 1987. In 1999, Frederick
Brooks received the Turing Award, the highest honor in Computer Science,
akin to a Nobel Prize.</p>
<h3 data-number="1.2.8" id="software-processes"><span
class="header-section-number">1.2.8</span> Software Processes <a
href="#software-processes" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> A software development process outlines the sequence of activities
and events necessary to build and deliver software. This process can be
compared to the construction of buildings, which follow a particular
sequence of activities: foundation, masonry, roofing, plumbing
installations, electrical installations, painting, among others.</p>
<p>There are two main types of processes that are used in the
construction of software</p>
<ul>
<li>Waterfall processes</li>
<li>Agile processes</li>
</ul>
<p> Originating in the 70s as software engineering began to gain
recognition, Waterfall processes were the first to be proposed. Taking
inspiration from traditional engineering processes, they are centered on
sequential activities, similar to the order of activities in the
building construction analogy. Usage of Waterfall was very common until
the 1990s, largely due to a standardization issued by the US Department
of Defense in 1985. Around this period, all software contracted by the
Department of Defense had to be built using Waterfall.</p>
<p>Also known as <strong>plan-driven processes</strong>, Waterfall
processes propose a system construction sequence where each stage flows
sequentially like a waterfall. As illustrated in the next figure, the
stages include requirement specification, analysis, detailed design,
coding, and testing. The system is released for production use upon the
waterfall‚Äôs completion.</p>
<figure>
<img src="./figs/cap1/waterfall-en.svg" style="width:87.0%"
alt="Phases of a Waterfall process." />
<figcaption aria-hidden="true">Phases of a Waterfall
process.</figcaption>
</figure>
<p> However, Waterfall processes encountered criticism in the late 90s
due to frequent project delays and costs overruns. These issues usually
happen because Waterfall assumes a full requirements gathering phase, a
complete design phase, followed by a a full implementation and testing
phase before validating the system with users. Therefore, the system is
validated with users only after finishing these phases, which may occur
years after the beginning. By then, the world may have changed, as well
as the needs of the customers, who no longer need the system they
demanded years before.</p>
<p>To address these challenges, a group of 17 software engineers
proposed an alternative approach, Agile, at a meeting in Utah, United
States, in February 2001. They also published a manifesto detailing the
new approach, called the <a href="https://agilemanifesto.org/">Agile
Manifesto</a>. Contrary to the Waterfall approach, Agile involves
building a system incrementally and iteratively with immediate
validation by users at every stage.</p>
<p>The concepts behind Agile have significantly impacted the software
industry and are used widely across organizations of many sizes. Various
methods derived from these principles, such as <strong>XP</strong>,
<strong>Scrum</strong>, and <strong>Kanban</strong>. Agile methods have
also promoted the adoption of various development practices, such as
<strong>automated testing</strong>, <strong>test-driven
development</strong> (i.e., writing the tests before the actual code),
and <strong>continuous integration</strong>. Continuous integration
recommends that developers integrate the code they produce immediately.
If possible, every day, for example. The goal is to avoid integration
conflicts, which occur when two developers change the same lines of code
in parallel.</p>
<h3 data-number="1.2.9" id="software-models"><span
class="header-section-number">1.2.9</span> Software Models <a
href="#software-models" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Software models provide a higher-level representation of a system
than its source code, enabling developers to analyze a system‚Äôs
essential properties and characteristics more easily and quickly without
deep-diving into the code details. These models can either be created
before the code, when they are used to support <strong>Forward
Engineering</strong>, or created for understanding an existing code
base, in which case they aid in <strong>Reverse
Engineering</strong>.</p>
<p> Many software models use graphical notations - for instance,
<strong>UML</strong> (Unified Modeling Language), a notation featuring
more than a dozen graphical diagrams to model a system‚Äôs structural and
behavioral properties. The next figure shows a UML diagram ‚Äî called a
Class Diagram ‚Äî for the code used in the section on Software Design . In
this diagram, the rectangular boxes represent classes, including their
attributes and methods. Arrows denote relationships between classes.
There are also editors for creating UML diagrams, which can be used, for
example, in Forward Engineering scenarios.</p>
<figure>
<img src="figs/cap1/uml-intro-en.svg" style="width:80.0%"
alt="Example of UML Class Diagram" />
<figcaption aria-hidden="true">Example of UML Class Diagram</figcaption>
</figure>
<h3 data-number="1.2.10" id="software-quality"><span
class="header-section-number">1.2.10</span> Software Quality <a
href="#software-quality" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Quality is a prominent goal in the engineering of products,
reflected across various industries such as automobile manufacturing,
cell phone production, computer companies, and construction. Similarly,
quality is of utmost importance in software engineering. A
classification proposed by Bertrand Meyer (<a
href="https://dl.acm.org/citation.cfm?id=261119">link</a>) suggests that
software quality can be evaluated in two dimensions: <strong>external
quality</strong> and <strong>internal quality</strong>.</p>
<p> External quality refers to factors that can be assessed without
delving into the code. These factors can be evaluated by end-users who
are not necessarily experts in software engineering. Some examples of
external quality factors (or attributes) are:</p>
<ul>
<li>Correctness: Does the software align with its specification and
perform as expected under normal conditions?</li>
<li>Robustness: Can the software continue to function appropriately
during exceptional circumstances, such as communication or disk failure?
A robust software implementation should not crash due to such events,
instead, it should alert users about the abnormal operation.</li>
<li>Efficiency: Does the software optimally use computational
resources?</li>
<li>Portability: Is the software adaptable to other platforms and
operating systems? Is it available for major operating systems such as
Windows, Linux, and macOS or, in the case of mobile apps, does it
support Android and iOS?</li>
<li>Ease of Use: Does the software have a user-friendly interface, clear
error messages, and support multiple languages? Can users with
disabilities, such as visual or auditory impairments use it?</li>
<li>Compatibility: Does the software support primary data formats
prevalent in its specific domain? For instance, a spreadsheet software
should import files in XLS and CSV formats.</li>
</ul>
<p> In contrast, internal quality relates to properties<br />
tied to the system‚Äôs implementation. Assessment of internal quality
requires expertise in software engineering and it isn‚Äôt typically
something for end-users. Examples of internal quality factors (or
attributes) include modularity, code readability, maintainability, and
testability.</p>
<p>The assurance of software quality can be achieved via several
strategies. Firstly, <strong>metrics</strong> can be utilized to track
the development process, including source code metrics and process
metrics. Code metric examples include the number of lines in a program,
providing an indication of its size. Process metrics include, for
exaple, the number of defects reported by end-users over a specific
period.</p>
<p> Additionally, there are practices that support the production of
high-quality software. Notably, many organizations implement
<strong>code reviews</strong>, where the code written by one developer
is only approved for production after another team member reviews and
inspects it. This practice aids in early bug detection (before the
system enters production) and improves the internal quality of the code
(i.e., its maintainability, readability, modularity, etc.). It also
encourages the dissemination of good software engineering practices
within the team.</p>
<p>The next figure shows an example of code review, referring to an
example we commented in the Software Testing section. When an
organization uses code reviews, this code will be reviewed by another
developer, called the reviewer, before being put into production. The
reviewer could notice the bug and tag the code with a question, before
approving it. Then, the developer responsible for the code could agree
that, in fact, there is a bug, fix the code, and resubmit it for review
and approval. There are several tools to support code review processes.
In the example, we used the tool provided by GitHub.</p>
<figure>
<img src="figs/cap1/github.png" style="width:65.0%"
alt="Example of code review" />
<figcaption aria-hidden="true">Example of code review</figcaption>
</figure>
<h3 data-number="1.2.11" id="professional-practice"><span
class="header-section-number">1.2.11</span> Professional Practice <a
href="#professional-practice" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> The opening quote of this chapter by Bjarne Stroustrup states:
<em>our civilization runs on software</em>. This statement highlights
the myriad of opportunities available to professionals in this field.
However, it als implies in challenges and responsibilities. For example,
questions surrounding the professional practice of software engineering
arise when formulating undergraduate curricula. Courses in the area
should offer a solid foundation in fundamental aspects of Computer
Science, such as algorithms and data structures, while also covering the
critical aspects of the profession including concepts, methodologies,
and techniques.</p>
<p> Equally important is the discussion about the <strong>ethical
responsibility</strong> of software engineers, particularly in a society
where human interactions are increasingly mediated by software and
algorithms. Scientific societies within the field have formulated codes
to guide computing professionals ‚Äî not just Software Engineers ‚Äî in
exercising their profession ethically. For instance, the ACM‚Äôs Code of
Ethics (<a href="https://www.acm.org/code-of-ethics">link</a>) and the
IEEE Computer Society‚Äôs Code (<a
href="https://www.computer.org/education/code-of-ethics">link</a>). The
latter puts special emphasis on the practice of software engineering,
asserting that:</p>
<blockquote>
<p>Software engineers shall commit themselves to making the analysis,
specification, design, development, testing, and maintenance of software
a beneficial and respected profession.</p>
</blockquote>
<p><strong>Real World Insight:</strong> Stack Overflow holds an annual
survey, which in 2018 received responses from over 100,000 developers
worldwide. A section of the survey focused on ethical considerations (<a
href="https://insights.stackoverflow.com/survey/2018#ethics">link</a>).
One question asked if developers felt obligated to consider the ethical
implications of the code they create ‚Äî almost 80% responded positively.
Another asked who should hold the responsibility for code that leads to
unethical behavior, to which 57.5% pointed to the company‚Äôs top
management and 23% felt it was the developers themselves. When asked if
they would consent to write code with ethical issues, 58% said no, while
37% responded that it would depend on the code‚Äôs requirements.</p>
<h3 data-number="1.2.12" id="economic-aspects"><span
class="header-section-number">1.2.12</span> Economic Aspects <a
href="#economic-aspects" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Numerous economic factors are entwined with software development.
For instance, software startups must select their monetization model ‚Äî
perhaps a subscription-based or advertisement-supported model. Mobile
app developers must decide how much to charge for their apps, a decision
that requires understanding their competitors‚Äô pricing among other
variables. With such intricate economic considerations, it‚Äôs no surprise
that large software companies now hire economists to evaluate these
factors related to their products.</p>
<p>For a practical example, economists frequently discuss the
opportunity costs of a decision. These costs represent the missed
opportunities associated with disregarded solutions or choices. If you
choose decision X over Y, the benefits of Y become your missed
opportunities. For instance, imagine your company‚Äôs main product has a
list of bugs. Sure, fixing these bugs will satisfy customers and
potentially prevent churn. However, this decision also has an
opportunity cost. Instead of bug fixing, the company could invest in new
features, which could expand the customer base. Deciding between bug
fixes or new features ultimately becomes an economic decision.</p>
<h2 data-number="1.3" id="classification-of-software-systems"><span
class="header-section-number">1.3</span> Classification of Software
Systems <a href="#classification-of-software-systems"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> Software is part to a wide array of human activities. It comes in
different sizes and types, fulfilling a variety of functional and
non-functional requirements. As such, it‚Äôs important to avoid the
misconception that there is a single and universal method for software
development. In other words, we should not assume that all software must
follow the same processes, design principles, or quality assurance
mechanisms.</p>
<p> Bertrand Meyer proposed a classification (<a
href="https://bertrandmeyer.com/2013/03/25/the-abc-of-software-engineering/">link</a>)
that assists in distinguishing between the types of software that can be
developed and in identifying suitable software engineering practices for
each one. According to Meyer, there are three primary types of software:
Acute Systems (A), Business Systems (B), and Casual Systems (C). We will
discuss Casual and Acute systems first, followed by Business
systems.</p>
<p> Casual systems, or Type C systems, are not under much pressure for
high-quality performance. They can tolerate minor bugs without
jeopardizing their operation. As examples, we can mention an academic
project script, a data migration program for one-time-use, or a system
to manage a student association‚Äôs membership. These systems do not
necessarily require high internal quality, optimal runtime performance,
or sophisticated user interfaces. They are typically implemented by a
small team and are non-critical and lightweight. As a result, they do
not benefit from the practices, techniques, and processes discussed in
this book. In fact, over-engineering poses a risk for such systems, as
there‚Äôs no need for advanced techniques.</p>
<p> On the other end of the spectrum, we have Acute systems, or Type A
systems, where a single failure can have devastating consequences,
including the potential loss of lifes. Notable examples include control
systems used in autonomous vehicles, nuclear power plants, airplanes,
ICU equipment, and subway trains. The software that controlled the
Ariane 5 rocket is an illustrative sample. Developing these systems
requires rigorous processes, including comprehensive code review and
external certification. It‚Äôs common to have hardware and software
redundancies alike‚Äîfor example, two systems running in parallel that
only make a decision when both agree. Sometimes, these systems are
designed using a formal language based on logic or set theory.</p>
<p><strong>Alert:</strong> In this book, we will not cover Type A
(Acute) or mission-critical systems.</p>
<p>Lastly, we have Business Systems (B), or Type B systems. These
systems are the ones that benefit the most from the principles and
practices discussed in this book. They cover a wide array of corporate
applications (like finance, HR, logistics, sales), various web-based
systems, software libraries and frameworks, general-purpose applications
(such as text editors, spreadsheets), and basic software systems (like
compilers, IDEs). The concepts presented in this book make the
development of Type B systems more productive and contribute to their
quality, both internally (resulting in systems that are easier to
maintain, for example) and externally (producing systems with fewer
bugs, for example).</p>
<h2 data-number="1.4" id="upcoming-chapters"><span
class="header-section-number">1.4</span> Upcoming Chapters <a
href="#upcoming-chapters" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>This book has <strong>10 chapters</strong> and <strong>one
appendix</strong>:</p>
<p><strong>Chapter 2: Processes</strong>, which focuses on agile
development processes, specifically XP, Scrum, and Kanban. Our decision
to focus on agile methods derives from their wide usage in modern
software development, regardless of the domain or size. However, we also
briefly cover traditional processes like Waterfall and the Unified
Process.</p>
<p><strong>Chapter 3: Requirements</strong>, which begins with a
discussion on the importance of requirements and the main types of
requirements. Then, we introduces two techniques for requirements
elicitation and specification: user stories for agile methods, and use
cases for more traditional and documentation-driven methods. The chapter
also covers techniques like Minimum Viable Product (MVPs) and A/B Tests,
whose importance nowadays extends beyond startups.</p>
<p><strong>Chapter 4: Models</strong>, which focuses on the use of UML
as sketches software. Indeed, UML is no longer widely used for creating
detailed software models, which was its initial goal. Rarely do
companies invest time in creating detailed UML diagrams before starting
to code. Despite, we decided to cover UML in the book to ensure a basic
understanding of its diagrams, as software developers often use them as
sketches when discussing or or documenting design ideas.</p>
<p><strong>Chapter 5: Design Principles</strong>, which covers two
topics that every software designer needs to know. They are: (1)
important properties (or considerations) in software design, including
conceptual integrity, information hiding, cohesion, and coupling; (2)
design principles, which constitute more specific recommendations for
building software projects, such as the SOLID principles.</p>
<p><strong>Chapter 6: Design Patterns</strong>, which constitute a
catalog of solutions for common software project problems. In this
chapter, we will study the main design patterns defined in the
literature. The discussion of each pattern is divided into three parts:
(1) a context, that is, a system in which the pattern can be useful; (2)
a problem faced when designing this system; (3) a solution to this
problem through patterns. We also provide several code examples to
facilitate comprehension.</p>
<p><strong>Chapter 7: Architecture</strong>, which starts with a
discussion on the importance of software architecture. After that, we
present and discuss five architectural patterns, including: layered
architectures (such a 3-tier architectures), MVC (Model-View Controler,
including a discussion on Single Page applications), Microservices,
message queues, and Publish-Subscribe architectures. To conclude, we
present an architectural anti-pattern, called <em>big ball of mud</em>,
which is a term used to designate systems with no architectural
organization. These systems might have had some architecture in their
past, but it was progressively abandoned, turning them into a spaghetti
of inter-module dependencies.</p>
<p><strong>Chapter 8: Tests</strong>, with emphasis on unit tests, using
frameworks like JUnit. The chapter includes dozens of unit test examples
and discusses various aspects of these tests. For instance, we discuss
good principles for writing unit tests and also test smells, which are
patterns of tests that are not recommended. Then, we address
testability, i.e., we discuss the importance of writing code that can be
easily tested. The chapter includes a full section on mocks and stubs,
which are objects that enable unit testing of code with more complex
dependencies, such as dependencies on databases and other external
systems. After the discussion on unit tests, we also talk, albeit in a
more summarized way, about two other types of tests: integration tests
and end-to-end tests. These tests verify the properties of larger code
units, like the classes that implement a given service or functionality
(integration tests) or even all the classes in a system (end-to-end
test). To conclude, we include a discussion about other tests, such as
black-box tests (or functional tests), white-box tests (or structural
tests), acceptance tests and also tests to verify non-functional
requirements, like performance.</p>
<p><strong>Chapter 9: Refactoring</strong>, which presents the main
refactorings that can be performed to improve the internal quality of a
software system. The presentation includes several source code examples,
some of them from actual refactorings performed on open source systems.
The aim is to provide a practical refactoring experience to the readers
and thus to help them to develop the habit of frequently improving the
design of their code. In the chapter, we also present a list of code
smells, i.e., indicators that a code structure is not <q>smelling
good</q> and therefore should be the subject of a refactoring.</p>
<p><strong>Chapter 10: DevOps</strong>, which is a movement to bring the
development (Devs) and operations (Ops) teams of a software organization
closer together. The operations team is responsible for keeping the
software up and running, and consists of network administrators,
database administrators, Site Reliability Engineers (SRE), among others.
In a traditional culture, these two teams tend to operate independently.
That is, the development team develops the system and then <q>throws it
over the wall</q> to the operations department. To solve this problem,
DevOps proposes a constant interaction between the Devs and Ops areas,
from the early days of development. The aim is to reduce the friction
involved in the release of new features. In addition to an introduction
to DevOps, we will study some important practices when a organization
adopts this culture, including Version Control, Continuous Integration,
and Continuous Deployment/Delivery.</p>
<p><strong>Appendix A: Git</strong> covers the essential Git commands,
given that version control is an indispensable practice in today‚Äôs
development world.</p>
<h2 class="unnumbered" id="bibliografia">Bibliografia <a
href="#bibliografia" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Pierre Bourque, Richard Fairley. Guide to the Software Engineering
Body of Knowledge, Version 3.0, IEEE Computer Society, 2014.</p>
<p>Armando Fox, David Patterson. Engineering Software as a Service: An
Agile Approach Using Cloud Computing. 1st edition, 2014.</p>
<p>Frederick Brooks. The Mythical Man-Month: Essays on Software
Engineering. Addison-Wesley, anniversary edition, 1995.</p>
<h2 class="unnumbered" id="exercises">Exercises <a href="#exercises"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>1. According to Frederick Brooks, software development faces
essential difficulties (for which there is no silver bullet) and
accidental ones (for which there is a better solution). Give an example
of an accidental difficulty you have experienced while developing
programs, even small ones. Suggestion: they can be related to tools you
have used, such as compilers, IDEs, databases, operating systems,
etc.</p>
<p>2. Differentiate between functional and non-functional
requirements.</p>
<p>3. Explain why tests can be considered both a software verification
and validation activity. Which test type is best suited for
verification? Which test type is recommended for validating a software
system?</p>
<p>4. Why can‚Äôt tests prove the <em>absence</em> of bugs?</p>
<p>5. Suppose a program has only one input: a 64-bit integer. Exhaustive
testing demands testing a program with all possible inputs (thus,
2<sup>64</sup>, in our case). If each test requires 1 nanosecond
(10<sup>-9</sup> seconds), calculate the total time required for
exhaustively testing our program.</p>
<p>6. Considering the historical context, explain why early software
development processes were sequential and based on comprehensive
planning and documentation.</p>
<p>7. Several studies show that maintenance and evolution costs
constitute 80% or more of a software system‚Äôs total costs over its
lifecycle. Explain why this value is so high.</p>
<p>8. Refactoring is a code transformation that preserves behavior. What
is the meaning of the expression <em>preserve behavior</em>? In
practice, what restriction does it impose on refactoring operations?</p>
<p>9. Give examples of Type A (<em>Acute</em> or critical) and Type B
(<em>Business</em> or commercial) systems that you‚Äôve interacted
with.</p>
<p>10. Give examples of Type C (Casual) systems that you‚Äôve
developed.</p>
<p>11. In 2015, it was discovered that millions of cars produced by a
major automobile company emitted pollutants within legal standards only
when they were under test in a laboratory. During normal use, the cars
emitted more pollutants to improve performance. That is, the code
included a decision structure like the following one (merely
illustrative, for the purposes of this exercise):</p>
<pre><code>if &quot;Car being tested in a laboratory&quot;
   &quot;Comply with emission standards&quot;
else 
   &quot;Exceed emission standards&quot;</code></pre>
<p>What would you do if your boss asks you to write an <em>if</em> like
the one above? For more information on this episode, consult this <a
href="https://en.wikipedia.org/wiki/Volkswagen_emissions_scandal">Wikipedia</a>
page.</p>
</div>
</div>
</div>

<footer>
All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this 
<a href="https://forms.gle/urrjFgGYgmKuJrfb9">form</a>.
</footer>
</body>
</html>
