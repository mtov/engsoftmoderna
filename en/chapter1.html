<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Chapter 1: Introduction ‚Äì Software Engineering: A Modern Approach</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <meta name="robots" content="noindex">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p> <h4>Disclaimer: This chapter is a beta version subjected to revision and final proofreading. </h4> </p>
<header id="title-block-header">
<h1 class="title">Software Engineering: A Modern Approach</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction <a
href="#introduction" class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>Our civilization runs on software.</em> ‚Äì Bjarne Stroustrup</p>
</blockquote>
<p>In this first chapter, we describe the goals and problems
investigated in Software Engineering (Section 1.1). We also provide an
overview of the main topics studied in this area of the Computer Science
(Section 1.2). Our intention is to give the reader a broad perspective
of the area before delving into specific problems and solutions.
Furthermore, since Software Engineering is a very broad area, we also
characterize the types of software systems that benefit from the
techniques and concepts presented in this book (Section 1.3). The
objective is to avoid false expectations regarding the content of our
work. Finally, we present the structure and the topics covered in the
remaining chapters of the book (Section 1.4).</p>
<h2 data-number="1.1" id="definition-context-and-history"><span
class="header-section-number">1.1</span> Definition, Context, and
History <a href="#definition-context-and-history" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>In the modern world, everything is software. For instance, companies
of any size depend on software systems to fulfill their mission.
Governments also interact with citizens through software, for example,
to provide public services or collect taxes. Companies sell an immense
range of products directly to consumers through e-commerce platforms.
Software is also embedded in many physical products and devices, such as
cars, airplanes, satellites, and robots. Finally, software is
revitalizing traditional industries and services such as
telecommunications, transportation in large urban centers, and
advertising.</p>
<p>Thus, due to the relevance of software in our world, it is not a
surprise that there is a field in Computer Science that investigates
solutions for the development of software systems‚Äîparticularly the more
complex and larger ones. This field is called <strong>Software
Engineering</strong>.</p>
<p>Software Engineering deals with the application of systematic,
disciplined, and quantifiable approaches to implementing, operating,
maintaining, and evolving software systems. As we said, it is the field
of Computer Science that is concerned with proposing and applying
engineering principles in software construction.</p>
<p>Historically, the field emerged in the late ‚Äô60s of the last century.
Around this time, the first modern computers were designed and began to
be used for solving problems. However, at that time software was not a
central concern, but rather building machines that could solve a limited
number of scientific or mathematical problems.</p>
<p>However, progress in hardware technologies quickly changed this
scenario. By the end of the ‚Äô60s, computers were more popular, they were
present in many universities and they also started to be used by major
companies. Thus, computer scientists began to face a new challenge,
since users started to demand more complex and diverse applications,
including commercial systems in areas such as payroll, accounting, and
inventory management.</p>
<p> <strong>NATO Conference</strong>: In October of 1968, a group of
around 50 renowned Computer Scientists gathered for a week in Garmisch,
Germany, for a conference sponsored by a scientific committee of NATO,
the military organization that congregates the countries of the North
Atlantic (see a picture of the meeting in the next figure). The
meeting‚Äôs goal was to draw attention to a <q>crucial problem of computer
usage, the so-called software</q>. The conference produced a report with
over 130 pages, stating the need to construct software based on
practical and theoretical principles, as happens in well-established
branches of engineering. To make this proposal clearer, the participants
decided to coin the term Software Engineering. For this reason, the NATO
Conference is considered the historical landmark for the creation of the
Software Engineering research area in Computer Science.</p>
<figure>
<img src="figs/cap1/otan.jpg" style="width:45.0%"
alt="Scientists at the 1968 NATO conference on Software Engineering. Reproduction kindly authorized by Prof.¬†Robert McClure." />
<figcaption aria-hidden="true">Scientists at the 1968 NATO conference on
Software Engineering. Reproduction kindly authorized by Prof.¬†Robert
McClure.</figcaption>
</figure>
<p>The following comment, from one of the participants of the NATO
Conference, illustrates the challenges faced by the newly-created
research area:</p>
<blockquote>
<p>The basic problem is that certain classes of systems are placing
demands on us which are beyond our capabilities and our theories and
methods of design and production at this time. There are many areas
where there is no such thing as a crisis‚Äîsort routines, payroll
applications, for example. It is large systems that are encountering
great difficulties. We should not expect the production of such systems
to be easy.</p>
</blockquote>
<p>More than half a century after the NATO Conference, the achievements
in techniques and methods for software construction are notable. Today,
it is already known that software‚Äîmost of the time‚Äîshould not be built
in strictly sequential phases, as occurs with traditional engineering
products, such as Civil Engineering, Mechanical Engineering or
Electrical Engineering. There are also many patterns that can be used by
software engineers in their systems, so that they do not need to
<q>reinvent the wheel</q> every time they face a new design problem.
Libraries and frameworks for various purposes are widely available, so
that software developers can reuse code without worrying about details
inherent to tasks like implementing graphical interfaces, manipulating
data structures, accessing databases, encrypting messages, among others.
A variety of testing techniques can (and should) be used to assert that
that failures do not occur when the code is put into production and used
by real customers. It is also known that software systems age, like
other engineering products. Therefore, software also needs maintenance,
not only corrective, to fix bugs reported by users, but also to ensure
that the systems remain easy to maintain and understand over the
years.</p>
<h3 class="unnumbered" id="no-silver-bullet">No Silver Bullet <a
href="#no-silver-bullet" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Software development is inherently different from other engineering
products, especially when we compare software with hardware. Frederick
Brooks, Turing Award in Computing (1999) and one of the pioneers of the
field of Software Engineering, was one of the first to draw attention to
this fact. In 1987, in an essay titled <em>No Silver Bullet: Essence and
Accident in Software Engineering</em> (<a
href="https://doi.org/10.1109/MC.1987.1663532">link</a>), he discussed
the peculiarities of the Software Engineering field.</p>
<p> According to Brooks, there are two types of difficulties in software
engineering: <strong>essential difficulties</strong> and
<strong>accidental difficulties</strong>. The essential ones are part of
the nature of the field and thus they probably will not be solved by any
new technology or method that might be invented.</p>
<p>In general terms, the term silver bullet ‚Äì that is part of the essay
title ‚Äì designates a magical solution to a complicated problem. Indeed,
in folklore, a silver bullet is the only way to kill a werewolf,
provided it is used on a full moon night. According to Brooks, because
of the essential difficulties that characterize the area, we should not
assume the existence of silver bullets in Software Engineering. Despite,
even after Brooks‚Äôs essay, new software technologies are often promoted
and sold as if they were silver bullets.</p>
<p>According to Brooks, the essential difficulties are:</p>
<ol type="1">
<li><p><strong>Complexity</strong>: among the constructions that man can
build, software is one of the most challenging and most complex one. As
a matter of fact, even traditional engineering constructions, like
satellites, nuclear power plants, or rockets, are increasingly dependent
on software.</p></li>
<li><p><strong>Conformity</strong>: due to its nature, software has to
adapt to its environment, which changes all the time in our world. For
example, if a tax collection rule changes, all software in the related
domain needs to quickly adapted to it. Brooks notes that this does not
occur, for example, in Physics, as the laws of nature do not change
according to men‚Äôs decisions.</p></li>
<li><p><strong>Changeability</strong>: in the case of software, there is
a pressure for constant evolution, for example to incorporate new
features. In fact, the more successful a software system is, the more
demand for changes it receives.</p></li>
<li><p><strong>Invisibility</strong>: due to its abstract nature, it is
difficult to visualize the size and consequently estimate the effort
required to construct software systems.</p></li>
</ol>
<p>Difficulties (2), (3) and (4) are specific to software systems, that
is, they do not occur in other engineering products, at least not at the
same intensity. For example, when environmental legislation changes, car
manufacturers have years to comply with the new rules. Additionally,
cars are not changed, at least essentially, with new functionalities,
after being produced. Finally, a car is a physical product with weight,
height, width, seats, and a geometric shape, which facilitates its
valuation and pricing by final consumers.</p>
<p>On the other hand, software development also faces accidental
difficulties. However, they are associated with technological problems
that engineers can solve, if properly trained and assuming they have
access to the necessary technologies and resources. As an example, we
can mention the following accidental difficulties: a compiler that
produces obscure error messages, an IDE that has many bugs and
frequently crashes, a framework that lacks documentation or a Web
application with an unintuitive interface. However, these problems are
not an inherent characteristic of the mentioned systems. With time,
resources, and expertise, they can be adequately tackled.</p>
<p> </p>
<p><strong>Real World</strong>: To illustrate the complexity involved in
building software systems, we give some numbers about the size of these
systems, in lines of code. For example, the Linux operating system , in
its version 4.1.3, from 2017, has about 25 million lines of code and
contributions from almost 1,700 engineers (<a
href="https://www.linuxfoundation.org/2017-linux-kernel-report-landing-page">link</a>).
As a second example, Google‚Äôs systems, in total, have more than 2
billion lines of code, distributed across 9 million files, as in January
2015 (<a href="https://doi.org/10.1145/2854146">link</a>). At that time,
an average of about 40,000 code change requests (commits) were
performed, per day, by the company‚Äôs software engineers.</p>
<h2 data-number="1.2" id="what-is-studied-in-software-engineering"><span
class="header-section-number">1.2</span> What is Studied in Software
Engineering? <a href="#what-is-studied-in-software-engineering"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> To answer this question, we rely on the <em>Guide to the Software
Engineering Body of Knowledge</em>, also known by the acronym SWEBOK (<a
href="http://www.swebok.org">link</a>). This report is organized by the
IEEE Computer Society (an international scientific society) with the
support of various researchers and industry professionals. The purpose
of the report is to document the body of knowledge that characterizes
the area that we call Software Engineering today.</p>
<p>The SWEBOK defines twelve knowledge areas in Software
Engineering:</p>
<ol type="1">
<li><p>Requirements Engineering</p></li>
<li><p>Software Design</p></li>
<li><p>Software Construction</p></li>
<li><p>Software Testing</p></li>
<li><p>Software Maintenance</p></li>
<li><p>Configuration Management</p></li>
<li><p>Project Management</p></li>
<li><p>Software Processes</p></li>
<li><p>Software Models</p></li>
<li><p>Software Quality</p></li>
<li><p>Professional Practice</p></li>
<li><p>Software Economics</p></li>
</ol>
<p>In fact, the SWEBOK includes three other knowledge areas: Computing
Foundations, Mathematical Foundations, and Engineering Foundations.
However, as they are located in the frontier with other scientific
areas, they are not covered in this chapter.</p>
<p>In the rest of this section, we briefly comment on each of the areas
listed above. Our goal is to provide an overview of the knowledge
developed over the years in Software Engineering and, thus, inform the
reader about <em>what</em> is studied in this area.</p>
<h3 data-number="1.2.1" id="requirements-engineering"><span
class="header-section-number">1.2.1</span> Requirements Engineering <a
href="#requirements-engineering" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Requirements define <em>what</em> a system should do and <em>how</em>
it should operate. Thus, Requirements Engineering designates the
activities carried out to analyze, document, and validate a system‚Äôs
requirements. Requirements can be <strong>functional</strong> or
<strong>non-functional</strong>.</p>
<p> Functional requirements define <em>what</em> a system should do;
that is, which functionalities or services it should implement.
Non-functional requirements, on the other hand, define <em>how</em> a
system should operate, under which constraints, and with what quality of
service. Examples of non-functional requirements are performance,
availability, fault tolerance, security, privacy, interoperability,
capacity, maintainability, and usability.</p>
<p>For example, consider a banking application. In this case, the
functional requirements include providing account balance, showing the
statement, transferring values between accounts, canceling a debit card,
among others. Non-functional requirements, for example, include:</p>
<ul>
<li><p>Performance: it must provide account balance in under two
seconds.</p></li>
<li><p>Availability: it must be online 99% of the time.</p></li>
<li><p>Fault tolerance: it must continue operating even if a certain
data center fails.</p></li>
<li><p>Security: it must encrypt all data exchanged with
branches.</p></li>
<li><p>Privacy: customer data should not be leaked to third
parties.</p></li>
<li><p>Interoperability: it must integrate with systems of the Central
Bank.</p></li>
<li><p>Capacity: it should be able to store and handle data for one
million banking customers.</p></li>
<li><p>Usability: it must have a version for visually impaired
people.</p></li>
</ul>
<h3 data-number="1.2.2" id="software-design"><span
class="header-section-number">1.2.2</span> Software Design <a
href="#software-design" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> During design, the main code units of a software system are defined,
but only at the level of interfaces, including <strong>provided
interfaces</strong> and <strong>required interfaces</strong>. Provided
interfaces are those services that a code unit makes public for use by
the rest of the system. Required interfaces are those interfaces upon
which a code unit depends to operate.</p>
<p>Therefore, during the design of a software system, we do not get into
implementation details of each code unit, such as method implementation
details, in case the system is implemented in an object-oriented
language. For example, during the design of a banking system, we can
define a class to represent bank accounts, like the following one:</p>
<pre><code>class BankAccount {
   private Customer customer;
   private double balance;
   public double getBalance() { ... }
   public String getCustomerName() { ... }
   public String getStatement (Date start) { ... }
   ...
}</code></pre>
<p>First, it is important to note that the implementation above is quite
simple, as our goal is only to explain the difference between software
design and implementation. Thus, it is important to mention that
<code>BankAccount</code> offers an interface to the other system
classes, in the form of its public methods, which constitute the
interface provided by the class. But <code>BankAccount</code> also
depends on another class, <code>Customer</code>; thus, the
<code>Customer</code> interface is a required interface for
<code>BankAccount</code>. Often, required interfaces are called
dependencies. That is, <code>BankAccount</code> has a dependency on
<code>Customer</code>.</p>
<p> When the design is performed at a higher level and the code units
have a coarser granularity‚Äîthey are packages or folders, for example‚Äîit
is classified as an architectural design. In other words,
<strong>software architecture</strong> deals with the organization of a
system at a level of abstraction higher than th e one involving classes
or similar constructs.</p>
<h3 data-number="1.2.3" id="software-construction"><span
class="header-section-number">1.2.3</span> Software Construction <a
href="#software-construction" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Construction deals with implementation, that is, coding the system.
At this point, there are many decisions that need to be made, such as
defining the algorithms and data structures to be used, defining the
third-party frameworks and libraries to be used; defining techniques for
exception handling; defining standards for names, layout, and code
documentation and, last but not least, defining the tools to be used in
development, including compilers, integrated development environments
(IDEs), debuggers, database managers, and tools for building
interfaces.</p>
<h3 data-number="1.2.4" id="software-testing"><span
class="header-section-number">1.2.4</span> Software Testing <a
href="#software-testing" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Testing involves executing a program with a finite set of cases and
verifying whether it produces the expected behavior. This quote from
Edsger W. Dijkstra‚Äîwho also won the Turing Award in Computing
(1982)‚Äîsummarizes the benefits of testing, but also its limitations:</p>
<blockquote>
<p><q>Software testing can show the presence of bugs, but not their
absence.</q></p>
</blockquote>
<p>We think that least three points should be discussed about testing in
this first chapter of our book. First, there are many types of tests.
For example, <strong>unit tests</strong> (when we test a small unit of
code, such as a class), <strong>integration tests</strong> (when we test
a larger unit, such as a set of classes), <strong>performance
tests</strong> (when we submit the system to a given load to check its
performance), and <strong>usability tests</strong> (when we aim to check
the usability of the system‚Äôs user interface).</p>
<p>Second, tests can be used both for verification and for validation.
Verification aims to ensure that a system complies with its
specification. With validation, the objective is to ensure that the
system meets the customers needs. The difference between the concepts
only exists because a system‚Äôs specification might not attend the needs
of its customers. This mismatch can be caused by an error in the
requirements specification phase. For example, developers might have not
understood the requirements or the client might have not explained them
precisely.</p>
<p>Two sentences are often used to synthesize the differences between
verification and validation:</p>
<ul>
<li><p><strong>Verification</strong>: are we implementing the system
correctly? That is, in accordance with its requirements.</p></li>
<li><p><strong>Validation</strong>: are we implementing the correct
system? That is, the one the customers or the market demands.</p></li>
</ul>
<p>Thus, when we run a method to check whether it returns the specified
results, we are performing a verification activity. On the other hand,
when we perform a acceptance meeting with clients, presenting them the
system results and features, we are conducting a validation
activity.</p>
<p> Third, it is also important to define and distinguish three terms
related to tests: <strong>defects</strong>, <strong>bugs</strong>, and
<strong>failures</strong>. To illustrate the difference between them,
consider the following code that calculates the area of a circle,
depending on a certain condition:</p>
<pre><code> if (condition)
    area = pi * radius * radius * radius; </code></pre>
<p>This code has a defect because the area of a circle is <q>pi times
radius squared</q>, not cubed. Bug is a more informal term, used with
different purposes. But the most common one is as a synonym for defect.
Finally, a failure occurs when a defective code is executed ‚Äî for
example, when the <code>if</code> condition above evaluates to true ‚Äî
and, as a result, causes the program to show an incorrect result.
Therefore, not every defect or bug leads to failures, since the
defective code may never be executed.</p>
<p>In summary: defective (or a buggy) code is a code that does not
comply with its specification. If this code is executed and actually
causes the program to produce an incorrect output, we say that a failure
has occurred.</p>
<p><strong>In-Depth:</strong> In the literature on testing, the terms
<strong>error</strong> and <strong>fault</strong> are sometimes
mentioned. When this happens, the meaning is the same as we adopt for
<em>defect</em> before. For example, the <em>IEEE Standard Glossary of
Software Engineering Terminology</em> (<a
href="https://doi.org/10.1109/IEEESTD.1990.101064">link</a>) defines a
fault as an <q>incorrect step, process, or data definition in a computer
program; the terms error and bug are [also] used to express this
meaning</q>. In summary, <em>defect</em>, <em>error</em>, <em>fault</em>
and <em>bug</em> are usually synonyms.</p>
<p></p>
<p><strong>Real World</strong>: There is a long list of software
failures with serious consequences both in financial terms and in terms
of human lives. One of the most famous examples is the explosion of the
French rocket Ariane 5, when launched in 1996, from Kourou in French
Guiana. About 30 seconds after launch, the rocket exploded due to an
unexpected behavior of one of the onboard systems, causing a financial
loss of about half a billion dollars. Interestingly, the defect that
caused the failure in Ariane 5‚Äôs onboard system was very specific,
relatively simple, and limited to a few lines of code, implemented in
the ADA programming language, which is widely used in the development of
military and space software. The buggy lines were responsible for
converting a 64-bit floating-point value to a 16-bit integer. During the
tests and, probably, during previous rocket launches, the conversion was
always successful: the real number always <q>fit</q> into an integer.
However, on the date of the explosion, a condition that was never tested
before required the conversion of a real larger than the largest integer
that fits in 16 bits. Hence, a spurious result was generated, causing
the rocket‚Äôs control system to function erratically and leading to the
explosion.</p>
<h3 data-number="1.2.5" id="software-maintenance-and-evolution"><span
class="header-section-number">1.2.5</span> Software Maintenance and
Evolution <a href="#software-maintenance-and-evolution"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>Just like traditional engineering systems, software also needs
maintenance. In this book, we will use the following classification for
the types of maintenance that can be carried out on software systems:
<strong>corrective</strong>, <strong>preventive</strong>,
<strong>adaptive</strong>, <strong>refactoring</strong>, and
<strong>evolutionary</strong>.</p>
<p> Corrective maintenance aims to correct bugs reported by users or
other developers.</p>
<p> On the other hand, preventive maintenance aims to correct latent
bugs in the code that have not yet caused failures visible to the
system‚Äôs users.</p>
<p></p>
<p><strong>Real World</strong>: The maintenance activities carried out
by several companies before the turn of the last millennium, from 1999
to 2000, are an example of preventive maintenance. At that time, many
software applications were using two digits to store the year of a date,
that is, dates were in the DD-MM-AA format. Thus, the companies were
afraid that in 2000 and subsequent years some operations with dates
would return incorrect values. For example, a subtraction 00 - 99 could
result to an unexpected result. For this reason, companies set up
special task groups to carry out maintenance on their systems and
convert all date values to the DD-MM-YYYY format. As these activities
were carried out before the turn of the millennium, they are an example
of preventive maintenance.</p>
<p> Adaptive maintenance aims to adapt a system to a change in its
environment, including technology, legislation, rules for integration
with other systems or requests from new customers. As examples of
adaptive maintenance, we can mention:</p>
<ul>
<li><p>The migration of a system from Python 2.7 to Python 3.0.</p></li>
<li><p>The customization of a system to meet the requirements of a new
client ‚Äî that is, before deploying a system in new a client it is common
to make changes to accommodate for specifics of their business.</p></li>
<li><p>The adaptation of a system to comply with changes in legislation
or other contextual changes.</p></li>
</ul>
<p>Refactorings are changes made to code that preserve its external
behavior but improve its design and maintainability. Examples of
refactoring operations include renaming a method or variable (to a more
intuitive and easy-to-remember name), breaking a large method into
smaller methods (to facilitate understanding) or moving a method to a
more appropriate class.</p>
<p> Evolutionary Maintenance is performed to include new features in a
system or to introduce significant improvements in existing features.
Software Systems can be used for decades exactly because they undergo
evolutionary maintenance, which preserve their value to the customers.
For example, many banking systems were created in the 70s and 80s in
programming languages such as COBOL. However, they have undergone
various changes and improvements, including the implementation of
several new features.</p>
<p> <strong>Legacy Systems</strong> are old systems, based on languages,
operating systems, and databases that are technologically outdated. For
this reason, the maintenance of these systems is more costly and risky.
However, it is important to note that legacy does not mean irrelevant,
because often these systems perform critical operations for their
customers.</p>
<p><strong>In-Depth:</strong> In the literature, there are alternative
classifications for software maintenance types. One of them, proposed by
Lientz &amp; Swanson, in 1978 (<a
href="https://dl.acm.org/citation.cfm?id=601062">link</a>), classifies
maintenance into the following categories: (1) Corrective, exactly as we
defined before; (2) Perfective, refers to the addition of new
functionalities; in this book, we decided to call it evolutionary
maintenance; (3) Adaptive, refers to changes in the operational
environment of the software, such as supporting a new hardware or
operating system; therefore, it does not include, for example,
customizations demanded by new clients, as proposed in this book; (4)
Preventive, refers to changes aimed at increasing a system‚Äôs
maintainability; in this book, we opted for the more common term today,
which is refactoring.</p>
<h3 data-number="1.2.6" id="configuration-management"><span
class="header-section-number">1.2.6</span> Configuration Management <a
href="#configuration-management" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Currently, it is inconceivable to develop software without a version
control system, such as git. These systems store all the versions of
software, covering not just the source code, but also documentation,
manuals, web pages, and reports. They also allow you to restore a
particular version. For example, if you change the code and this changes
results in a critical bug, you can easily return to the previous
version, prior to the bug‚Äôs introduction.</p>
<p> However, configuration management is more than just using a system
like git. It includes defining a set of policies for managing the
versions of a system. For example, a development team can decide that
the releases of a library they are implementing will be identified in
the format <em>x</em>.<em>y</em>.<em>z</em>, where <em>x</em>,
<em>y</em> and <em>z</em> are integers. An increment in <em>z</em>
occurs when a new release is launched with only bug fixes (commonly
called a <em>patch</em>); an increment in <em>y</em> occurs when a
release with small features is launched (commonly called a
<em>minor</em> version); and finally, an increment in <em>x</em> occurs
when a release with relevant new features is launched (commonly, called
a <em>major</em> version). This scheme for identifying releases is known
as <strong>semantic versioning</strong>.</p>
<h3 data-number="1.2.7" id="project-management"><span
class="header-section-number">1.2.7</span> Project Management <a
href="#project-management" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> Software development requires the use of project management
practices and activities such as negotiating contracts with clients (for
defining deadlines, prices, schedules, etc.), human resource management
(including hiring, training, defining promotion policies, and
remuneration values), risk management, monitoring competition,
marketing, finance, among others. In a project, the term
<strong>stakeholder</strong> designates all parties that have interest
in it. That is, the stakeholders are those who affect or are affected by
the project, whether they are individuals or organizations. For example,
common stakeholders in software projects include its developers and its
users, but also, project managers, subcontracted companies, suppliers of
any nature, possibly some level of government, among others.</p>
<p> There is a well-known quote, also by Frederick Brooks, that captures
a peculiarity of software projects. According to Brooks:</p>
<blockquote>
<p><q>Adding manpower to a late software project makes it later.</q></p>
</blockquote>
<p> This comment became so famous that it is known as <strong>Brooks‚Äô
Law</strong>. Basically, this effect happens because the new developers
need first to understand and comprehend the entire system, its
architecture and design, before they start to produce useful code. In
addition, larger teams increase the communication and coordination
efforts to make and explain decisions. For example, if a team has three
developers (d<sub>1</sub>, d<sub>2</sub>, d<sub>3</sub>), there are
three possible communication channels (d<sub>1</sub>-d<sub>2</sub>,
d<sub>1</sub>-d<sub>3</sub> and d<sub>2</sub>-d<sub>3</sub>); if it
grows to four developers, the number of channels doubles to six
channels. If the team grows to 10 developers, there are 45 communication
channels. For this reason, modern software is typically developed in
small teams, with about a dozen engineers, if that.</p>
<p><strong>In-Depth Look:</strong> Brooks‚Äô Law was proposed in a classic
book on software project management called <em>The Mythical
Man-Month</em>, whose first edition was published in 1975 (<a
href="https://dl.acm.org/citation.cfm?id=207583">link</a>). In the book,
Brooks reports the lessons he learned early in his career as a manager
responsible for IBM‚Äôs first operating systems. In 1995, a second edition
of the book was released to commemorate its 20th anniversary. This
edition included a new chapter with the article <em>No Silver Bullet ‚Äî
Essence and Accidents of Software Engineering</em>, originally published
in 1987 (and which we have already commented in this chapter). In 1999,
Frederick Brooks won the Turing Award, considered the Nobel Prize of
Computer Science.</p>
<h3 data-number="1.2.8" id="software-development-processes"><span
class="header-section-number">1.2.8</span> Software Development
Processes <a href="#software-development-processes" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> A development process defines what activities and stages should be
followed to build and deliver a software system. An analogy can be made,
for example, with the construction of buildings, which takes place
according to certain stages: foundation, masonry, roofing, plumbing
installations, electrical installations, finishing, painting, etc.</p>
<p>Historically, there are two main types of processes that can be
adopted in the construction of software systems:</p>
<ul>
<li><p><strong>Waterfall processes</strong></p></li>
<li><p><strong>Agile processes</strong> (or incremental or
iterative).</p></li>
</ul>
<p> Waterfall processes were the first to be proposed, way back in the
‚Äô70s, when Software Engineering was beginning to gain prominence.
Understandably, they were inspired by the processes used in traditional
engineering, which are largely sequential, as illustrated in the
building example, used in the opening paragraph of this section.
Waterfall processes were widely used until the 1990s and much of that
success is due to a standardization issued by the US Department of
Defense in 1985. Basically, they stipulated that all software purchased
or contracted by the Department of Defense had to be built using
Waterfall.</p>
<p>Waterfall processes ‚Äî also called <strong>plan-driven
processes</strong> ‚Äî propose that the construction of a system should be
done in sequential stages, like a waterfall, in which the water flows
from one level to another. These stages are: requirement gathering,
analysis (or high-level design), detailed design, coding, and testing.
After this pipeline is complete, the system is released for production,
that is, for effective use by its users, as illustrated in the next
figure.</p>
<figure>
<img src="./figs/cap1/waterfall-en.svg" style="width:87.0%"
alt="Phases of a Waterfall process." />
<figcaption aria-hidden="true">Phases of a Waterfall
process.</figcaption>
</figure>
<p> However, from the late ‚Äô90s, Waterfall processes were heavily
criticized due to the repeated delays and issues with software projects,
which were occurring frequently at that time. The main issue is that
Waterfall presupposes a complete requirement gathering phase, followed
by a detailed design phase, followed by a complete implementation phase,
etc. To only then validate the system with the users, which may happen
years after the beginning of the project. By then, the world may have
changed, as well as the needs of the customers, who may no longer need
the system they helped specify years before. So, gathered in a city in
Utah, United States, in February 2001, a group of 17 Software Engineers
proposed an alternative way to construct software, which they called
Agile ‚Äî the name of the manifesto they produced at that meeting (<a
href="https://agilemanifesto.org/">link</a>). In contrast to Waterfall
processes, the idea of Agile processes is that a system should be built
incrementally and iteratively. Small increments of functionality are
produced, at intervals of about one month, and immediately validated by
the users. Once the produced increment is approved, the cycle
repeats.</p>
<p>Agile processes have had a profound impact on the software industry.
Today, they are used by a wide variety of organizations that produce
software, from small companies to large Internet companies. Various
methods that operationalize Agile principles have been proposed, such as
<strong>XP</strong>, <strong>Scrum</strong>, <strong>Kanban</strong> and
<strong>Lean Development</strong>.</p>
<p>These methods have also helped spread various software development
practices, such as <strong>automated testing</strong>,
<strong>test-driven development</strong> (i.e., writing the tests first,
before the actual code), and <strong>continuous integration</strong>.
Continuous integration recommends that developers integrate the code
that they produce immediately if possible, every day. The goal is to
avoid developers working locally, on their machine, without integrating
the code they are producing into the main project repository for a long
time. When the development team is larger, this increases the chances of
integration conflicts, which occur when two developers alter the same
code in parallel. The first developer to integrate their code will be
successful; while the second developer will be informed that the section
has already been modified by the first developer.</p>
</div>
</div>
</div>

<footer>
All rights reserved. Version for personal use only.
To report any errors, including minor typos, use this form.
</footer>
</body>
</html>
