{
"title": "Cap. 5 - Princípios de Projeto",  
"questions": [
  {
    "text": "Uma maneira de atingir integridade conceitual é por meio de um projeto dirigido por comitês.",
    "correct": "false"
  },
  {
    "text": "A implementação de uma classe deve encapsular estruturas de dados e algoritmos que são sujeitos a mudanças.",
    "correct": "true"
  },
  {
    "text": "Desenvolvimento em paralelo, isto é, a possibilidade de desenvolver ao mesmo tempo diversas classes de um sistema, é uma das vantagens de ocultamento de informação.",
    "correct": "true"
  },
  {
    "text": "Getters e setters são essenciais para implementação de classes com ocultamento de informação.",
    "correct": "false"
  },
  {
    "text": "Coesão e separação de interesses são conceitos antagônicos.",
    "correct": "false"
  },
  {
    "text": "Acoplamento estrutural ocorre quando uma classe A referencia em sua implementação uma classe B. Por exemplo, a classe A declara um atributo ou parâmetro do tipo B ou cria um objeto do tipo B.",
    "correct": "true"
  },
  {
    "text": "Todo acoplamento estrutural é também um acoplamento evolutivo.",
    "correct": "false"
  },
  {
    "text": "Segregação de Variáveis e Responsabilidade Única são princípios úteis para obter classes coesas.",
    "correct": "false"
  },
  {
    "text": "O Princípio de Substituição de Liskov aplica-se somente a linguagens com herança.",
    "correct": "true"
  },
  {
    "text": "Um nome mais intuitivo para Inversão de Dependências é Prefira Composição a Herança, como Java e C++.",
    "correct": "false"
  },
  {
    "text": "Herança de classes envolve reúso de código, pois subclasses não precisam reimplementar os métodos herdados da classe pai.",
    "correct": "true"
  },
  {
    "text": "Composição é um mecanismo de reúso caixa-branca, pois a classe cliente tem acesso a diversos detalhes de implementação da classe servidora.",
    "correct": "false"
  },
  {
    "text": "Uma chamada obj.getX.getY().getZ().metodo() representa uma violação do Princípio de Demeter.",
    "correct": "true"
  },
  {
    "text": "De acordo com o Princípio Aberto/Fechado, uma classe deve ser aberta para modificações, mas fechada para extensões.",
    "correct": "false"
  },
  {
    "text": "Existe uma relação de composição entre duas classes A e B quando a classe A possui um atributo do tipo B.",
    "correct": "true"
  },
  {
    "text": "O Princípio de Liskov recomenda que não devemos usar objetos apenas como intermediários para chegar até um objeto de interesse.",
    "correct": "false"
  },
  {
    "text": "Coesão vale para qualquer unidade de código, seja ela um método, uma classe ou um pacote.",
    "correct": "true"
  },
  {
    "text": "Em um módulo, uma interface simples é mais importante do que uma implementação simples.",
    "correct": "true"
  }, 
  {
    "text": "Suponha uma classe X com grupos de métodos M1, M2 e M3, os quais são usados pelos sistemas contábil, financeiro e de compras de uma empresa. Isso é um indicativo de que X viola o Princípio Aberto/Fechado.",
    "correct": "false"
  },
  {
    "text": "'Não fale com estranhos' é uma frase que resume o Princípio de Demeter.",
    "correct": "true"
  },
  {
    "text": "Se uma classe tem mais de um método, ela viola o Princípio da Responsabilidade Única.",
    "correct": "false"
  }  
]
}	    