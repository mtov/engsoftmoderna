{
"title": "Cap. 5 - Princípios de Projeto",  
"questions": [
  {
    "text": "Uma maneira de atingir integridade conceitual é por meio de um projeto dirigido por comitês.",
    "correct": "false"
  },
  {
    "text": "A implementação de uma classe deve encapsular estruturas de dados e algoritmos que são sujeitos a mudanças.",
    "correct": "true"
  },
  {
    "text": "Desenvolvimento em paralelo, isto é, a possibilidade de desenvolver ao mesmo tempo diversas classes de um sistema, é uma das vantagens de ocultamento de informação.",
    "correct": "true"
  },
  {
    "text": "Getters e setters são essenciais para implementação de classes com ocultamento de informação.",
    "correct": "false"
  },
  {
    "text": "Coesão e separação de interesses são conceitos antagônicos.",
    "correct": "false"
  },
  {
    "text": "Acoplamento estrutural ocorre quando uma classe A referencia em sua implementação uma classe B. Por exemplo, a classe A declara um atributo ou parâmetro do tipo B ou cria um objeto do tipo B.",
    "correct": "true"
  },
  {
    "text": "Todo acoplamento estrutural é também um acoplamento evolutivo.",
    "correct": "false"
  },
  {
    "text": "Segregação de Variáveis e Responsabilidade Única são princípios úteis para obter classes coesas.",
    "correct": "false"
  },
  {
    "text": "O Princípio de Substituição de Liskov aplica-se somente a linguagens com herança.",
    "correct": "true"
  },
  {
    "text": "Um nome mais intuitivo para Inversão de Dependências é Prefira Composição a Herança, como Java e C++.",
    "correct": "false"
  },
  {
    "text": "Herança de classes envolve reúso de código, pois subclasses não precisam reimplementar os métodos herdados da classe pai.",
    "correct": "true"
  },
  {
    "text": "Composição é um mecanismo de reúso caixa-branca, pois a classe cliente tem acesso a diversos detalhes de implementação da classe servidora.",
    "correct": "false"
  },
  {
    "text": "Uma chamada obj.getX.getY().getZ().metodo() representa uma violação do Princípio de Demeter.",
    "correct": "true"
  },
  {
    "text": "De acordo com o Princípio Aberto/Fechado, uma classe deve ser aberta para modificações, mas fechada para extensões.",
    "correct": "false"
  },
  {
    "text": "Existe uma relação de composição entre duas classes A e B quando a classe A possui um atributo do tipo B.",
    "correct": "true"
  },
  {
    "text": "O Princípio de Liskov recomenda que não devemos usar objetos apenas como intermediários para chegar até um objeto de interesse.",
    "correct": "false"
  },
  {
    "text": "Coesão vale para qualquer unidade de código, seja ela um método, uma classe ou um pacote.",
    "correct": "true"
  },
  {
    "text": "Em um módulo, uma interface simples é mais importante do que uma implementação simples.",
    "correct": "true"
  }, 
  {
    "text": "Suponha uma classe de domínio X com grupos de métodos M1, M2 e M3, os quais são usados, respectivamente, pelos sistemas contábil, financeiro e de compras de uma empresa. Esse fato é um indicativo de que X viola o Princípio da Responsabilidade Única.",
    "correct": "true"
  },
  {
    "text": "'Não fale com estranhos' é uma frase que resume o Princípio de Demeter.",
    "correct": "true"
  },
  {
    "text": "Se uma classe tem mais de um método, ela viola o Princípio da Responsabilidade Única.",
    "correct": "false"
  },
  {
    "text": "Classes grandes são mais propensas a ter problemas de coesão (baixa) e acoplamento (alto).",
    "correct": "true"
  },
  {
    "text": "Todos os atributos de uma classe X são privados. Logo, com certeza, X possibilita Ocultamento de Informação.",
    "correct": "false"
  },
  {
    "text": "Uma classe X possui três atributos privados. Logo, para prover Ocultamento de Informação, X deve obrigatoriamente implementar três getters (um para cada atributo).",
    "correct": "false"
  },
  {
    "text": "Uma classe X possui três atributos privados. Logo, para prover Ocultamento de Informação, X deve obrigatoriamente implementar três setters (um para cada atributo).",
    "correct": "false"
  },
  {
    "text": "Uma interface I é implementada, atualmente, por duas classes C1 e C2. Amanhã, novas classes podem também vir a implementar I. Logo, um cliente C deve depender de I e nunca das classes concretas que implementam essa interface (tais como C1 e C2).",
    "correct": "true"
  }
]
}	    