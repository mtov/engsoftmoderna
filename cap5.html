<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 5: Princ√≠pios de Projeto ‚Äì Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-8249107-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-8249107-3', {'anonymize_ip': true});
  </script>

  <script>
  var trackOutboundLink = function(url, action, category) {
      gtag('event', action, {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': function(){document.location = url;}
      });
  }
  </script>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-8 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">
<img src="https://engsoftmoderna.info/figs/capa/capa-3d.jpg"></a>
</p>

<p>
<a href="https://engsoftmoderna.info">P√°gina principal do livro</a>
</p>

<p>Compre na

<a href="https://www.amazon.com.br/gp/product/6500019504">Amazon</a>, 

<a href="https://www.submarino.com.br/produto/1768283036/engenharia-de-software-moderna">
      Submarino</a> ou 

<a href="https://produto.mercadolivre.com.br/MLB-1552071489-engenharia-de-software-moderna-_JM">
      Mercado Livre</a>.
</p>

<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<section id="princ√≠pios-de-projeto" data-number="1">
<h1 data-number="5"><span class="header-section-number">5</span>
Princ√≠pios de Projeto <a href="#princ√≠pios-de-projeto"
class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>The most fundamental problem in computer science is problem
decomposition: how to take a complex problem and divide it up into
pieces that can be solved independently.</em> ‚Äì John Ousterhout</p>
</blockquote>
<p> </p>
<p>Este cap√≠tulo inicia com uma introdu√ß√£o ao projeto de software, na
qual procuramos definir e motivar a import√¢ncia desse tipo de atividade
(Se√ß√£o 5.1). Em seguida, discutimos diversas considera√ß√µes relevantes em
projetos de software. Especificamente, tratamos de Integridade
Conceitual (Se√ß√£o 5.2), Ocultamento de Informa√ß√£o (Se√ß√£o 5.3), Coes√£o
(Se√ß√£o 5.4) e Acoplamento (Se√ß√£o 5.5). Na Se√ß√£o 5.6 discutimos um
conjunto de princ√≠pios de projeto, incluindo: Responsabilidade √önica,
Segrega√ß√£o de Interfaces, Invers√£o de Depend√™ncias, Prefira Composi√ß√£o a
Heran√ßa, Demeter, Aberto/Fechado e Substitui√ß√£o de Liskov. Por fim,
tratamos de m√©tricas para avaliar a qualidade de projetos de software
(Se√ß√£o 5.7).</p>
<section id="introdu√ß√£o" data-number="1.1">
<h2 data-number="5.1"><span class="header-section-number">5.1</span>
Introdu√ß√£o <a href="#introdu√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> A afirma√ß√£o de John Ousterhout que abre este cap√≠tulo √© uma
excelente defini√ß√£o para <strong>projeto de software</strong>. Apesar de
n√£o afirmar explicitamente, a cita√ß√£o assume que quando falamos de
projeto estamos procurando uma solu√ß√£o para um determinado problema. No
contexto de Engenharia de Software, esse problema consiste na
implementa√ß√£o de um sistema que atenda aos requisitos funcionais e
n√£o-funcionais definidos por um cliente ‚Äî ou Dono do Produto, para usar
um termo mais moderno. Prosseguindo, Ousterhout sugere como devemos
proceder para chegar a essa solu√ß√£o: devemos decompor, isto √©, quebrar o
problema inicial, que pode ser bastante complexo, em partes menores. Por
fim, a frase imp√µe uma restri√ß√£o a essa decomposi√ß√£o: ela deve permitir
que cada uma das partes do projeto possa ser resolvida (ou implementada)
de forma independente.</p>
<p>Essa explica√ß√£o pode passar a impress√£o de que projeto √© uma
atividade simples. No entanto, no projeto de software temos que combater
um grande inimigo: a <strong>complexidade</strong> que caracteriza
sistemas modernos de software. Talvez, por isso, Ousterhout mencione que
a decomposi√ß√£o de um problema em partes independentes √© uma quest√£o
fundamental, n√£o apenas em Engenharia de Software, mas em toda Ci√™ncia
da Computa√ß√£o!</p>
<p> Uma estrat√©gia importante para combater a complexidade de sistemas
de software passa pela cria√ß√£o de <strong>abstra√ß√µes</strong>. Uma
abstra√ß√£o ‚Äî pelo menos em Computa√ß√£o ‚Äî √© uma representa√ß√£o simplificada
de uma entidade. Apesar de simplificada, ela nos permite interagir e
tirar proveito da entidade abstra√≠da, sem que tenhamos que dominar todos
os detalhes envolvidos na sua implementa√ß√£o. Dentre outros, fun√ß√µes,
classes, interfaces, pacotes e bibliotecas s√£o os instrumentos cl√°ssicos
oferecidos por linguagens de programa√ß√£o para cria√ß√£o de abstra√ß√µes.</p>
<p>Em resumo, o primeiro objetivo de projeto de software √© decompor um
problema em partes menores. Al√©m disso, deve ser poss√≠vel implementar
tais partes de forma independente. Por fim, mas n√£o menos importante,
essas partes devem ser abstratas. Em outras palavras, a implementa√ß√£o
delas pode ser desafiadora e complexa, mas apenas para os
desenvolvedores envolvidos em tal tarefa. Para os demais
desenvolvedores, deve ser simples usar a abstra√ß√£o que foi criada.</p>
<section id="exemplo" data-number="1.1.1">
<h3 data-number="5.1.1"><span class="header-section-number">5.1.1</span>
Exemplo <a href="#exemplo" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Para ilustrar essa introdu√ß√£o a projetos de software, vamos usar o
exemplo de um compilador. Os requisitos no caso s√£o claros: dado um
programa em uma linguagem X devemos convert√™-lo em um programa em uma
linguagem Y, que costuma ser a linguagem de uma m√°quina. No entanto, o
projeto de um compilador n√£o √© trivial. Ent√£o, ap√≥s anos de pesquisa,
descobriu-se uma solu√ß√£o ‚Äî ou projeto ‚Äî para esse tipo de sistema, a
qual √© ilustrada na figura da pr√≥xima p√°gina.</p>
<figure>
<img src="figs/cap5/compiler-design.svg" style="width:100.0%"
alt="Principais m√≥dulos de um compilador" />
<figcaption aria-hidden="true">Principais m√≥dulos de um
compilador</figcaption>
</figure>
<p>O problema inicial ‚Äî projetar um compilador ‚Äî foi decomposto em
quatro problemas menores, que vamos descrever brevemente neste
par√°grafo. Primeiro, temos que implementar um analisador l√©xico, que vai
ler o arquivo de entrada e dividi-lo em tokens (como <code>if</code>,
<code>for</code>, <code>while</code>, <code>x</code>, <code>+</code>,
etc.).</p>
<p>Depois, temos que implementar um analisador sint√°tico, que vai
analisar as tokens e verificar se elas respeitam a gram√°tica da
linguagem fonte. Feito isso, ele deve <q>hierarquizar</q> essas tokens,
isto √©, transform√°-las em uma estrutura conhecida como √Årvore de Sintaxe
Abstrata (AST). Por fim, temos o analisador sem√¢ntico, que detecta, por
exemplo, erros de tipo; e o gerador de c√≥digo, que vai converter a
representa√ß√£o do programa para uma linguagem de mais baixo n√≠vel, que
possa ser executada por um determinado hardware.</p>
<p>Essa descri√ß√£o do projeto de um compilador √© bastante simples e
resumida. Mesmo assim, ela deixa claro o primeiro objetivo do projeto de
um software: decompor um problema em partes menores. No nosso exemplo, o
problema inicial tornou-se mais concreto, pois agora temos quatro
problemas menores para resolver. Isto √©, temos que (1) projetar e
implementar um analisador l√©xico, (2) um analisador sint√°tico, (3) um
analisador sem√¢ntico e (4) um gerador de c√≥digo. Ainda existem desafios
importantes em cada uma dessas tarefas, mas estamos mais perto de uma
solu√ß√£o para o problema inicial.</p>
<p>Continuando com o exemplo, vamos agora focar na implementa√ß√£o de um
analisador l√©xico, a qual envolve certos desafios. No entanto, eles
devem ser uma preocupa√ß√£o apenas dos desenvolvedores que ficaram
respons√°veis por essa parte do sistema. Para os demais desenvolvedores,
deve ser poss√≠vel usar o analisador l√©xico da forma mais simples
poss√≠vel. Por exemplo, apenas chamando uma fun√ß√£o que retorna a pr√≥xima
token do arquivo de entrada, como no seguinte c√≥digo:</p>
<p><code>String token = Scanner.next_token();</code></p>
<p>Portanto, a complexidade envolvida na implementa√ß√£o de um analisador
l√©xico est√° abstra√≠da (ou, se preferir, encapsulada) na fun√ß√£o
<code>next_token()</code>, cujo uso √© bem simples.</p>
</section>
<section id="o-que-vamos-estudar" data-number="1.1.2">
<h3 data-number="5.1.2"><span class="header-section-number">5.1.2</span>
O Que Vamos Estudar? <a href="#o-que-vamos-estudar" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>√â verdade que o projeto de sistemas de software depende de
experi√™ncia e, em alguma medida, tamb√©m de talento e criatividade. No
entanto, existem algumas propriedades importantes no projeto de
sistemas. Por isso, estudar e conhecer essas <strong>propriedades de
projeto</strong> pode ajudar na concep√ß√£o de sistemas com maior
qualidade. No restante deste cap√≠tulo, iremos estudar as seguintes
propriedades de projetos de software: integridade conceitual,
ocultamento de informa√ß√£o, coes√£o e acoplamento. Para tornar o estudo
mais pr√°tico, iremos, em seguida, enunciar alguns <strong>princ√≠pios de
projeto</strong>, os quais representam diretrizes para se garantir que
um projeto atende a determinadas propriedades. Para concluir, vamos
descrever m√©tricas para quantificar propriedades como coes√£o,
acoplamento e complexidade.</p>
<p></p>
<p><strong>Aviso:</strong> Os assuntos discutidos neste cap√≠tulo
aplicam-se a <strong>projeto orientado a objetos</strong>. Ou seja, a
suposi√ß√£o √© que o sistema ser√° implementado em linguagens como Java,
C++, C#, Python, Go, Ruby, etc. Certamente, alguns dos temas discutidos
valem para projetos que ser√£o implementados em linguagens estruturadas
(como C) ou em linguagens funcionais (como Haskell, Clojure ou Erlang).
Mas n√£o podemos garantir que oferecemos uma cobertura completa dos
aspectos de projeto mais importantes em tais casos.</p>
</section>
</section>
<section id="integridade-conceitual" data-number="1.2">
<h2 data-number="5.2"><span class="header-section-number">5.2</span>
Integridade Conceitual <a href="#integridade-conceitual"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> Integridade conceitual √© uma propriedade de projeto proposta por
Frederick Brooks ‚Äî o mesmo da Lei de Brooks mencionada no Cap√≠tulo 1. O
princ√≠pio foi enunciado em 1975, na primeira edi√ß√£o do livro <em>The
Mythical Man-Month</em> (<a
href="https://dl.acm.org/citation.cfm?id=540031">link</a>). Brooks
defende que um sistema n√£o pode ser um amontoado de funcionalidades, sem
coer√™ncia e coes√£o entre elas. Integridade conceitual √© importante
porque facilita o uso e entendimento de um sistema por parte de seus
usu√°rios. Por exemplo, com integridade conceitual, o usu√°rio acostumado
a usar uma parte de um sistema se sente confort√°vel a usar uma outra
parte, pois as funcionalidades e a interface implementadas ao longo do
produto s√£o sempre consistentes.</p>
<p>Para citar um contra-exemplo, isto √©, um caso de aus√™ncia de
integridade conceitual, vamos assumir um sistema que usa tabelas para
apresentar seus resultados. Dependendo da tela do sistema na qual s√£o
usadas, essas tabelas possuem leiautes diferentes, em termos de tamanho
de fontes, uso de negrito, espa√ßamento entre linhas, etc. Al√©m disso, em
algumas tabelas pode-se ordenar os dados clicando-se no t√≠tulo das
colunas, mas em outras tabelas essa funcionalidade n√£o est√° dispon√≠vel.
Por fim, os valores s√£o mostrados em moedas distintas. Em algumas
tabelas, os valores referem-se a reais; em outras tabelas, eles
referem-se a d√≥lares. Essa falta de padroniza√ß√£o √© um sinal de falta de
integridade conceitual e, como afirmamos, ela adiciona complexidade
acidental no uso e entendimento do sistema.</p>
<p> Na primeira edi√ß√£o do seu livro, Brooks faz uma defesa enf√°tica do
princ√≠pio, afirmando que:</p>
<blockquote>
<p><q>Integridade conceitual √© a considera√ß√£o mais importante no projeto
de sistemas. √â melhor um sistema omitir algumas funcionalidades e
melhorias an√¥malas, de forma a oferecer um conjunto coerente de ideias,
do que oferecer diversas ideias interessantes, mas independentes e
descoordenadas.</q></p>
</blockquote>
<p>Em 1995, em uma edi√ß√£o comemorativa dos 20 anos do lan√ßamento do
livro (<a href="https://dl.acm.org/citation.cfm?id=207583">link</a>),
Brooks voltou a defender o princ√≠pio, ainda com mais √™nfase:</p>
<blockquote>
<p><q>Hoje, eu estou mais convencido do que antes. Integridade
conceitual √© fundamental para qualidade de produtos de software.</q></p>
</blockquote>
<p>Sempre que falamos de integridade conceitual, surge uma discuss√£o
sobre se o princ√≠pio requer que uma autoridade central ‚Äî um √∫nico
arquiteto ou gerente de produto, por exemplo ‚Äî seja respons√°vel por
decidir quais funcionalidades ser√£o inclu√≠das no sistema. Sobre essa
quest√£o, temos que ressaltar que essa pr√©-condi√ß√£o ‚Äî o projeto ser
liderado por uma pessoa apenas ‚Äî n√£o faz parte da defini√ß√£o de
integridade conceitual. No entanto, existe um certo consenso de que
decis√µes importantes de projeto n√£o devem ficar nas m√£os de um grande
comit√™, no qual cada membro tem direito a um voto. Quando isso ocorre, a
tend√™ncia √© a produ√ß√£o de sistemas com mais funcionalidades do que o
necess√°rio, isto √©, sistemas sobrecarregados (<em>bloated systems</em>).
Por exemplo, um grupo pode defender uma funcionalidade A e outro grupo
defender uma funcionalidade B. Talvez, as duas n√£o sejam necess√°rias;
por√©m, para obter consenso, o comit√™ acaba decidindo que ambas devem ser
implementadas. Assim, os dois grupos v√£o ficar satisfeitos, embora a
integridade conceitual do sistema ficar√° comprometida. Existe uma frase
que resume o que acabamos de discutir; ela afirma que <q>um camelo √© um
cavalo projetado por um comit√™</q>.</p>
<p>Nos par√°grafos anteriores, enfatizamos o impacto da falta de
integridade conceitual nos usu√°rios finais de um sistema. No entanto, o
princ√≠pio se aplica tamb√©m ao design e c√≥digo de um sistema. Nesse caso,
os afetados s√£o os desenvolvedores, que ter√£o mais dificuldade para
entender, manter e evoluir o sistema. A seguir, mencionamos exemplos de
falta de integridade conceitual em n√≠vel de c√≥digo:</p>
<ul>
<li><p>Quando uma parte do sistema usa um padr√£o de nomes para vari√°veis
(por exemplo, <em>camel case</em>, como em <code>notaTotal</code>),
enquanto em outra parte usa-se um outro padr√£o (por exemplo, <em>snake
case</em>, como em <code>nota_total</code>).</p></li>
<li><p>Quando uma parte do sistema usa um determinado framework para
manipula√ß√£o de p√°ginas Web, enquanto em outra parte usa-se um segundo
framework ou ent√£o uma vers√£o diferente do primeiro framework.</p></li>
<li><p>Quando em uma parte do sistema resolve-se um problema usando-se
uma estrutura de dados X, enquanto que, em outra parte, um problema
parecido √© resolvido por meio de uma estrutura Y.</p></li>
<li><p>Quando fun√ß√µes de uma parte do sistema que precisam de uma
determinada informa√ß√£o ‚Äî por exemplo, o endere√ßo de um servidor ‚Äî a
obt√©m diretamente de um arquivo de configura√ß√£o. Por√©m, em outras
fun√ß√µes, de outras partes do sistema, a mesma informa√ß√£o deve ser
passada como par√¢metro.</p></li>
</ul>
<p>Esses exemplos revelam uma falta de padroniza√ß√£o e, logo, de
integridade conceitual. Eles s√£o um problema porque tornam mais dif√≠cil
um desenvolvedor acostumado a manter uma parte do sistema ser alocado
para manter uma outra parte.</p>
<p><strong>Mundo Real</strong>: Samuel Roso e Daniel Jackson,
pesquisadores do MIT, nos EUA, d√£o um exemplo real de sistema que
implementa duas funcionalidades com prop√≥sitos semelhantes ‚Äî o que
tamb√©m revela uma falta de integridade conceitual (<a
href="https://doi.org/10.1145/2509578.2509584">link</a>). Segundo eles,
em um conhecido sistema de blogs, quando um usu√°rio inclu√≠a um sinal de
interroga√ß√£o no t√≠tulo de um post, uma janela era aberta, solicitando
que ele informasse se desejava receber respostas para esse post. No
entanto, os pesquisadores argumentam que essa possibilidade deixava os
usu√°rios confusos, pois j√° existia no sistema a possibilidade de
comentar posts. Logo, a confus√£o acontecia devido a duas funcionalidades
parecidas: coment√°rios (em posts normais) e respostas (em posts cujos
t√≠tulos terminavam com um ponto de interroga√ß√£o).</p>
</section>
<section id="ocultamento-de-informa√ß√£o" data-number="1.3">
<h2 data-number="5.3"><span class="header-section-number">5.3</span>
Ocultamento de Informa√ß√£o <a href="#ocultamento-de-informa√ß√£o"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> Essa propriedade, uma tradu√ß√£o da express√£o <em>information
hiding</em>, foi discutida pela primeira vez em 1972, por David Parnas,
em um dos artigos mais importantes e influentes da √°rea de Engenharia de
Software, de todos os tempos, cujo t√≠tulo √© <em>On the criteria to be
used in decomposing systems into modules</em> (<a
href="https://dl.acm.org/citation.cfm?id=361623">link</a>). O resumo do
artigo come√ßa da seguinte forma:</p>
<blockquote>
<p><q>Este artigo discute modulariza√ß√£o como sendo um mecanismo capaz de
tornar sistemas de software mais flex√≠veis e f√°ceis de entender e, ao
mesmo tempo, reduzir o tempo de desenvolvimento deles. A efetividade de
uma determinada modulariza√ß√£o depende do crit√©rio usado para dividir um
sistema em m√≥dulos.</q></p>
</blockquote>
<p> <strong>Aviso</strong>: Parnas usa o termo <em>m√≥dulo</em> no seu
artigo, mas isso em uma √©poca em que orienta√ß√£o a objetos ainda n√£o
havia surgido, pelo menos como conhecemos hoje. J√° neste cap√≠tulo,
escrito quase 50 anos ap√≥s o trabalho de Parnas, optamos pelo termo
<strong>classe</strong>, em vez de m√≥dulo. O motivo √© que classes s√£o a
principal unidade de modulariza√ß√£o de linguagens de programa√ß√£o
modernas, como Java, C++ e Ruby. No entanto, o conte√∫do do cap√≠tulo
aplica-se a outras unidades de modulariza√ß√£o, incluindo aquelas menores
do que classes, como m√©todos e fun√ß√µes; e tamb√©m a unidades maiores,
como pacotes e componentes.</p>
<p>Ocultamento de informa√ß√£o traz as seguintes vantagens para um
sistema:</p>
<ul>
<li><p><strong>Desenvolvimento em paralelo.</strong> Suponha que um
sistema X foi implementado por meio de classes C<sub>1</sub>,
C<sub>2</sub>, ‚Ä¶, C<sub>n</sub>. Quando essas classes ocultam suas
principais informa√ß√µes, fica mais f√°cil implement√°-las em paralelo, por
desenvolvedores diferentes. Consequentemente, teremos uma redu√ß√£o no
tempo total de implementa√ß√£o do sistema.</p></li>
<li><p><strong>Flexibilidade a mudan√ßas.</strong> Por exemplo, suponha
que descobrimos que a classe C<sub>i</sub> √© respons√°vel pelos problemas
de desempenho do sistema. Quando detalhes de implementa√ß√£o de
C<sub>i</sub> s√£o ocultados do resto do sistema, fica mais f√°cil trocar
sua implementa√ß√£o por uma classe C<sub>i</sub>', que use estruturas de
dados e algoritmos mais eficientes. Essa troca tamb√©m √© mais segura,
pois como as classes s√£o independentes, diminui-se o risco de a mudan√ßa
introduzir bugs em outras classes.</p></li>
<li><p><strong>Facilidade de entendimento.</strong> Por exemplo, um novo
desenvolvedor contratado pela empresa pode ser alocado para trabalhar em
algumas classes apenas. Portanto, ele n√£o precisar√° entender toda a
complexidade do sistema, mas apenas a implementa√ß√£o das classes pelas
quais ficou respons√°vel.</p></li>
</ul>
<p>No entanto, para se atingir os benef√≠cios acima, classes devem
satisfazer √† seguinte condi√ß√£o (ou crit√©rio): elas devem esconder
decis√µes de projeto que s√£o sujeitas a mudan√ßas. Devemos entender
decis√£o de projeto como qualquer aspecto de projeto da classe, como os
requisitos que ela implementa ou os algoritmos e estruturas de dados que
ser√£o usados no seu c√≥digo. Portanto, ocultamento de informa√ß√£o
recomenda que classes devem esconder detalhes de implementa√ß√£o que est√£o
sujeitos a mudan√ßas. Modernamente, os atributos e m√©todos que uma classe
pretende encapsular s√£o declarados com o modificador de visibilidade
<strong>privado</strong>, dispon√≠vel em linguagens como Java, C++, C# e
Ruby.</p>
<p>Por√©m, se uma classe encapsular toda a sua implementa√ß√£o ela n√£o ser√°
√∫til. Dito de outra forma, uma classe para ser √∫til deve tornar alguns
de seus m√©todos p√∫blicos, isto √©, permitir que eles possam ser chamados
por c√≥digo externo. C√≥digo externo que chama m√©todos de uma classe √©
dito ser <strong>cliente</strong> da classe. Dizemos tamb√©m que o
conjunto de m√©todos p√∫blicos de uma classe define a sua
<strong>interface</strong>. A defini√ß√£o da interface de uma classe √©
muito importante, pois ela constitui a sua parte vis√≠vel.</p>
<p>Interfaces devem ser est√°veis, pois mudan√ßas na interface de uma
classe podem demandar atualiza√ß√µes em seus clientes. Para ser mais
claro, suponha uma classe <code>Math</code>, com m√©todos que realizam
opera√ß√µes matem√°ticas. Suponha um m√©todo <code>sqrt</code>, que calcula
a raiz quadrada de seu par√¢metro. Suponha ainda que a assinatura desse
m√©todo seja alterada ‚Äî para, por exemplo, retornar uma exce√ß√£o caso o
valor do par√¢metro seja negativo. Essa altera√ß√£o ter√° impacto em todo
c√≥digo cliente do m√©todo <code>sqrt</code>, que dever√° ser alterado para
tratar a nova exce√ß√£o.</p>
<section id="exemplo-1" data-number="1.3.1">
<h3 data-number="5.3.1"><span class="header-section-number">5.3.1</span>
Exemplo <a href="#exemplo-1" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Suponha um sistema para controle de estacionamentos. Suponha ainda
que, em uma primeira vers√£o, a classe principal desse sistema seja a
seguinte:</p>
<pre><code>import java.util.Hashtable;

public class Estacionamento {

  public Hashtable&lt;String, String&gt; veiculos;

  public Estacionamento() {
    veiculos = new Hashtable&lt;String, String&gt;();
  }

  public static void main(String[] args) {
    Estacionamento e = new Estacionamento();
    e.veiculos.put(&quot;TCP-7030&quot;, &quot;Uno&quot;);
    e.veiculos.put(&quot;BNF-4501&quot;, &quot;Gol&quot;);
    e.veiculos.put(&quot;JKL-3481&quot;, &quot;Corsa&quot;);
  }
}</code></pre>
<p>Essa classe tem um problema de exposi√ß√£o excessiva de informa√ß√£o ou,
em outras palavras, ela n√£o oculta estruturas que podem mudar no futuro.
Especificamente, a tabela hash que armazena os ve√≠culos estacionados no
estacionamento √© p√∫blica. Com isso, clientes ‚Äî como o m√©todo
<code>main</code> ‚Äî t√™m acesso direto a ela para, por exemplo, adicionar
ve√≠culos no estacionamento. Se, futuramente, decidirmos usar uma outra
estrutura de dados para armazenar os ve√≠culos, todos os clientes dever√£o
ser modificados.</p>
<p>Suponha que o sistema de estacionamento fosse manual, com o nome dos
ve√≠culos anotados em uma folha de papel. Fazendo uma compara√ß√£o, essa
primeira vers√£o da classe <code>Estacionamento</code> corresponderia ‚Äî
no caso desse sistema manual ‚Äî ao cliente do estacionamento, ap√≥s
estacionar seu carro, entrar na cabine de controle e escrever ele mesmo
a placa e o modelo do seu carro na folha de controle.</p>
<p>J√° a pr√≥xima vers√£o da classe √© melhor, pois ela encapsula a
estrutura de dados respons√°vel por armazenar os ve√≠culos. Para
estacionar um ve√≠culo, existe agora o m√©todo <code>estaciona</code>. Com
isso, os desenvolvedores da classe t√™m liberdade para trocar de
estrutura de dados, sem causar impacto nos seus clientes. A √∫nica
restri√ß√£o √© que a assinatura de <code>estaciona</code> deve ser
preservada.</p>
<pre><code>import java.util.Hashtable;

public class Estacionamento {

  private Hashtable&lt;String,String&gt; veiculos;

  public Estacionamento() {
    veiculos = new Hashtable&lt;String, String&gt;();
  }

  public void estaciona(String placa, String veiculo) {
    veiculos.put(placa, veiculo);
  }

  public static void main(String[] args) {
    Estacionamento e = new Estacionamento();
    e.estaciona(&quot;TCP-7030&quot;, &quot;Uno&quot;);
    e.estaciona(&quot;BNF-4501&quot;, &quot;Gol&quot;);
    e.estaciona(&quot;JKL-3481&quot;, &quot;Corsa&quot;);
  }
}</code></pre>
<p>Em resumo, essa nova vers√£o oculta uma estrutura de dados ‚Äî sujeita a
altera√ß√µes durante a evolu√ß√£o do sistema ‚Äî e disponibiliza uma interface
est√°vel para os clientes da classe ‚Äî representada pelo m√©todo
<code>estaciona</code>.</p>
<p> </p>
<p><strong>Mundo Real</strong>: Em 2002, consta que Jeff Bezos, dono da
Amazon, enviou um mail para todos os desenvolvedores da empresa, com um
conjunto de diretrizes para projeto de software que eles deveriam
obrigatoriamente seguir a partir de ent√£o. Reproduzimos a mensagem na
lista a seguir (apenas fizemos adapta√ß√µes cosm√©ticas para ela ficar mais
clara em portugu√™s; essa mesma mensagem √© mencionada no livro de Fox e
Patterson (<a href="http://www.saasbook.info/">link</a>, Cap. 1, Se√ß√£o
1.4):</p>
<ol type="1">
<li><p>Todos os times devem, daqui em diante, garantir que os sistemas
exponham seus dados e funcionalidades por meio de interfaces.</p></li>
<li><p>Os sistemas devem se comunicar apenas por meio de
interfaces.</p></li>
<li><p>N√£o deve haver outra forma de comunica√ß√£o: sem links diretos, sem
leitura direta em bases de dados de outros sistemas, sem mem√≥ria
compartilhada ou vari√°veis globais ou qualquer tipo de
<em>backdoor</em>. A √∫nica forma de comunica√ß√£o permitida √© por meio de
interfaces.</p></li>
<li><p>N√£o importa qual tecnologia voc√™s v√£o usar: HTTP, CORBA, PubSub,
protocolos espec√≠ficos ‚Äî isso n√£o interessa. Bezos n√£o liga para
isso.</p></li>
<li><p>Todas as interfaces, sem exce√ß√£o, devem ser projetadas para uso
externo. Ou seja, os times devem planejar e projetar interfaces pensando
em usu√°rios externos. Sem nenhuma exce√ß√£o √† regra.</p></li>
<li><p>Quem n√£o seguir essas recomenda√ß√µes est√° demitido.</p></li>
<li><p>Obrigado; tenham um excelente dia!</p></li>
</ol>
</section>
<section id="getters-e-setters" data-number="1.3.2">
<h3 data-number="5.3.2"><span class="header-section-number">5.3.2</span>
Getters e Setters <a href="#getters-e-setters" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>M√©todos <code>get</code> e <code>set</code> ‚Äî muitas vezes chamados
apenas de <em>getters</em> e <em>setters</em> ‚Äî s√£o muito usados em
linguagens orientadas a objetos, como Java e C++. A recomenda√ß√£o para
uso desses m√©todos √© a seguinte: todos os dados de uma classe devem ser
privados e o acesso a eles ‚Äî se necess√°rio ‚Äî deve ocorrer por meio de
getters (acesso de leitura) e setters (acesso de escrita).</p>
<p>Veja um exemplo a seguir, no qual m√©todos <code>get</code> e
<code>set</code> s√£o usados para acessar o atributo
<code>matricula</code> de uma classe <code>Aluno</code>.</p>
<pre><code>class Aluno {

  private int matricula;
  ...
  public int getMatricula() {
    return matricula;
  }

  public setMatricula(int matricula) {
    this.matricula = matricula;  
  }
  ...
}</code></pre>
<p> No entanto, getters e setters n√£o s√£o uma garantia de que estamos
ocultando dados da classe, como mencionado em alguns livros e discuss√µes
pela Internet. Pelo contr√°rio, eles s√£o um instrumento de libera√ß√£o de
informa√ß√£o (<em>information leakage</em>). Veja o que John Ousterhout
diz sobre esses m√©todos (<a
href="https://dl.acm.org/citation.cfm?id=3288797">link</a>, Se√ß√£o
19.6):</p>
<blockquote>
<p><q>Embora possa fazer sentido usar getters e setters para expor dados
privados de uma classe, √© melhor evitar essa exposi√ß√£o logo de in√≠cio.
Ela torna parte da implementa√ß√£o da classe vis√≠vel externamente, o que
viola a ideia de ocultamento de informa√ß√£o e aumenta a complexidade da
interface da classe.</q></p>
</blockquote>
<p>Em resumo: certifique-se de que √© imprescind√≠vel liberar informa√ß√£o
privativa de uma classe. Se isso for, de fato, importante, considere a
ideia de implementar essa libera√ß√£o por meio de getters e setters ‚Äî e
n√£o tornando o atributo p√∫blico.</p>
<p>No nosso exemplo, vamos ent√£o assumir que √© imprescind√≠vel que os
clientes possam ler e alterar a matr√≠cula de alunos. Assim, √© melhor que
o acesso a esse atributo seja feito por meio de m√©todos <code>get</code>
e <code>set</code>, pois eles constituem uma interface mais est√°vel para
tal acesso, pelos seguintes motivos:</p>
<ul>
<li><p>No futuro, podemos precisar de recuperar a matr√≠cula de um banco
de dados, ou seja, ela n√£o estar√° mais em mem√≥ria. Essa nova l√≥gica
poder√°, ent√£o, ser implementada no m√©todo <code>get</code>, sem impactar
nenhum cliente da classe.</p></li>
<li><p>No futuro, podemos precisar de adicionar um d√≠gito verificador
nas matr√≠culas. Essa l√≥gica ‚Äî c√°lculo e incorpora√ß√£o do d√≠gito
verificador ‚Äî poder√° ser implementada no m√©todo set, sem impactar os
seus clientes.</p></li>
</ul>
<p>Al√©m disso, getters e setters s√£o requeridos por algumas bibliotecas,
tais como bibliotecas de depura√ß√£o, serializa√ß√£o e mocks (iremos estudar
mais sobre mocks no cap√≠tulo de Testes).</p>
</section>
</section>
<section id="coes√£o" data-number="1.4">
<h2 data-number="5.4"><span class="header-section-number">5.4</span>
Coes√£o <a href="#coes√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p>A implementa√ß√£o de qualquer classe deve ser coesa, isto √©, toda
classe deve implementar uma √∫nica funcionalidade ou servi√ßo.
Especificamente, todos os m√©todos e atributos de uma classe devem estar
voltados para a implementa√ß√£o do mesmo servi√ßo. Uma outra forma de
explicar coes√£o √© afirmando que toda classe deve ter uma √∫nica
responsabilidade no sistema. Ou, ainda, afirmando que deve existir um
√∫nico motivo para modificar uma classe.</p>
<p>Coes√£o tem as seguintes vantagens:</p>
<ul>
<li><p>Facilita a implementa√ß√£o de uma classe, bem como o seu
entendimento e manuten√ß√£o.</p></li>
<li><p>Facilita a aloca√ß√£o de um √∫nico respons√°vel por manter uma
classe.</p></li>
<li><p>Facilita o re√∫so e teste de uma classe, pois √© mais simples
reusar e testar uma classe coesa do que uma classe com v√°rias
responsabilidades.</p></li>
</ul>
<p> <strong>Separa√ß√£o de interesses</strong> (<em>separation of
concerns</em>) √© uma outra propriedade desej√°vel em projetos de
software, a qual √© semelhante ao conceito de coes√£o. Ela defende que uma
classe deve implementar apenas um <strong>interesse</strong>
(<em>concern</em>). Nesse contexto, o termo interesse se refere a
qualquer funcionalidade, requisito ou responsabilidade da classe.
Portanto, as seguintes recomenda√ß√µes s√£o equivalentes: (1) uma classe
deve ter uma √∫nica responsabilidade; (2) uma classe deve implementar um
√∫nico interesse; (3) uma classe deve ser coesa.</p>
<section id="exemplos" data-number="1.4.1">
<h3 data-number="5.4.1"><span class="header-section-number">5.4.1</span>
Exemplos <a href="#exemplos" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p><strong>Exemplo 1:</strong> A discuss√£o anterior foi voltada para
coes√£o de classes. No entanto, o conceito se adapta tamb√©m a m√©todos ou
fun√ß√µes. Por exemplo, suponha uma fun√ß√£o como a seguinte:</p>
<pre><code>float sin_or_cos(double x, int op) {
  if (op == 1)
    &quot;calcula e retorna seno de x&quot;
  else
    &quot;calcula e retorna cosseno de x&quot;
}</code></pre>
<p>Essa fun√ß√£o ‚Äî que consiste em um exemplo extremo e, queremos
acreditar, pouco comum na pr√°tica ‚Äî apresenta um problema s√©rio de
coes√£o, pois ela faz duas coisas: calcula o seno ou o cosseno de seu
argumento. O recomend√°vel seria criar fun√ß√µes separadas para cada uma
dessas tarefas.</p>
<p><strong>Exemplo 2:</strong> Suponha agora a seguinte classe:</p>
<pre><code>class Stack&lt;T&gt; {
  boolean empty() { ... }
  T pop() { ... }
  push (T) { ... }
  int size() { ... }
}</code></pre>
<p>Trata-se de uma classe coesa, pois todos os seus m√©todos implementam
opera√ß√µes importantes em uma estrutura de dados do tipo Pilha.</p>
<p><strong>Exemplo 3:</strong> Para concluir a lista de exemplos, vamos
voltar √† classe <code>Estacionamento</code>, na qual foram adicionados
agora quatro atributos com informa√ß√µes sobre o gerente do
estacionamento:</p>
<pre><code>class Estacionamento {
  ...
  private String nome_gerente;
  private String fone_gerente;
  private String cpf_gerente;
  private String endereco_gerente;
  ...
}  </code></pre>
<p>A principal responsabilidade dessa classe √© gerenciar a opera√ß√£o do
estacionamento, incluindo m√©todos como <code>estaciona()</code>,
<code>calcula_preco()</code>, <code>libera_veiculo()</code>, etc.
Portanto, ela n√£o deveria assumir responsabilidades relacionadas com o
gerenciamento dos funcion√°rios do estacionamento. Para isso, poderia ser
criada uma segunda classe, chamada, por exemplo,
<code>Funcionario</code>.</p>
</section>
</section>
<section id="acoplamento" data-number="1.5">
<h2 data-number="5.5"><span class="header-section-number">5.5</span>
Acoplamento <a href="#acoplamento" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p>Acoplamento √© a for√ßa (<em>strength</em>) da conex√£o entre duas
classes. Apesar de parecer simples, o conceito possui algumas nuances,
as quais derivam da exist√™ncia de dois tipos de acoplamento entre
classes: acoplamento aceit√°vel e acoplamento ruim.</p>
<p>Dizemos que existe um <strong>acoplamento aceit√°vel</strong> de uma
classe A para uma classe B quando:</p>
<ul>
<li><p>A classe A usa apenas m√©todos p√∫blicos da classe B.</p></li>
<li><p>A interface provida por B √© est√°vel do ponto de vista sint√°tico e
sem√¢ntico. Isto √©, as assinaturas dos m√©todos p√∫blicos de B n√£o mudam
com frequ√™ncia; e o mesmo acontece como o comportamento externo de tais
m√©todos. Por isso, s√£o raras as mudan√ßas em B que ter√£o impacto na
classe A.</p></li>
</ul>
<p> Por outro lado, existe um <strong>acoplamento ruim</strong> de uma
classe A para uma classe B quando mudan√ßas em B podem facilmente
impactar A. Isso ocorre principalmente nas seguintes situa√ß√µes:</p>
<ul>
<li><p>Quando a classe A realiza um acesso direto a um arquivo ou banco
de dados da classe B.</p></li>
<li><p>Quando as classes A e B compartilham uma vari√°vel ou estrutura de
dados global. Por exemplo, a classe B altera o valor de uma vari√°vel
global que a classe A usa no seu c√≥digo.</p></li>
<li><p>Quando a interface da classe B n√£o √© est√°vel. Por exemplo, os
m√©todos p√∫blicos de B s√£o renomeados com frequ√™ncia.</p></li>
</ul>
<p>Em ess√™ncia, o que caracteriza o acoplamento ruim √© o fato de que a
depend√™ncia entre as classes n√£o √© mediada por uma interface est√°vel.
Por exemplo, quando uma classe altera o valor de uma vari√°vel global,
ela n√£o tem consci√™ncia do impacto dessa mudan√ßa em outras partes do
sistema. Por outro lado, quando uma classe altera sua interface, ela
est√° ciente de que isso vai ter impacto nos clientes, pois a fun√ß√£o de
uma interface √© exatamente anunciar os servi√ßos que uma classe oferece
para o resto do sistema.</p>
<p>Resumindo: acoplamento pode ser de grande utilidade, principalmente
quando ocorre com a interface de uma classe est√°vel que presta um
servi√ßo relevante para a classe de origem. J√° o acoplamento ruim deve
ser evitado, pois √© um acoplamento n√£o mediado por interfaces. Mudan√ßas
na classe de destino do acoplamento podem facilmente se propagar para a
classe de origem.</p>
<p>Frequentemente, as recomenda√ß√µes sobre acoplamento e coes√£o s√£o
reunidas em uma √∫nica recomenda√ß√£o:</p>
<blockquote>
<p>Maximize a coes√£o das classes e minimize o acoplamento entre
elas.</p>
</blockquote>
<p>De fato, se uma classe depende de muitas outras classes, por exemplo,
de dezenas de classes, ela pode estar assumindo responsabilidades
demais, na forma de funcionalidades n√£o coesas. Lembre-se que uma classe
deve ter uma √∫nica responsabilidade (ou um √∫nico motivo para ser
modificada). Por outro lado, devemos tomar cuidado com o significado do
verbo minimizar. O objetivo n√£o deve ser eliminar completamente o
acoplamento de uma classe com outras classes, pois √© natural que uma
classe precise de outras classes, principalmente daquelas que
implementam servi√ßos b√°sicos, como estruturas de dados, entrada/sa√≠da,
etc.</p>
<section id="exemplos-1" data-number="1.5.1">
<h3 data-number="5.5.1"><span class="header-section-number">5.5.1</span>
Exemplos <a href="#exemplos-1" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p><strong>Exemplo 1:</strong> Suponha a classe
<code>Estacionamento</code>, usada na Se√ß√£o 5.3, a qual possui um
atributo que √© uma <code>Hashtable</code>. Logo, dizemos que
<code>Estacionamento</code> est√° acoplada a <code>Hashtable</code>. No
entanto, na nossa classifica√ß√£o, trata-se de um acoplamento aceit√°vel,
isto √©, ele n√£o deve ser motivo de preocupa√ß√£o, pelos seguintes
motivos:</p>
<ul>
<li><p><code>Estacionamento</code> s√≥ usa m√©todos p√∫blicos de
<code>Hashtable</code>.</p></li>
<li><p>A interface de <code>Hashtable</code> √© est√°vel, j√° que ela faz
parte do pacote oficial de estruturas de dados de Java (estamos supondo
que o sistema ser√° implementado nessa linguagem). Assim, uma altera√ß√£o
na assinatura dos m√©todos p√∫blicos de <code>Hashtable</code> quebraria
n√£o apenas nossa classe <code>Estacionamento</code>, mas talvez milh√µes
de outras classes de diversos sistemas Java ao redor do mundo.</p></li>
</ul>
<p><strong>Exemplo 2:</strong> Suponha o seguinte trecho de c√≥digo, no
qual existe um arquivo compartilhado por duas classes, <code>A</code> e
<code>B</code>, mantidas por desenvolvedores distintos. O m√©todo
<code>B.g()</code> grava um inteiro no arquivo, que √© lido por
<code>A.f()</code>. Essa forma de comunica√ß√£o origina um acoplamento
ruim entre as classes. Por exemplo, o desenvolvedor que implementa
<code>B</code> pode n√£o saber que o arquivo √© lido por <code>A</code>.
Assim, ele pode decidir mudar o formato do arquivo por conta pr√≥pria,
sem comunicar o desenvolvedor da classe <code>A</code>.</p>
<pre><code>class A {
  private void f() {
    int total; ...
    File arq = File.open(&quot;arq1.db&quot;);
    total = arq.readInt();
    ...
  }
}</code></pre>
<pre><code>class B {
  private void g() {
    int total;
    // computa valor de total
    File arq = File.open(&quot;arq1.db&quot;);
    arq.writeInt(total);
    ...
    arq.close();
  }
}</code></pre>
<p>Antes de avan√ßar, um pequeno coment√°rio: no exemplo, existe tamb√©m um
acoplamento entre <code>B</code> e <code>File</code>. Por√©m, ele √© um
acoplamento aceit√°vel, pois <code>B</code> realmente precisa persistir
seus dados. Ent√£o, para conseguir isso, nada melhor do que usar uma
classe da biblioteca de entrada e sa√≠da da linguagem.</p>
<p><strong>Exemplo 3:</strong> Uma solu√ß√£o melhor para o acoplamento
entre as classes <code>A</code> e <code>B</code> do exemplo anterior √©
mostrada no c√≥digo a seguir.</p>
<pre><code>class A {

  private void f(B b) {
    int total;
    total = b.getTotal();
    ...
  }
}</code></pre>
<pre><code>class B {

  int total;

  public int getTotal() {
    return total;
  }

  private void g() {
    // computa valor de total
    File arq = File.open(&quot;arq1&quot;);
    arq.writeInt(total);
    ...
  }
}</code></pre>
<p>Nessa nova vers√£o, a depend√™ncia entre <code>A</code> e
<code>B</code> √© tornada expl√≠cita. Agora, <code>B</code> possui um
m√©todo p√∫blico que retorna o valor <code>total</code>. E a classe
<code>A</code> possui uma depend√™ncia para a classe <code>B</code>, por
meio de um par√¢metro do m√©todo <code>f</code>. Esse par√¢metro √© usado
para requisitar explicitamente o valor de <code>total</code>,
chamando-se o m√©todo <code>getTotal()</code>. Como esse m√©todo foi
declarado p√∫blico em <code>B</code>, espera-se que o desenvolvedor dessa
classe se esforce para n√£o alterar a sua assinatura. Por isso, nessa
nova vers√£o, dizemos que, apesar de existir uma depend√™ncia de
<code>A</code> para <code>B</code>, o acoplamento criado por ela √©
aceit√°vel. Ou seja, n√£o √© um acoplamento que gera preocupa√ß√µes.</p>
<p>Ainda sobre o exemplo anterior, √© interessante mencionar que, na
primeira vers√£o, o c√≥digo de <code>A</code> n√£o declara nenhuma vari√°vel
ou atributo do tipo <code>B</code>. E, mesmo assim, temos um acoplamento
ruim entre as classes. Na segunda vers√£o, ocorre o contr√°rio, pois o
m√©todo <code>A.f()</code> declara um par√¢metro do tipo <code>B</code>.
Mesmo assim, o acoplamento entre as classes √© de melhor qualidade, pois
√© mais f√°cil estudar e manter o c√≥digo de <code>A</code> sem conhecer
detalhes de <code>B</code>.</p>
<p> Alguns autores usam ainda os termos acoplamento estrutural e
acoplamento evolutivo (ou l√≥gico), com o seguinte significado:</p>
<ul>
<li><p><strong>Acoplamento estrutural</strong> entre A e B ocorre quando
uma classe A possui uma refer√™ncia expl√≠cita em seu c√≥digo para uma
classe B. Por exemplo, o acoplamento entre <code>Estacionamento</code> e
<code>Hashtable</code> √© estrutural.</p></li>
<li><p><strong>Acoplamento evolutivo (ou l√≥gico)</strong> entre A e B
ocorre quando mudan√ßas na classe B tendem a se propagar para a classe A.
No exemplo mencionado, no qual a classe A depende de um inteiro
armazenado em um arquivo interno de B, n√£o existe acoplamento estrutural
entre A e B, pois A n√£o declara nenhuma vari√°vel do tipo B, mas existe
acoplamento evolutivo. Por exemplo, mudan√ßas no formato do arquivo
criado por B ter√£o impacto em A.</p></li>
</ul>
<p>Acoplamento estrutural pode ser aceit√°vel ou ruim, dependendo da
estabilidade da interface da classe de destino. Acoplamento evolutivo,
principalmente quando qualquer mudan√ßa em B se propaga para a classe de
origem A, representa um acoplamento ruim.</p>
<p> Kent Beck ‚Äî na √©poca em que trabalhou no Facebook ‚Äî criou um
gloss√°rio de termos relacionados com projeto de software. Nesse
gloss√°rio, acoplamento √© definido da seguinte forma (<a
href="https://engineering.fb.com/uncategorized/software-design-glossary/">link</a>):</p>
<blockquote>
<p><q>Dois elementos est√£o acoplados quando mudan√ßas em um elemento
demandam mudan√ßas em um outro elemento. Acoplamento pode dar origem a
uma rela√ß√£o bem sutil entre classes, como frequentemente observamos no
Facebook. Certos eventos que interrompem o funcionamento de uma parte do
sistema normalmente s√£o causados por pequenos bits de acoplamento que
n√£o s√£o esperados ‚Äî por exemplo, mudan√ßas na configura√ß√£o do sistema A
causam um time-out no sistema B, que causa uma sobrecarga no sistema
C.</q></p>
</blockquote>
<p>A defini√ß√£o de acoplamento proposta por Beck ‚Äî <q>quando mudan√ßas em
um elemento demandam mudan√ßas em um outro elemento</q> ‚Äî corresponde √†
defini√ß√£o de acoplamento evolutivo. Ou seja, parece que Beck n√£o se
preocupa com o acoplamento aceit√°vel (isto √©, estrutural e est√°vel)
entre duas classes; pois ele, de fato, n√£o deve ser motivo de
preocupa√ß√£o.</p>
<p>O coment√°rio tamb√©m deixa claro que acoplamento pode ser indireto.
Isto √©, mudan√ßas em A podem ser propagar para B, e ent√£o alcan√ßar C.
Nesse caso, C est√° acoplado a A, mas de forma indireta.</p>
<p> </p>
<p><strong>Mundo Real</strong>: Um exemplo de problema real causado por
acoplamento indireto ficou conhecido como <strong>epis√≥dio do
left-pad</strong>. Em 2016, uma disputa de direitos autorais motivou um
desenvolvedor a remover uma de suas bibliotecas do diret√≥rio npm, muito
usado para armazenar e distribuir bibliotecas node.js/JavaScript. A
biblioteca removida ‚Äî chamada leftPad ‚Äî tinha uma √∫nica fun√ß√£o
JavaScript, de nome leftPad, com apenas 11 linhas de c√≥digo. Ela
preenchia uma string com brancos √† esquerda. Por exemplo,
<code>leftPad('foo', 5)</code> iria retornar <code>'  foo'</code>, ou
seja, <code>'foo'</code> com dois brancos √† esquerda.</p>
<p>Milhares de sistemas Web dependiam dessa fun√ß√£o trivial, por√©m a
depend√™ncia ocorria de modo indireto. Os sistemas usavam o npm para
baixar dinamicamente o c√≥digo JavaScript de uma biblioteca B1, que por
sua vez dependia de uma biblioteca B2 cujo c√≥digo tamb√©m estava no npm
e, assim por diante, at√© alcan√ßar uma biblioteca Bn que dependia do
left-pad. Como resultado, todos os sistemas que dependiam do left-pad ‚Äî
de forma direta ou indireta ‚Äî ficaram fora do ar por algumas horas, at√©
que a biblioteca fosse inserida de novo no npm. Em resumo, os sistemas
foram afetados por um problema em uma biblioteca trivial; e eles n√£o
tinham a menor ideia de que estavam acoplados a ela.</p>
</section>
</section>
<section id="solid-e-outros-princ√≠pios-de-projeto" data-number="1.6">
<h2 data-number="5.6"><span class="header-section-number">5.6</span>
SOLID e Outros Princ√≠pios de Projeto <a
href="#solid-e-outros-princ√≠pios-de-projeto" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p>Princ√≠pios de projeto s√£o recomenda√ß√µes mais concretas que
desenvolvedores de software devem seguir para atender √†s propriedades de
projeto que estudamos na se√ß√£o anterior. Assim, propriedades de projeto
podem ser vistas como recomenda√ß√µes ainda gen√©ricas (ou t√°ticas),
enquanto que os princ√≠pios que estudaremos agora est√£o em um n√≠vel
operacional.</p>
<p>Nesta se√ß√£o, iremos estudar os sete princ√≠pios de projeto listados na
pr√≥xima tabela. A tabela mostra ainda as propriedades de projeto que s√£o
contempladas ao seguir cada um desses princ√≠pios.</p>
<table>
<thead>
<tr class="header">
<th><strong>Princ√≠pio de Projeto</strong></th>
<th><strong>Propriedade de Projeto</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Responsabilidade √önica</td>
<td>Coes√£o</td>
</tr>
<tr class="even">
<td>Segrega√ß√£o de Interfaces</td>
<td>Coes√£o</td>
</tr>
<tr class="odd">
<td>Invers√£o de Depend√™ncias</td>
<td>Acoplamento</td>
</tr>
<tr class="even">
<td>Prefira Composi√ß√£o a Heran√ßa</td>
<td>Acoplamento</td>
</tr>
<tr class="odd">
<td>Demeter</td>
<td>Ocultamento de Informa√ß√£o</td>
</tr>
<tr class="even">
<td>Aberto/Fechado</td>
<td>Extensibilidade</td>
</tr>
<tr class="odd">
<td>Substitui√ß√£o de Liskov</td>
<td>Extensibilidade</td>
</tr>
</tbody>
</table>
<p> Cinco dos princ√≠pios que vamos estudar s√£o conhecidos como
<strong>Princ√≠pios SOLID</strong>, que √© uma sigla cunhada por Robert
Martin e Michael Feathers (<a
href="https://dl.acm.org/citation.cfm?id=3175742">link</a>). Ela deriva
da letra inicial de cada princ√≠pio, em ingl√™s:</p>
<ul>
<li><strong>S</strong>ingle Responsibility Principle</li>
<li><strong>O</strong>pen Closed/Principle</li>
<li><strong>L</strong>iskov Substitution Principle</li>
<li><strong>I</strong>nterface Segregation Principle</li>
<li><strong>D</strong>ependency Inversion Principle</li>
</ul>
<p>Os princ√≠pios de projeto que vamos estudar t√™m um ponto em comum:
eles n√£o visam apenas <q>resolver</q> um problema, mas tamb√©m assegurar
que a solu√ß√£o encontrada possa ser mantida e evolu√≠da com sucesso, no
futuro. Os maiores problemas com projetos de software costumam ocorrer
ap√≥s a implementa√ß√£o, quando o sistema precisa ser mantido. Normalmente,
existe uma tend√™ncia de que essa manuten√ß√£o fique gradativamente mais
lenta, custosa e arriscada. Portanto, os princ√≠pios de projeto que
estudaremos tentam reduzir ou postergar essa cont√≠nua degrada√ß√£o da
qualidade interna de sistemas de software. Em resumo, o objetivo n√£o √©
apenas entregar um projeto capaz de resolver um problema, mas tamb√©m que
facilite manuten√ß√µes futuras. Lembre-se que a principal regra sobre
requisitos de software √© que eles mudam com frequ√™ncia. O mesmo acontece
com tecnologias de implementa√ß√£o, como bibliotecas e frameworks.</p>
<section id="princ√≠pio-da-responsabilidade-√∫nica" data-number="1.6.1">
<h3 data-number="5.6.1"><span class="header-section-number">5.6.1</span>
Princ√≠pio da Responsabilidade √önica <a
href="#princ√≠pio-da-responsabilidade-√∫nica" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Esse princ√≠pio √© uma aplica√ß√£o direta da ideia de coes√£o. Ele prop√µe
o seguinte: toda classe deve ter uma √∫nica responsabilidade. Mais ainda,
responsabilidade, no contexto do princ√≠pio, significa <q>motivo para
modificar uma classe</q>. Ou seja, deve existir um √∫nico motivo para
modificar qualquer classe em um sistema.</p>
<p>Um corol√°rio desse princ√≠pio recomenda separar
<strong>apresenta√ß√£o</strong> de <strong>regras de neg√≥cio</strong>.
Portanto, um sistema deve possuir classes de apresenta√ß√£o, que v√£o
tratar de aspectos de sua interface com os usu√°rios, formato das
mensagens, meio no qual as mensagens ser√£o exibidas, etc. E classes
respons√°veis por regras de neg√≥cio, isto √©, que v√£o realizar as
computa√ß√µes, processamento, an√°lises, etc. S√£o interesses e
responsabilidades diferentes. E que podem evoluir e sofrer modifica√ß√µes
por raz√µes distintas. Portanto, elas devem ser implementadas em classes
diferentes. Por esse motivo, n√£o √© surpresa que existam desenvolvedores
que tratam apenas de requisitos de <em>front-end</em> (isto √©, de
classes de apresenta√ß√£o) e desenvolvedores que tratam de requisitos de
<em>backend</em> (isto √©, de classes com regras de neg√≥cio).</p>
<p><strong>Exemplo:</strong> A pr√≥xima classe ilustra uma viola√ß√£o do
Princ√≠pio da Responsabilidade √önica. O m√©todo
<code>calculaIndiceDesistencia</code> da classe <code>Disciplina</code>
possui duas responsabilidades: calcular o √≠ndice de desist√™ncia de uma
disciplina e imprimi-lo no console do sistema.</p>
<pre><code>class Disciplina {

  void calculaIndiceDesistencia() {
    indice = &quot;calcula √≠ndice de desist√™ncia&quot;
    System.out.println(indice);
  }

}</code></pre>
<p>Uma solu√ß√£o consiste em dividir essas responsabilidades entre duas
classes: uma classe de interface com o usu√°rio (<code>Console</code>) e
uma classe de <q>regra de neg√≥cio</q> (<code>Disciplina</code>),
conforme mostrado no c√≥digo a seguir. Dentre outros benef√≠cios, essa
solu√ß√£o permite reusar a classe de neg√≥cio com outras classes de
interface, como classes de interface gr√°fica, interface web, interface
para celular, etc.</p>
<pre><code>class Console {

  void imprimeIndiceDesistencia(Disciplina disciplina) {
    double indice = disciplina.calculaIndiceDesistencia();
    System.out.println(indice);
  }

}

class Disciplina {

  double calculaIndiceDesistencia() {
    double indice = &quot;calcula √≠ndice de desist√™ncia&quot;
    return indice;
  }

}</code></pre>
</section>
<section id="princ√≠pio-da-segrega√ß√£o-de-interfaces" data-number="1.6.2">
<h3 data-number="5.6.2"><span class="header-section-number">5.6.2</span>
Princ√≠pio da Segrega√ß√£o de Interfaces <a
href="#princ√≠pio-da-segrega√ß√£o-de-interfaces" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Assim como o princ√≠pio anterior, esse princ√≠pio √© uma aplica√ß√£o da
ideia de coes√£o. Melhor dizendo, ele √© um caso particular de
Responsabilidade √önica com foco em interfaces. O princ√≠pio define que
interfaces t√™m que ser pequenas, coesas e, mais importante ainda,
espec√≠ficas para cada tipo de cliente. O objetivo √© evitar que clientes
dependam de interfaces com m√©todos que eles n√£o v√£o usar. Para evitar
isso, duas ou mais interfaces espec√≠ficas podem, por exemplo, substituir
uma interface de prop√≥sito geral.</p>
<p>Uma viola√ß√£o do princ√≠pio ocorre, por exemplo, quando uma interface
possui dois conjuntos de m√©todos M<sub>x</sub> e M<sub>y</sub>. O
primeiro conjunto √© usado por clientes C<sub>x</sub> (que ent√£o n√£o usam
os m√©todos M<sub>y</sub>). De forma inversa, os m√©todos M<sub>y</sub>
s√£o usados apenas por clientes C<sub>y</sub> (que n√£o usam os m√©todos
M<sub>x</sub>). Consequentemente, essa interface deveria ser quebrada em
duas interfaces menores e espec√≠ficas: uma interface contendo apenas os
m√©todos M<sub>x</sub> e a segunda interface contendo apenas os m√©todos
M<sub>y</sub>.</p>
<p><strong>Exemplo:</strong> Suponha uma interface
<code>Funcionario</code> com os seguintes m√©todos: (1) retornar sal√°rio,
(2) retornar contribui√ß√£o mensal para o FGTS (Fundo de Garantia por
Tempo de Servi√ßo) e (3) retornar SIAPE (isto √©, o <q>n√∫mero de
matr√≠cula</q> de todo funcion√°rio p√∫blico federal). Essa interface viola
o Princ√≠pio de Segrega√ß√£o de Interfaces, pois apenas funcion√°rios de
empresas privadas, contratados em regime de CLT, possuem uma conta no
FGTS. Por outro lado, apenas funcion√°rios p√∫blicos possuem uma matr√≠cula
no SIAPE.</p>
<pre><code>interface Funcionario {

  double getSalario();

  double getFGTS();// apenas funcion√°rios CLT

  int getSIAPE();// apenas funcion√°rios p√∫blicos

  ...
}</code></pre>
<p>Uma alternativa ‚Äî que atende ao Princ√≠pio de Segrega√ß√£o de Interfaces
‚Äî consiste em criar interfaces espec√≠ficas (<code>FuncionarioCLT</code>
e <code>FuncionarioPublico</code>) que estendem a interface gen√©rica
(<code>Funcionario</code>).</p>
<pre><code>interface Funcionario {
  double getSalario();
  ...
}

interface FuncionarioCLT extends Funcionario {
  double getFGTS();
  ...
}

interface FuncionarioPublico extends Funcionario {
  int getSIAPE();
  ...
}</code></pre>
</section>
<section id="princ√≠pio-de-invers√£o-de-depend√™ncias" data-number="1.6.3">
<h3 data-number="5.6.3"><span class="header-section-number">5.6.3</span>
Princ√≠pio de Invers√£o de Depend√™ncias <a
href="#princ√≠pio-de-invers√£o-de-depend√™ncias" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Esse princ√≠pio recomenda que uma classe cliente deve estabelecer
depend√™ncias prioritariamente com abstra√ß√µes e n√£o com implementa√ß√µes
concretas, pois abstra√ß√µes (isto √©, interfaces) s√£o mais est√°veis do que
implementa√ß√µes concretas (isto √©, classes). A ideia √© ent√£o trocar (ou
<q>inverter</q>) as depend√™ncias: em vez de depender de classes
concretas, clientes devem depender de interfaces. Portanto, um nome mais
intuitivo para o princ√≠pio seria <strong>Prefira Interfaces a
Classes</strong>.</p>
<p>Para detalhar a ideia do princ√≠pio, suponha que exista uma interface
I e uma classe C1 que a implementa. Se puder escolher, um cliente deve
se acoplar a I e n√£o a C1. O motivo √© que quando um cliente se acopla a
uma interface I ele fica imune a mudan√ßas na implementa√ß√£o dessa
interface. Por exemplo, em vez de C1, pode-se mudar a implementa√ß√£o para
C2, que isso n√£o ter√° impacto no cliente em quest√£o.</p>
<p><strong>Exemplo 1:</strong> O c√≥digo a seguir ilustra o cen√°rio que
acabamos de descrever. Nesse c√≥digo, o mesmo <code>Cliente</code> pode
<q>trabalhar</q> com objetos concretos das classes <code>C1</code> e
<code>C2</code>. Ele n√£o precisa conhecer a classe concreta que est√° por
tr√°s ‚Äî ou que implementa ‚Äî a interface <code>I</code> que ele referencia
em seu c√≥digo.</p>
<pre><code>interface I { ... }

class C1 implements I {
  ...
}
class C2 implements I {
  ...
}</code></pre>
<pre><code>class Cliente {

  I i;

  Cliente (I i) {
    this.i = i;
    ...
  } ...
}</code></pre>
<pre><code>class Main {

  void main () {
    C1 c1 = new C1();
    new Cliente(c1);
    ...
    C2 c2 = new C2();
    new Cliente(c2);
    ...
  }
}</code></pre>
<p><strong>Exemplo 2:</strong> Agora, mostramos um exemplo de c√≥digo que
segue o Princ√≠pio de Invers√£o de Depend√™ncias. Esse princ√≠pio justifica
a escolha de <code>Projetor</code> como tipo do par√¢metro do m√©todo
<code>g</code>. Amanh√£, o tipo da vari√°vel local <code>projetor</code>
no m√©todo <code>f</code> pode mudar para, por exemplo,
<code>ProjetorSamsung</code>. Se isso vier a acontecer, a implementa√ß√£o
de g permanecer√° v√°lida, pois ao usarmos um tipo interface estamos nos
preparando para receber par√¢metros de v√°rios tipos concretos que
implementam essa interface.</p>
<pre><code>void f() {
  ...
  ProjetorLG projetor = new ProjetorLG();
  ...
  g(projetor);
}</code></pre>
<pre><code>void g(Projetor projetor) {
  ...
}</code></pre>
<p><strong>Exemplo 3:</strong> Como um exemplo final, suponha um pacote
de estruturas de dados que oferece uma interface <code>List</code> e
algumas implementa√ß√µes concretas (classes) para ela, como
<code>ArrayList</code>, <code>LinkedList</code> e <code>Vector</code>.
Sempre que poss√≠vel, em c√≥digo cliente desse pacote, declare vari√°veis,
par√¢metros ou atributos usando o tipo <code>List</code>, pois assim voc√™
estar√° criando c√≥digo compat√≠vel com as diversas implementa√ß√µes
concretas dessa interface.</p>
</section>
<section id="prefira-composi√ß√£o-a-heran√ßa" data-number="1.6.4">
<h3 data-number="5.6.4"><span class="header-section-number">5.6.4</span>
Prefira Composi√ß√£o a Heran√ßa <a href="#prefira-composi√ß√£o-a-heran√ßa"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Antes de explicar o princ√≠pio, vamos esclarecer que existem dois
tipos de heran√ßa:</p>
<ul>
<li><p><strong>Heran√ßa de classes</strong> (exemplo: <code>class A
extends B</code>), que √© aquela que envolve re√∫so de c√≥digo. N√£o apenas
neste cap√≠tulo, mas em todo o livro, quando mencionarmos apenas o termo
heran√ßa estaremos nos referindo a heran√ßa de classes.</p></li>
<li><p><strong>Heran√ßa de interfaces</strong> (exemplo: <code>interface
I extends J</code>), que n√£o envolve re√∫so de c√≥digo. Essa forma de
heran√ßa √© mais simples e n√£o suscita preocupa√ß√µes. Quando precisarmos de
nos referir a ela, iremos usar o nome completo: heran√ßa de
interfaces.</p></li>
</ul>
<p>Voltando ao princ√≠pio, quando orienta√ß√£o a objetos se tornou comum,
na d√©cada de 80, houve um incentivo ao uso de heran√ßa. Acreditava-se que
o conceito seria talvez uma bala de prata capaz de resolver os problemas
de re√∫so de software. Argumentava-se que hierarquias de classes
profundas, com v√°rios n√≠veis, seriam um indicativo de um bom projeto, no
qual foi poss√≠vel atingir elevados √≠ndices de re√∫so. No entanto, com o
tempo, percebeu-se que heran√ßa n√£o era a tal <q>bala de prata</q>. Pelo
contr√°rio, heran√ßa tende a introduzir problemas na manuten√ß√£o e evolu√ß√£o
das classes de um sistema. Esses problemas t√™m sua origem no forte
acoplamento que existe entre subclasses e superclasses, conforme
descrito por Gamma e colegas no livro sobre padr√µes de projeto (<a
href="https://dl.acm.org/citation.cfm?id=186897">link</a>):</p>
<p></p>
<blockquote>
<p><q>Heran√ßa exp√µe para subclasses detalhes de implementa√ß√£o das
classes pai. Logo, frequentemente diz-se que heran√ßa viola o
encapsulamento das classes pai. A implementa√ß√£o das subclasses se torna
t√£o acoplada √† implementa√ß√£o da classe pai que qualquer mudan√ßa nessas
√∫ltimas pode for√ßar modifica√ß√µes nas subclasses.</q></p>
</blockquote>
<p> O princ√≠pio, por√©m, n√£o pro√≠be o uso de heran√ßa. Mas ele recomenda:
se existirem duas solu√ß√µes de projeto, uma baseada em heran√ßa e outra em
composi√ß√£o, a solu√ß√£o por meio de composi√ß√£o, normalmente, √© a melhor.
S√≥ para deixar claro, existe uma rela√ß√£o de <strong>composi√ß√£o</strong>
entre duas classes A e B quando a classe A possui um atributo do tipo
B.</p>
<p><strong>Exemplo:</strong> Suponha que temos que implementar uma
classe <code>Stack</code>. Existem pelo menos duas solu√ß√µes ‚Äî por meio
de heran√ßa ou por meio de composi√ß√£o ‚Äî conforme mostra o seguinte
c√≥digo:</p>
<p>Solu√ß√£o via Heran√ßa:</p>
<pre><code>class Stack extends ArrayList {
  ...
}</code></pre>
<p>Solu√ß√£o via Composi√ß√£o:</p>
<pre><code>class Stack {
  private ArrayList elementos;
  ...
}</code></pre>
<p>A solu√ß√£o por meio de heran√ßa n√£o √© recomendada por v√°rios motivos,
sendo que os principais s√£o os seguintes: (1) um <code>Stack</code>, em
termos conceituais, n√£o √© um <code>ArrayList</code>, mas sim uma
estrutura que pode usar um <code>ArrayList</code> na sua implementa√ß√£o
interna; (2) quando se for√ßa uma solu√ß√£o via heran√ßa, a class
<code>Stack</code> ir√° herdar m√©todos como <code>get</code> e
<code>set</code>, que n√£o fazem parte da especifica√ß√£o de pilhas.
Portanto, nesse caso, devemos preferir a solu√ß√£o baseada em
composi√ß√£o.</p>
<p>Uma segunda vantagem de composi√ß√£o √© que a rela√ß√£o entre as classes
n√£o √© est√°tica, como no caso de heran√ßa. No exemplo, se opt√°ssemos por
heran√ßa, a classe <code>Stack</code> estaria acoplada estaticamente a
<code>ArrayList</code>; e n√£o seria poss√≠vel mudar essa decis√£o em tempo
de execu√ß√£o. Por outro lado, quando se adota uma solu√ß√£o baseada em
composi√ß√£o, isso fica mais f√°cil, como mostra o exemplo a seguir:</p>
<pre><code>class Stack {

  private List elementos;

  Stack(List elementos) {
    this.elementos = elementos;
  }
  ...
}</code></pre>
<p>No exemplo, a estrutura de dados que armazena os elementos da pilha
passou a ser um par√¢metro do construtor da classe <code>Stack</code>.
Com isso, torna-se poss√≠vel instanciar objetos <code>Stack</code> com
estruturas de dados distintas. Por exemplo, um objeto no qual os
elementos da pilha s√£o armazenados em um <code>ArrayList</code> e outro
objeto no qual eles s√£o armazenado em um <code>Vector</code>. Como uma
observa√ß√£o final, veja que o tipo do atributo elementos de
<code>Stack</code> passou a ser um <code>List</code>; ou seja, fizemos
uso tamb√©m do Princ√≠pio de Invers√£o de Depend√™ncias (ou Prefira
Interfaces a Classes).</p>
<p>Antes de concluir, gostar√≠amos de mencionar tr√™s pontos suplementares
ao que discutimos sobre <q>Prefira Composi√ß√£o a Heran√ßa</q>:</p>
<ul>
<li><p>Heran√ßa √© classificada como um mecanismo de <strong>re√∫so
caixa-branca</strong>, pois as subclasses costumam ter acesso a detalhes
de implementa√ß√£o da classe base. Por outro lado, composi√ß√£o √© um
mecanismo de <strong>re√∫so caixa-preta</strong>.</p></li>
<li><p>Um padr√£o de projeto que ajuda a substituir uma solu√ß√£o baseada
em heran√ßa por uma solu√ß√£o baseada em composi√ß√£o √© o Padr√£o Decorador,
que vamos estudar no pr√≥ximo cap√≠tulo.</p></li>
<li><p>Por conta dos problemas discutidos nesta se√ß√£o, linguagens de
programa√ß√£o mais recentes ‚Äî como Go e Rust ‚Äî n√£o incluem suporte a
heran√ßa.</p></li>
</ul>
</section>
<section id="princ√≠pio-de-demeter" data-number="1.6.5">
<h3 data-number="5.6.5"><span class="header-section-number">5.6.5</span>
Princ√≠pio de Demeter <a href="#princ√≠pio-de-demeter" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>O nome desse princ√≠pio faz refer√™ncia a um grupo de pesquisa da
Northeastern University, em Boston, EUA. Esse grupo, chamado Demeter,
desenvolvia pesquisas na √°rea de modulariza√ß√£o de software. No final da
d√©cada de 80, em uma de suas pesquisas, o grupo enunciou um conjunto de
regras para evitar problemas de encapsulamento em projeto de sistemas
orientados a objetos, as quais ficaram conhecidas como Princ√≠pio ou Lei
de Demeter.</p>
<p>O Princ√≠pio de Demeter ‚Äî tamb√©m chamado de <strong>Princ√≠pio do Menor
Privil√©gio</strong> (<em>Principle of Least Privilege</em>) ‚Äî defende
que a implementa√ß√£o de um m√©todo deve invocar apenas os seguintes outros
m√©todos:</p>
<ul>
<li><p>de sua pr√≥pria classe (caso 1)</p></li>
<li><p>de objetos passados como par√¢metros (caso 2)</p></li>
<li><p>de objetos criados pelo pr√≥prio m√©todo (caso 3)</p></li>
<li><p>de atributos da classe do m√©todo (caso 4)</p></li>
</ul>
<p><strong>Exemplo:</strong> O seguinte c√≥digo mostra um m√©todo,
<code>m1</code>, com quatro chamadas que respeitam o Princ√≠pio de
Demeter. E, em seguida, temos um m√©todo <code>m2</code>, com uma chamada
que n√£o obedece ao princ√≠pio.</p>
<pre><code>class PrincipioDemeter {

  T1 attr;

  void f1() { 
    ...
  }

  void m1(T2 p) {  // m√©todo que segue Demeter
    f1();           // caso 1: pr√≥pria classe
    p.f2();         // caso 2: par√¢metro
    new T3().f3();  // caso 3: criado pelo m√©todo
    attr.f4();      // caso 4: atributo da classe
  }

  void m2(T4 p) {  // m√©todo que viola Demeter
    p.getX().getY().getZ().doSomething();
  }

}</code></pre>
<p>O m√©todo <code>m2</code>, ao chamar tr√™s m√©todos <code>get</code> em
sequ√™ncia, viola o Princ√≠pio de Demeter. O motivo √© que os objetos
intermedi√°rios ‚Äî retornados pelos m√©todos <code>get</code> ‚Äî s√£o usados
apenas como <q>passagem</q> para se chegar ao objeto final, que √© aquele
que de fato nos interessa e sobre o qual vamos executar uma opera√ß√£o
<q>√∫til</q>‚Äî no exemplo, <code>doSomething()</code>. No entanto, esses
objetos intermedi√°rios podem existir apenas para liberar informa√ß√£o
interna sobre o estado de suas classes. Al√©m de tornar a chamada mais
complexa, a informa√ß√£o liberada pode estar sujeita a mudan√ßas. Se isso
ocorrer, um dos <q>elos</q> da sequ√™ncia de chamadas ser√° quebrado e o
cliente ‚Äî o m√©todo <code>m2</code>, no exemplo ‚Äî ter√° que descobrir um
outro modo de atingir o m√©todo final. Em resumo, chamadas que violam o
Princ√≠pio de Demeter t√™m grande chance de quebrar o encapsulamento dos
objetos de passagem.</p>
<p>Costuma-se dizer que o Princ√≠pio de Demeter recomenda que os m√©todos
de uma classe devem falar apenas com seus <q>amigos</q>, isto √©, com
m√©todos da pr√≥pria classe ou ent√£o com m√©todos de objetos que eles
recebem como par√¢metro ou que eles criam. Por outro lado, n√£o √©
recomend√°vel falar com os <q>amigos dos amigos</q>.</p>
<p>Um exemplo ‚Äî formulado por David Bock (<a
href="https://www2.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf">link</a>)
‚Äî ilustra com clareza os benef√≠cios do Princ√≠pio de Demeter. O exemplo
baseia-se em um cen√°rio com tr√™s <q>objetos</q>: um entregador de
jornais, um cliente e sua carteira. Uma viola√ß√£o do Princ√≠pio de Demeter
ocorre se, para receber o valor de um jornal, o entregador tiver que
executar o seguinte c√≥digo:</p>
<pre><code>preco = 6.00;
Carteira carteira = cliente.getCarteira();
if (carteira.getValorTotal() &gt;= preco) {  // viola Demeter
   carteira.debita(preco);                // viola Demeter
} else {
  // volto amanh√£, para cobrar o valor do jornal
}</code></pre>
<p>O jornaleiro tem acesso √† carteira do seu cliente ‚Äî via
<code>getCarteira()</code> ‚Äî e ent√£o ele mesmo retira o valor do jornal
dela. Por√©m, nenhum cliente aceitaria que um jornaleiro tivesse essa
liberdade. Uma solu√ß√£o mais realista √© a seguinte:</p>
<pre><code>preco = 6.00;
try {
  cliente.pagar(preco);
}
catch (ExcecaoValorInsuficiente e) {
  // volto amanh√£, para cobrar o valor do jornal
}</code></pre>
<p>No novo c√≥digo, o cliente n√£o libera o acesso √† sua carteira. Pelo
contr√°rio, o jornaleiro nem fica ciente de que o cliente possui uma
carteira. Essa informa√ß√£o est√° encapsulada na classe
<code>Cliente</code>. Em vez disso, o cliente oferece um m√©todo
<code>pagar</code>, que deve ser chamado pelo jornaleiro. Finalmente,
uma exce√ß√£o sinaliza quando o <code>Cliente</code> n√£o possui recursos
suficientes para pagar pelo jornal.</p>
</section>
<section id="princ√≠pio-abertofechado" data-number="1.6.6">
<h3 data-number="5.6.6"><span class="header-section-number">5.6.6</span>
Princ√≠pio Aberto/Fechado <a href="#princ√≠pio-abertofechado"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Esse princ√≠pio, originalmente proposto por Bertrand Meyer ainda na
d√©cada de 80 (<a
href="https://dl.acm.org/citation.cfm?id=261119">link</a>), defende algo
que pode parecer paradoxal: uma classe deve estar fechada para
modifica√ß√µes e aberta para extens√µes.</p>
<p>No entanto, o aparente paradoxo se esclarece quando o projeto da
classe prev√™ a possibilidade de extens√µes e customiza√ß√µes. Para isso, o
projetista pode se valer de recursos como heran√ßa, fun√ß√µes de mais alta
ordem (ou fun√ß√µes lambda) e padr√µes de projeto, como Abstract Factory,
Template Method e Strategy. Especificamente, no pr√≥ximo cap√≠tulo, iremos
tratar de padr√µes de projeto que permitem customizar uma classe sem
modificar o seu c√≥digo.</p>
<p>Em resumo, o Princ√≠pio Aberto/Fechado tem como objetivo a constru√ß√£o
de classes flex√≠veis e extens√≠veis, capazes de se adaptarem a diversos
cen√°rios de uso, sem modifica√ß√µes no seu c√≥digo fonte.</p>
<p><strong>Exemplo 1:</strong> Um exemplo de classe que segue o
Princ√≠pio Aberto/Fechado √© a classe <code>Collections</code> de Java.
Ela possui um m√©todo est√°tico para ordenar uma lista em ordem crescente
de seus elementos. Um exemplo de uso desse m√©todo √© mostrado a
seguir:</p>
<pre><code>List&lt;String&gt; nomes;
nomes = Arrays.asList(&quot;joao&quot;, &quot;maria&quot;, &quot;alexandre&quot;, &quot;ze&quot;);
Collections.sort(nomes);

System.out.println(nomes);  
// resultado: [&quot;alexandre&quot;,&quot;joao&quot;,&quot;maria&quot;,&quot;ze&quot;]</code></pre>
<p>No entanto, futuramente, podemos precisar de usar o m√©todo
<code>sort</code> para ordenar as strings de acordo com seu tamanho em
caracteres. Felizmente, a classe <code>Collections</code> est√° preparada
para esse novo cen√°rio de uso. Mas para isso precisamos implementar um
objeto <code>Comparator</code>, que ir√° comparar as strings pelo seu
tamanho, como no seguinte c√≥digo:</p>
<pre><code>Comparator&lt;String&gt; comparador = new Comparator&lt;String&gt;() {
  public int compare(String s1, String s2) {
    return s1.length() - s2.length();
  }
};
Collections.sort(nomes, comparador);

System.out.println(nomes);   
// resultado: [ze, joao, maria, alexandre]</code></pre>
<p>Ou seja, a classe <code>Collections</code> se mostrou <q>aberta</q> a
lidar com esse novo requisito, mas mantendo o seu c√≥digo <q>fechado</q>,
isto √©, o c√≥digo fonte da classe n√£o teve que ser modificado.</p>
<p><strong>Exemplo 2</strong>: Mostramos agora um exemplo de fun√ß√£o que
n√£o segue o Princ√≠pio Aberto/Fechado.</p>
<pre><code>double calcTotalBolsas(Aluno[] lista) {
  double  total = 0.0;
  foreach (Aluno aluno in lista) {
    if (aluno instanceof AlunoGrad) {
      AlunoGrad grad = (AlunoGrad) aluno;
      total += &quot;c√≥digo que calcula bolsa de grad&quot;;
    }
    else if (aluno instanceof AlunoMestrado) {
      AlunoMestrado mestrando = (AlunoMestrado) aluno;
      total += &quot;c√≥digo que calcula bolsa de mestrando&quot;;
    }
  }
  return total;
}</code></pre>
<p>Se amanh√£ tivermos que criar mais uma subclasse de
<code>Aluno</code>, por exemplo, <code>AlunoDoutorado</code>, o c√≥digo
de <code>calcTotalBolsas</code> ter√° que ser adaptado. Ou seja, a fun√ß√£o
n√£o est√° preparada para acomodar extens√µes (isto √©, ela n√£o est√°
aberta), nem imune a altera√ß√µes no seu c√≥digo (isto √©, ela tamb√©m n√£o
est√° fechada).</p>
<p>O Princ√≠pio Aberto/Fechado requer que o projetista de uma classe
antecipe os seus pontos de extens√£o. Por isso, n√£o √© poss√≠vel a uma
classe acomodar todos os poss√≠veis tipos de extens√µes que podem
aparecer. Mas apenas aqueles para os quais s√£o oferecidos pontos de
extens√£o, seja via heran√ßa, fun√ß√µes de mais alta ordem ou padr√µes de
projeto. Por exemplo, a implementa√ß√£o da classe <code>Collections</code>
(no exemplo 1) usa um algoritmo de ordena√ß√£o que √© uma vers√£o do
MergeSort. Por√©m, os clientes da classe n√£o podem alterar e customizar
esse algoritmo, tendo que se contentar com a implementa√ß√£o default que √©
oferecida. Logo, sob o crit√©rio de customiza√ß√£o do algoritmo de
ordena√ß√£o, o m√©todo <code>sort</code> n√£o atende ao Princ√≠pio
Aberto/Fechado.</p>
</section>
<section id="princ√≠pio-de-substitui√ß√£o-de-liskov" data-number="1.6.7">
<h3 data-number="5.6.7"><span class="header-section-number">5.6.7</span>
Princ√≠pio de Substitui√ß√£o de Liskov <a
href="#princ√≠pio-de-substitui√ß√£o-de-liskov" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Conforme j√° discutimos ao falar do princ√≠pio <q>Prefira Composi√ß√£o a
Heran√ßa</q>, heran√ßa n√£o √© mais um conceito popular como foi na d√©cada
de 80. Hoje, o emprego de heran√ßa √© mais restrito e raro. No entanto,
alguns casos de uso ainda s√£o justificados. Heran√ßa define uma rela√ß√£o
<q>√©-um</q> entre objetos de uma classe base e objetos de subclasses. A
vantagem √© que comportamentos (isto √©, m√©todos) comuns a essas classes
podem ser implementados uma √∫nica vez, na classe base. Feito isso, eles
s√£o herdados em todas as subclasses.</p>
<p> O Princ√≠pio de Substitui√ß√£o de Liskov explicita regras para
redefini√ß√£o de m√©todos de classes base em classes filhas. O nome do
princ√≠pio √© uma refer√™ncia a Barbara Liskov, professora do MIT e
ganhadora da edi√ß√£o de 2008 do Pr√™mio Turing. Dentre outros trabalhos,
Liskov desenvolveu pesquisas sobre sistemas de tipos para linguagens
orientadas a objetos. Em um desses trabalhos, ela enunciou o princ√≠pio
que depois ganhou seu nome.</p>
<p>Para explicar o Princ√≠pio de Substitui√ß√£o de Liskov vamos nos basear
no seguinte exemplo:</p>
<pre><code>void f(A a) {
  ...
  a.g();
  ...
}</code></pre>
<p>O m√©todo <code>f</code> pode ser chamado passando-se como par√¢metros
objetos de subclasses <code>B1</code>, <code>B2</code>, ‚Ä¶,
<code>Bn</code> da classe base <code>A</code>, como mostrado a
seguir:</p>
<pre><code>f(new B1());  // f pode receber objetos da subclasse B1 
...
f(new B2());  // e de qualquer subclasse de A, como B2
...
f(new B3());  // e B3</code></pre>
<p>O Princ√≠pio de Substitui√ß√£o de Liskov determina as condi√ß√µes ‚Äî
sem√¢nticas e n√£o sint√°ticas ‚Äî que as subclasses devem atender para que
um programa como o anterior funcione.</p>
<p>Suponha que as subclasses <code>B1</code>, <code>B2</code>, ‚Ä¶.,
<code>Bn</code> redefinam o m√©todo <code>g()</code> de <code>A</code>,
que √© um m√©todo chamado no corpo de <code>f</code>. O Princ√≠pio de
Substitui√ß√£o de Liskov prescreve que essas redefini√ß√µes n√£o podem violar
o contrato da implementa√ß√£o original de <code>g</code> em A.</p>
<p><strong>Exemplo 1:</strong> Suponha uma classe base que calcula
n√∫meros primos. Suponha ainda algumas subclasses que implementam outros
algoritmos com o mesmo prop√≥sito. Especificamente, o m√©todo
<code>getPrimo(n)</code> √© um m√©todo que retorna o n-√©simo n√∫mero primo.
Esse m√©todo existe na classe base e √© redefinido em todas as
subclasses.</p>
<p>Suponha ainda que o contrato do m√©todo <code>getPrimo(n)</code>
especifique o seguinte: <em>1 &lt;= n &lt;= 1 milh√£o</em>. Ou seja, o
m√©todo deve ser capaz de retornar qualquer n√∫mero primo, para n variando
de 1 at√© 1 milh√£o. Nesse exemplo, uma poss√≠vel viola√ß√£o do contrato de
<code>getPrimo(n)</code> ocorre, por exemplo, se, em uma das classes, o
algoritmo implementado calcule apenas n√∫meros primos at√© 900 mil.</p>
<p>De forma mais concreta, o Princ√≠pio de Substitui√ß√£o de Liskov define
o seguinte: suponha que um cliente chame um m√©todo
<code>getPrimo(n)</code> de um objeto <code>p</code> da classe
<code>NumeroPrimo</code>. Suponha agora que o objeto <code>p</code> seja
<q>substitu√≠do</q> por um objeto de uma subclasse de
<code>NumeroPrimo</code>. Nesse caso, o cliente vai passar a executar o
m√©todo <code>getPrimo(n)</code> dessa subclasse. Por√©m, essa
<q>substitui√ß√£o</q> de m√©todos n√£o deve ter impacto no comportamento do
cliente. Para tanto, todos os m√©todos <code>getPrimo(n)</code> das
subclasses de <code>NumeroPrimo</code> devem realizar as mesmas tarefas
que o m√©todo original, possivelmente de modo mais eficiente.</p>
<p><strong>Exemplo 2:</strong> Vamos mostrar um segundo exemplo de
viola√ß√£o, dessa vez bem forte, exatamente para refor√ßar o sentido do
Princ√≠pio de Substitui√ß√£o de Liskov.</p>
<pre><code>class A {
  int soma(int a, int b) {
    return a+b;
  }
}</code></pre>
<pre><code>class B extends A {

  int soma(int a, int b) {
    String r = String.valueOf(a) + String.valueOf(b);
    return Integer.parseInt(r);
  }

}</code></pre>
<pre><code>class Cliente {

  void f(A a) {
    ...
    a.soma(1,2); // pode retornar 3 ou 12
    ...
  }

}</code></pre>
<pre><code>
class Main {

  void main() {
    A a = new A();
    B b = new B();
    Cliente cliente = new Cliente();
    cliente.f(a);
    cliente.f(b);
  }

}</code></pre>
<p>Nesse exemplo, o m√©todo que soma dois inteiros foi redefinido na
subclasse com uma sem√¢ntica de concatena√ß√£o dos respectivos valores
convertidos para strings. Logo, para um desenvolvedor encarregado de
manter a classe <code>Cliente</code> a situa√ß√£o fica bastante confusa.
Em uma execu√ß√£o, a chamada <code>soma(1,2)</code> retorna 3 (isto √©,
1+2); na execu√ß√£o seguinte, a mesma chamada ir√° retornar 12 (isto √©,
<q>1</q>+ <q>2</q> = <q>12</q> ou 12, como inteiro).</p>
</section>
</section>
<section id="m√©tricas-de-c√≥digo-fonte" data-number="1.7">
<h2 data-number="5.7"><span class="header-section-number">5.7</span>
M√©tricas de C√≥digo Fonte <a href="#m√©tricas-de-c√≥digo-fonte"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p></p>
<p>Ao longo dos anos, diversas m√©tricas foram propostas para quantificar
propriedades de um projeto de software. Normalmente, essas m√©tricas
precisam do c√≥digo fonte de um sistema, isto √©, o projeto j√° deve ter
sido implementado. Por meio da an√°lise de caracter√≠sticas do c√≥digo
fonte, elas expressam de forma quantitativa ‚Äî por meio de valores
num√©ricos ‚Äî propriedades como tamanho, coes√£o, acoplamento e
complexidade do c√≥digo. O objetivo √© permitir a avalia√ß√£o da qualidade
de um projeto de forma mais objetiva.</p>
<p>No entanto, a monitora√ß√£o do projeto de um sistema por meio de
m√©tricas de c√≥digo fonte n√£o √© uma pr√°tica t√£o comum nos dias de hoje.
Um dos motivos √© que diversas propriedades de um sistema de software ‚Äî
como coes√£o e acoplamento, por exemplo ‚Äî possuem um grau de
subjetividade, o que dificulta a sua mensura√ß√£o. Al√©m disso, a
interpreta√ß√£o dos resultados de m√©tricas de software depende de
informa√ß√µes de contexto. Uma determinada faixa de valores de uma m√©trica
pode ser admiss√≠vel em um sistema, mas n√£o ser em outro sistema, de um
dom√≠nio diferente. Mesmo entre as classes de um sistema, a interpreta√ß√£o
dos valores de uma determinada m√©trica pode ser bem distinta.</p>
<p>Nesta se√ß√£o, vamos estudar m√©tricas para mensurar as seguintes
propriedades de um projeto de software: tamanho, coes√£o, acoplamento e
complexidade. Iremos detalhar os procedimentos de c√°lculo dessas
m√©tricas e dar alguns exemplos. Existem ainda ferramentas que calculam
essas m√©tricas de forma autom√°tica. Algumas delas funcionam como plugins
de IDEs conhecidas.</p>
<section id="tamanho" data-number="1.7.1">
<h3 data-number="5.7.1"><span class="header-section-number">5.7.1</span>
Tamanho <a href="#tamanho" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> A m√©trica de c√≥digo fonte mais popular √© <strong>linhas de
c√≥digo</strong> (LOC, <em>lines of code</em>). Ela pode ser usada para
medir o tamanho de uma fun√ß√£o, classe, pacote ou de um sistema inteiro.
Quando se reporta os resultados de LOC, deve-se deixar claro quais
linhas foram de fato contadas. Por exemplo, se coment√°rios ou linhas em
branco foram considerados ou n√£o.</p>
<p>Embora LOC possa dar uma ideia do tamanho de um sistema, ela n√£o deve
ser usada para medir a produtividade de programadores. Por exemplo, se
um desenvolvedor implementou 1 KLOC em um m√™s e outro implementou 5
KLOC, n√£o podemos afirmar que o segundo foi 5 vezes mais produtivo.
Dentre outros motivos, os requisitos implementados por cada um deles
podem ter complexidade diferente. Ken Thompson ‚Äî um dos desenvolvedores
do sistema operacional Unix ‚Äî tem uma frase a esse respeito:</p>
<p></p>
<blockquote>
<p><q>Um dos dias mais produtivos da minha vida foi quando eu deletei
1.000 linhas de c√≥digo de um sistema.</q></p>
</blockquote>
<p>Essa frase √© atribu√≠da a Thompson no seguinte <a
href="https://dl.acm.org/citation.cfm?id=829549">livro</a>, de Eric
Raymond, p√°gina 24. Portanto, m√©tricas de software, quaisquer que sejam,
n√£o devem ser vistas como uma meta. No caso de LOC, isso poderia, por
exemplo, incentivar os desenvolvedores a gerar c√≥digo duplicado apenas
para cumprir a meta estabelecida.</p>
<p>Outras metas de tamanho de um sistema incluem: n√∫mero de m√©todos,
n√∫mero de atributos, n√∫mero de classes e n√∫mero de pacotes.</p>
</section>
<section id="coes√£o-1" data-number="1.7.2">
<h3 data-number="5.7.2"><span class="header-section-number">5.7.2</span>
Coes√£o <a href="#coes√£o-1" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Uma das m√©tricas mais conhecidas para se calcular coes√£o √© chamada de
<strong>LCOM</strong> (<em>Lack of Cohesion Between Methods</em>). Na
verdade, como seu nome indica, LCOM mede a <q>falta de coes√£o</q> de uma
classe. Em geral, m√©tricas de software s√£o interpretadas da seguinte
forma: quanto maior o valor da m√©trica, pior a qualidade do c√≥digo ou do
projeto. No entanto, coes√£o √© uma exce√ß√£o a essa regra, pois quanto
maior a coes√£o de uma classe, melhor o seu projeto. Por isso, LCOM foi
planejada para medir a falta de coes√£o de classes. Quanto maior o valor
de LCOM, maior a falta de coes√£o de uma classe e, portanto, pior o seu
projeto.</p>
<p>Para calcular o valor de LCOM de uma classe C deve-se, primeiro,
computar o seguinte conjunto:</p>
<p><em>M(C) = { (f<sub>1</sub>, f<sub>2</sub>) | f<sub>1</sub> e
f<sub>2</sub> s√£o m√©todos de C }</em></p>
<p>Ele √© formado por todos os pares n√£o-ordenados de m√©todos da classe
C. Seja ainda o seguinte conjunto:</p>
<p><em>A(f) = conjunto de atributos da classe que s√£o acessados por um
m√©todo f</em></p>
<p>O valor de LCOM de C √© assim definido:</p>
<p><em>P = | { (f<sub>1</sub>, f<sub>2</sub>) in M(C) | A(f<sub>1</sub>)
e A(f<sub>2</sub>) s√£o conjuntos disjuntos } |</em></p>
<p>Isto √©, LCOM(C) √© o n√∫mero de pares de m√©todos ‚Äî dentre todos os
poss√≠veis pares de m√©todos de C ‚Äî que n√£o usam atributos em comum, isto
√©, a interse√ß√£o deles √© vazia.</p>
<p><strong>Exemplo:</strong> Para deixar a explica√ß√£o mais clara,
suponha a seguinte classe:</p>
<pre><code>class A {

  int a1;
  int a2;
  int a3;

  void m1() {
    a1 = 10;
    a2 = 20;
  }

  void m2() {
    System.out.println(a1);
    a3 = 30;
  }

  void m3() {
    System.out.println(a3);
  }

}</code></pre>
<p>A pr√≥xima tabela mostra os elementos dos conjuntos M e A; e o
resultado da interse√ß√£o que define o valor de LCOM.</p>
<figure>
<img src="figs/cap5/lcom.jpg" style="width:80.0%"
alt="Exemplo de c√°lculo de LCOM" />
<figcaption aria-hidden="true">Exemplo de c√°lculo de LCOM</figcaption>
</figure>
<p>Logo, nesse exemplo, LCOM(C) = 1, pois a classe C tem tr√™s poss√≠veis
pares de m√©todos, mas dois deles acessam pelo menos um atributo em comum
(veja terceira coluna da tabela). Resta um √∫nico par de m√©todos que n√£o
tem atributos em comum.</p>
<p>LCOM parte do pressuposto que, em uma classe coesa, qualquer par de
m√©todos deve acessar pelo menos um atributo em comum. Ou seja, o que d√°
coes√£o a uma classe √© o fato de seus m√©todos trabalharem com os mesmos
atributos. Por isso, a coes√£o de uma classe √© prejudicada ‚Äî isto √©, seu
LCOM aumenta em uma unidade ‚Äî sempre que achamos um par de m√©todos
(f<sub>1</sub>,f<sub>2</sub>), onde f<sub>1</sub> manipula alguns
atributos e f<sub>2</sub> manipula atributos diferentes.</p>
<p>Para c√°lculo de LCOM n√£o s√£o considerados m√©todos construtores e
getters/setters. Construtores tendem a ter atributos em comum com a
maioria dos outros m√©todos. E o contr√°rio tende a acontecer com getters
e setters.</p>
<p>Por fim, √© importante mencionar que existem propostas alternativas
para c√°lculo de LCOM. A vers√£o que apresentamos, chamada de LCOM1, foi
proposta por Shyam Chidamber e Chris Kemerer, em 1991 (<a
href="https://doi.org/10.1145/118014.117970">link</a>). As vers√µes
alternativas ganham os nomes de LCOM2, LCOM3, etc. Por isso, ao reportar
valores de LCOM, √© importante deixar claro qual vers√£o da m√©trica est√°
sendo adotada.</p>
</section>
<section id="acoplamento-1" data-number="1.7.3">
<h3 data-number="5.7.3"><span class="header-section-number">5.7.3</span>
Acoplamento <a href="#acoplamento-1" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p><strong>CBO</strong> (<em>Coupling Between Objects</em>) √© uma
m√©trica para medir <strong>acoplamento estrutural</strong> entre duas
classes. Ela tamb√©m foi proposta por Chidamber e Kemerer (<a
href="https://doi.org/10.1145/118014.117970"><u>link1</u></a> e <a
href="https://doi.org/10.1109/32.295895"><u>link2</u></a>).</p>
<p>Dada uma classe A, CBO conta o n√∫mero de classes das quais A depende
de forma sint√°tica (ou estrutural). Diz-se que A depende de uma classe B
quando:</p>
<ul>
<li><p>A chama um m√©todo de B</p></li>
<li><p>A acessa um atributo p√∫blico de B</p></li>
<li><p>A herda de B</p></li>
<li><p>A declara uma vari√°vel local, um par√¢metro ou um tipo de retorno
do tipo B</p></li>
<li><p>A captura uma exce√ß√£o do tipo B</p></li>
<li><p>A levanta uma exce√ß√£o do tipo B</p></li>
<li><p>A cria um objeto do tipo B.</p></li>
</ul>
<p>Seja uma classe A com dois m√©todos (<code>metodo1</code> e
<code>metodo2</code>):</p>
<pre><code>class A extends T1 implements T2 {

  T3 a;

  T4 metodo1(T5 p) throws T6 {
    T7 v;
    ...
  }

  void metodo2() {
    T8 = new T8();
    try {
      ...
    }
    catch (T9 e) { ... }
  }

}</code></pre>
<p>Conforme indicamos numerando os tipos de que A depende, CBO(A) =
9.</p>
<p>A defini√ß√£o de CBO n√£o distingue as classes das quais uma classe
depende. Por exemplo, tanto faz se a depend√™ncia √© para uma classe da
biblioteca de Java (por exemplo, String) ou uma classe mais inst√°vel da
pr√≥pria aplica√ß√£o que est√° sendo desenvolvida.</p>
</section>
<section id="complexidade" data-number="1.7.4">
<h3 data-number="5.7.4"><span class="header-section-number">5.7.4</span>
Complexidade <a href="#complexidade" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p><strong>Complexidade Ciclom√°tica</strong> (CC) √© uma m√©trica proposta
por Thomas McCabe em 1976 para medir a complexidade do c√≥digo de uma
fun√ß√£o ou m√©todo (<a
href="https://dl.acm.org/citation.cfm?id=1313586">link</a>). √Äs vezes,
ela √© chamada tamb√©m de Complexidade de McCabe. No contexto dessa
m√©trica, o conceito de complexidade relaciona-se com a dificuldade de
manter e testar uma fun√ß√£o. A defini√ß√£o de CC baseia-se no conceito de
grafos de fluxo de controle. Em tais grafos, os nodos representam os
comandos de uma fun√ß√£o ou m√©todo; e as arestas representam os poss√≠veis
fluxos de controle. Portanto, comandos como <code>if</code> geram fluxos
de controle alternativos. O nome da m√©trica deriva do fato de ser
calculada usando um conceito de Teoria dos Grafos chamado de n√∫mero
ciclom√°tico (<em>cyclomatic number</em>).</p>
<p>Por√©m, existe uma alternativa simples para calcular o CC de uma
fun√ß√£o, a qual dispensa a constru√ß√£o de grafos de fluxo de controle.
Essa alternativa define CC da seguinte forma:</p>
<p><em>CC = <q>n√∫mero de comandos de decis√£o em uma fun√ß√£o</q> +
1</em></p>
<p>Onde comandos de decis√£o podem ser <code>if</code>,
<code>while</code>, <code>case</code>, <code>for</code>, etc. A intui√ß√£o
subjacente a essa f√≥rmula √© que comandos de decis√£o tornam o c√≥digo mais
dif√≠cil de entender e testar e, portanto, mais complexo.</p>
<p>Portanto, o c√°lculo de CC √© bastante simples: dado o c√≥digo fonte de
uma fun√ß√£o, conte o n√∫mero dos comandos listados acima e some 1.
Consequentemente, o menor valor de CC √© 1, que ocorre em um c√≥digo que
n√£o possui nenhum comando de decis√£o. No artigo em que definiu a
m√©trica, McCabe sugere que um <q>limite superior razo√°vel, mas n√£o
m√°gico</q> para CC √© 10.</p>
</section>
</section>
<h2 class="unnumbered" id="bibliografia">Bibliografia <a
href="#bibliografia" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Robert C. Martin. Clean Architecture: A Craftsman's Guide to Software
Structure and Design, Prentice Hall, 2017.</p>
<p>John Ousterhout. A Philosophy of Software Design, Yaknyam Press,
2018.</p>
<p>Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides. Design
Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley,
1995.</p>
<p>Frederick P. Brooks. O M√≠tico Homem-M√™s. Ensaios Sobre Engenharia de
Software. Alta Books, 1a edi√ß√£o, 2018.</p>
<p>Diomidis Spinellis. Code Quality. Addison-Wesley, 2006.</p>
<p>Andrew Hunt, David Thomas. The Pragmatic Programmer: From Journeyman
to Master. Addison-Wesley, 1999.</p>
<p>Mauricio Aniche. Orienta√ß√£o a Objetos e SOLID para Ninjas. Projetando
classes flex√≠veis. Casa do C√≥digo, 2015.</p>
<p>Thomas J. McCabe. A Complexity Measure. IEEE Transactions on Software
Engineering, 1976.</p>
<p>Shyam Chidamber and Chris Kemerer. A metrics suite for object
oriented design. IEEE Transactions on Software Engineering, 1994.</p>
<p>Shyam Chidamber and Chris Kemerer. Towards a metrics suite for object
oriented design. Conference on Object-oriented Programming Systems,
Languages, and Applications (OOPSLA), 1991.</p>
<h2 class="unnumbered" id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o
<a href="#exerc√≠cios-de-fixa√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>1. Descreva tr√™s benef√≠cios da propriedade de projeto chamada
ocultamento de informa√ß√£o (<em>information hiding</em>)?</p>
<p>2. Suponha que um programador adote a seguinte estrat√©gia: ao
implementar qualquer nova funcionalidade ou corrigir um bug que implique
na modifica√ß√£o de duas classes A e B localizadas em arquivos diferentes,
ele conclui a tarefa movendo as classes para o mesmo arquivo. Explicando
melhor: ap√≥s terminar a tarefa de programa√ß√£o que ficou sob sua
responsabilidade, ele escolhe uma das classes, digamos a classe B, e a
move para o mesmo arquivo da classe A. Agindo dessa maneira, ele estar√°
melhorando qual propriedade de projeto? Por outro lado, qual propriedade
de projeto estar√° sendo afetada de modo negativo? Justifique.</p>
<p>3. <strong>Classitis</strong> √© o nome dado por John Ousterhout √†
prolifera√ß√£o de pequenas classes em um sistema. Segundo ele,
<em>classitis</em> pode resultar em classes que individualmente s√£o
simples, mas que aumentam a complexidade total de um sistema. Usando os
conceitos de acoplamento e coes√£o, como podemos explicar o problema
causado por essa <q>doen√ßa</q>?</p>
<p>4. Defina: (a) acoplamento aceit√°vel; (b) acoplamento ruim; (c)
acoplamento estrutural; (d) acoplamento evolutivo (ou l√≥gico).</p>
<p>5. D√™ um exemplo de: (1) acoplamento estrutural e aceit√°vel; (2)
acoplamento estrutural e ruim.</p>
<p>6. √â poss√≠vel que uma classe A esteja acoplada a uma classe B sem ter
uma refer√™ncia para B em seu c√≥digo? Se sim, esse acoplamento ser√°
aceit√°vel ou ser√° um acoplamento ruim?</p>
<p>7. Suponha um programa em que todo o c√≥digo est√° implementado no
m√©todo <code>main</code>. Ele tem um problema de coes√£o ou acoplamento?
Justifique.</p>
<p>8. Qual princ√≠pio de projeto √© violado pelo seguinte c√≥digo?</p>
<pre><code>void onclick() {
  num1 = textfield1.value();
  c1 = BD.getConta(num1)
  num2 = textfield2.value();
  c2 = BD.getConta(num2)
  valor = textfield3.value();
  beginTransaction();
  try {
    c1.retira(valor);
    c2.deposita(valor);
    commit();
  }          
  catch() {
    rollback();
  }
}  </code></pre>
<p>9. Costuma-se afirmar que existem tr√™s conceitos chaves em orienta√ß√£o
a objetos: encapsulamento, polimorfismo e heran√ßa. Suponha que voc√™
tenha sido encarregado de projetar uma nova linguagem de programa√ß√£o.
Suponha ainda que voc√™ poder√° escolher apenas dois dos tr√™s conceitos
que mencionamos. Qual dos conceitos eliminaria ent√£o da sua nova
linguagem? Justifique sua resposta.</p>
<p>10. Qual princ√≠pio de projeto √© violado pelo seguinte c√≥digo? Como
voc√™ poderia alterar o c√≥digo do m√©todo para atender a esse
princ√≠pio?</p>
<pre><code>void sendMail(ContaBancaria conta, String msg) {
  Cliente cliente = conta.getCliente();
  String mail = cliente.getMailAddress();
  &quot;Envia mail&quot;
}  </code></pre>
<p>11. Qual princ√≠pio de projeto √© violado pelo seguinte c√≥digo? Como
voc√™ poderia alterar o c√≥digo do m√©todo para atender a esse
princ√≠pio?</p>
<pre><code>void imprimeDataContratacao(Funcionario func) {
  Date data = func.getDataContratacao();
  String msg = data.format();
  System.out.println(msg);
}  </code></pre>
<p>12. As pr√©-condi√ß√µes de um m√©todo s√£o express√µes booleanas envolvendo
seus par√¢metros (e, possivelmente, o estado de sua classe) que devem ser
verdadeiras antes da sua execu√ß√£o. De forma semelhante, as p√≥s-condi√ß√µes
s√£o express√µes booleanas envolvendo o resultado do m√©todo. Considerando
essas defini√ß√µes, qual princ√≠pio de projeto √© violado pelo c√≥digo
abaixo?</p>
<pre><code>class A {  
  int f(int x) { // pre: x &gt; 0
    ...
    return exp;
  }              // pos: exp &gt; 0
  ...
}</code></pre>
<pre><code>class B extends A {  
  int f(int x) { // pre: x &gt; 10
  ...
  return exp;
  }              // pos: exp &gt; -50
  ...
}</code></pre>
<p>13. Calcule o CBO e LCOM da seguinte classe:</p>
<pre><code>class A extends B {

  C f1, f2, f3;

  void m1(D p) {
    &quot;usa f1 e f2&quot;
  }
  void m2(E p) {
    &quot;usa f2 e f3&quot;
  }
  void m3(F p) {
    &quot;usa f3&quot;  
  }
}</code></pre>
<p>14. Qual das seguintes classes √© mais coesa? Justifique computando os
valores de LCOM de cada uma delas.</p>
<pre><code>class A {

  X x = new X();

  void f() {
    x.m1();
  }
  void g() {
    x.m2();
  }
  void h() {
    x.m3();
  }
}</code></pre>
<pre><code>class B {

  X x = new X();
  Y y = new Y();
  Z z = new Z();

  void f() {
    x.m();
  }

  void g() {
    y.m();
  }

  void h() {
    z.m();
  }

}</code></pre>
<p>15. Por que a m√©trica LCOM mede a aus√™ncia e n√£o a presen√ßa de
coes√£o? Justifique.</p>
<p>16. Todos os m√©todos de uma classe devem ser considerados no c√°lculo
de LCOM? Sim ou n√£o? Justifique.</p>
<p>17. A defini√ß√£o de complexidade ciclom√°tica √© independente de
linguagem de programa√ß√£o. Sim ou n√£o? Justifique.</p>
<p>18. D√™ um exemplo de c√≥digo com complexidade ciclom√°tica m√≠nima. Qual
√© essa complexidade?</p>
<p>19. Cristina Lopes ‚Äî professora da Universidade da Calif√≥rnia, em
Irvine, nos EUA ‚Äî √© autora de um livro sobre estilos de programa√ß√£o (<a
href="https://dl.acm.org/citation.cfm?id=2648631">link</a>). Ela discute
no livro diversos estilos para implementa√ß√£o de um mesmo problema,
chamado frequ√™ncia de termos. Dado um arquivo texto, deve-se listar as
<em>n</em>-palavras mais frequentes em ordem decrescente de frequ√™ncia e
ignorando <em>stop words</em>, isto √©, artigos, preposi√ß√µes, etc. O
c√≥digo fonte em Python de todas as vers√µes analisadas no livro est√°
publicamente dispon√≠vel no GitHub (e, para esse exerc√≠cio, fizemos um
fork do reposit√≥rio original). Fa√ßa uma an√°lise de duas dessas
vers√µes:</p>
<ul>
<li><p>Monol√≠tica, dispon√≠vel neste <a
href="https://github.com/mtov/exercises-in-programming-style/tree/master/04-monolith">link</a>.</p></li>
<li><p>Orientada a objetos, dispon√≠vel neste <a
href="https://github.com/mtov/exercises-in-programming-style/tree/master/11-things">link</a>.</p></li>
</ul>
<p>Primeiro, revise e estude o c√≥digo das duas vers√µes (cada vers√£o tem
menos de 100 linhas). Em seguida, argumente sobre as vantagens da
solu√ß√£o OO sobre a vers√£o monol√≠tica. Para isso, tente extrapolar o
tamanho do sistema. Suponha que ele ser√° implementado por
desenvolvedores diferentes e que cada um ficar√° respons√°vel por uma
parte do projeto.</p>
</section>
</div>
</div>
</div>

<footer>
Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formul√°rio</a>.
</footer>
</body>
</html>
