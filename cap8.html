<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 8: Testes ‚Äì Engenharia de Software Moderna</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="helper/pico.min.css"/>

  <style>
    .container {
        max-width: 900px; /* Set your desired maximum width here */
        margin: 0 auto; /* Center the container */
        padding: 0 20px; /* Optional: Add some horizontal padding */
    }
    .anchor-link {
        opacity: 0.5;
        font-size: 60%;
    }
  </style>

  <style>
    code {
      word-spacing: 0; /* Ensures no extra space around words */
      padding: 0; /* Adjusts any unwanted padding */
      margin: 0; /* Removes any unnecessary margin */
    }  
  </style>

  <script>
    document.documentElement.setAttribute('data-theme', 'light');
  </script>

</head>
<body>
<header class="container">

<div style="margin-top: 30px;">
<a href="https://engsoftmoderna.info">   
<img src="https://engsoftmoderna.info/figs/capa/capa-3d.jpg" alt="Capa do livro">
</a>
</div>

<div style="margin-top: 30px;">
<p> 
<a href="https://engsoftmoderna.info">P√°gina Principal</a> |
<a href="#" id="dark-mode-toggle">Modo Dark</a> 
</p>
</div>

</header>

<main class="container">

<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="8" id="testes"><span
class="header-section-number">8</span> Testes <a href="#testes"
class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>Code without tests is bad code.</em> ‚Äì Michael Feathers</p>
</blockquote>
<p>Este cap√≠tulo inicia com uma introdu√ß√£o a testes, na qual usamos uma
pir√¢mide para classificar os principais tipos de testes, de acordo com a
sua granularidade e frequ√™ncia. Tamb√©m esclarecemos que o nosso foco no
cap√≠tulo s√£o testes de unidade. Assim, come√ßamos com uma se√ß√£o sobre
conceitos e funcionamento b√°sico desse tipo de teste (Se√ß√£o 8.2). Em
seguida, tratamos de aspectos avan√ßados e complementares, ainda sobre
testes de unidade, incluindo princ√≠pios para escrita de tais testes
(Se√ß√£o 8.3), cobertura de testes (Se√ß√£o 8.4), projeto de software para
facilitar a implementa√ß√£o de testes de unidade (Se√ß√£o 8.5) e objetos
mocks, os quais s√£o usados para facilitar a implementa√ß√£o de testes de
unidade (Se√ß√£o 8.6). Na Se√ß√£o 8.7, apresentamos o conceito de
Desenvolvimento Dirigido por Testes (ou <em>Test-Driven
Development</em>, TDD). Em seguida, tratamos dos testes da parte de cima
da pir√¢mide de testes, ou seja, Testes de Integra√ß√£o (Se√ß√£o 8.8) e
Testes de Sistemas (Se√ß√£o 8.9). Para fechar o cap√≠tulo, a Se√ß√£o 8.10
cobre de forma r√°pida outros tipos de testes, tais como: testes
caixa-preta e caixa-branca, testes de aceita√ß√£o e testes de requisitos
n√£o-funcionais.</p>
<h2 data-number="8.1" id="introdu√ß√£o"><span
class="header-section-number">8.1</span> Introdu√ß√£o <a
href="#introdu√ß√£o" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p></p>
<p>Software √© uma das constru√ß√µes humanas mais complexas, como
discutimos na Introdu√ß√£o deste livro. Portanto, √© compreens√≠vel que
sistemas de software estejam sujeitos aos mais variados tipos de erros e
inconsist√™ncias. Para evitar que tais erros cheguem aos usu√°rios finais
e causem preju√≠zos de valor incalcul√°vel, √© fundamental introduzir
atividades de teste em projetos de desenvolvimento de software. De fato,
teste √© uma das pr√°ticas de programa√ß√£o mais valorizadas hoje em dia, em
qualquer tipo de software. √â tamb√©m uma das pr√°ticas que sofreram mais
transforma√ß√µes nos anos recentes.</p>
<p>Quando o desenvolvimento era em cascata, os testes ocorriam em uma
fase separada, ap√≥s as fases de levantamento de requisitos, an√°lise,
projeto e codifica√ß√£o. Al√©m disso, existia uma equipe separada de
testes, respons√°vel por verificar se a implementa√ß√£o atendia aos
requisitos do sistema. Para checar isso, frequentemente os testes eram
manuais, isto √©, uma pessoa usava o sistema, informava dados de entrada
e verificava se as sa√≠das eram aquelas esperadas. Assim, o objetivo de
tais testes era apenas detectar bugs, antes que o sistema entrasse em
produ√ß√£o.</p>
<p>Com m√©todos √°geis, a pr√°tica de testes de software foi profundamente
reformulada, conforme explicamos a seguir:</p>
<ul>
<li><p>Grande parte dos testes passou a ser automatizada, isto √©, al√©m
de implementar as classes de um sistema, os desenvolvedores passaram a
implementar tamb√©m c√≥digo para testar tais classes. Assim, os programas
tornaram-se <strong>auto-test√°veis</strong>.</p></li>
<li><p>Testes n√£o s√£o mais implementados ap√≥s todas as classes de um
sistema ficarem prontas. Muitas vezes, eles s√£o implementados at√© mesmo
antes dessas classes.</p></li>
<li><p>N√£o existem mais grandes equipes de testes ‚Äî ou elas s√£o
respons√°veis por testes espec√≠ficos. Em vez disso, o desenvolvedor que
implementa uma classe tamb√©m deve implementar os seus testes.</p></li>
<li><p>Testes n√£o s√£o mais um instrumento exclusivo para detec√ß√£o de
bugs. Claro, isso continua sendo importante, mas testes ganharam novas
fun√ß√µes, como verificar se uma classe continuar√° funcionando ap√≥s um bug
ser corrigido em uma outra parte do sistema. E testes s√£o tamb√©m usados
como documenta√ß√£o para o c√≥digo de produ√ß√£o.</p></li>
</ul>
<p>Essas transforma√ß√µes tornaram testes uma das pr√°ticas de programa√ß√£o
mais valorizadas em desenvolvimento moderno de software. √â nesse
contexto que devemos entender a frase de Michael Feathers que abre esse
cap√≠tulo: se um c√≥digo n√£o √© acompanhado de testes, ele pode ser
considerado de baixa qualidade ou at√© mesmo um c√≥digo
legado<em>.</em></p>
<p>Neste cap√≠tulo, vamos focar em <strong>testes automatizados</strong>,
pois testes manuais d√£o muito trabalho, s√£o demorados e caros. Pior
ainda, eles devem ser repetidos toda vez que o sistema sofrer uma
modifica√ß√£o.</p>
<p> Uma forma interessante de classificar testes automatizados √© por
meio de uma <strong>pir√¢mide de testes</strong>, originalmente proposta
por Mike Cohn (<a
href="https://dl.acm.org/citation.cfm?id=1667109">link</a>). Como mostra
a pr√≥xima figura, essa pir√¢mide particiona os testes de acordo com sua
granularidade.</p>
<figure>
<img src="figs/cap8/piramide-testes.svg" style="width:70.0%"
alt="Pir√¢mide de testes" />
<figcaption aria-hidden="true">Pir√¢mide de testes</figcaption>
</figure>
<p> Particularmente, os testes s√£o divididos em tr√™s grupos.
<strong>Testes de unidade</strong> verificam automaticamente pequenas
partes de um c√≥digo, normalmente uma classe apenas (acompanhe tamb√©m
pelas figuras da pr√≥xima p√°gina). Eles formam a base da pir√¢mide, ou
seja, a maior parte dos testes est√£o nessa categoria. Testes de unidade
s√£o simples, mais f√°ceis de implementar e executam rapidamente. No
pr√≥ximo n√≠vel, temos <strong>testes de integra√ß√£o</strong> ou
<strong>testes de servi√ßos</strong>, que verificam uma funcionalidade ou
transa√ß√£o completa de um sistema. Logo, s√£o testes que usam diversas
classes, de pacotes distintos, e podem ainda testar componentes
externos, como bancos de dados. Testes de integra√ß√£o demandam mais
esfor√ßo para serem implementados e executam de forma mais lenta. Por
fim, no topo da pir√¢mide, temos os <strong>testes de sistema</strong>,
tamb√©m chamados de <strong>testes de interface com o usu√°rio</strong>.
Eles simulam, da forma mais fiel poss√≠vel, uma sess√£o de uso do sistema
por um usu√°rio real. Como s√£o testes de ponta a ponta
(<em>end-to-end</em>), eles s√£o mais caros, mais lentos e menos
numerosos. Testes de interface costumam ser tamb√©m fr√°geis, isto √©,
m√≠nimas altera√ß√µes nos componentes da interface podem demandar
modifica√ß√µes nesses testes.</p>
<figure>
<img src="figs/cap8/teste-unidade.svg" style="width:25.0%"
alt="Escopo de testes de unidade" />
<figcaption aria-hidden="true">Escopo de testes de unidade</figcaption>
</figure>
<figure>
<img src="figs/cap8/teste-integracao.svg" style="width:25.0%"
alt="Escopo de testes de integra√ß√£o" />
<figcaption aria-hidden="true">Escopo de testes de
integra√ß√£o</figcaption>
</figure>
<figure>
<img src="figs/cap8/teste-sistema.svg" style="width:25.0%"
alt="Escopo de testes de sistema" />
<figcaption aria-hidden="true">Escopo de testes de sistema</figcaption>
</figure>
<p>Uma recomenda√ß√£o gen√©rica √© que esses tr√™s testes sejam implementados
na seguinte propor√ß√£o: 70% como testes de unidades; 20% como testes de
servi√ßos e 10% como testes de sistema (<a
href="https://dl.acm.org/citation.cfm?id=2207802">link</a>, Cap√≠tulo
3).</p>
<p>Neste cap√≠tulo, vamos estudar os tr√™s tipos de testes da pir√¢mide de
testes. O espa√ßo que dedicaremos a cada teste tamb√©m ser√° compat√≠vel com
seu espa√ßo na pir√¢mide. Ou seja, falaremos mais de testes de unidade do
que de testes de sistema, pois os primeiros s√£o muito mais comuns. Antes
de come√ßar de fato, gostar√≠amos de relembrar alguns conceitos que
apresentamos na Introdu√ß√£o. Diz-se que um c√≥digo possui um
<strong>defeito</strong> ‚Äî ou um <strong>bug</strong>, de modo mais
informal ‚Äî quando ele n√£o est√° de acordo com a sua especifica√ß√£o. Se um
c√≥digo com defeito for executado e levar o programa a apresentar um
resultado ou comportamento incorreto, dizemos que ocorreu uma
<strong>falha</strong> (<em>failure</em>, em ingl√™s).</p>
<h2 data-number="8.2" id="testes-de-unidade"><span
class="header-section-number">8.2</span> Testes de Unidade <a
href="#testes-de-unidade" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Testes de unidade s√£o testes automatizados de pequenas unidades de
c√≥digo, normalmente classes, as quais s√£o testadas de forma isolada do
restante do sistema. Um teste de unidade √© um programa que chama m√©todos
de uma classe e verifica se eles retornam os resultados esperados.
Assim, quando se usa testes de unidades, o c√≥digo de um sistema pode ser
dividido em dois grupos: um conjunto de classes ‚Äî que implementam os
requisitos do sistema ‚Äî e um conjunto de testes, conforme ilustrado na
pr√≥xima figura.</p>
<figure>
<img src="figs/cap8/testes-classes-unidade.svg" style="width:55.0%"
alt="Correspond√™ncia entre classes e testes" />
<figcaption aria-hidden="true">Correspond√™ncia entre classes e
testes</figcaption>
</figure>
<p>A figura mostra um sistema com <em>n</em> classes e <em>m</em>
testes. Como pode ser observado, n√£o existe uma correspond√™ncia de 1
para 1 entre classes e testes. Por exemplo, uma classe pode ter mais de
um teste. √â o caso da classe C1, que √© testada por T1 e T2.
Provavelmente, isso ocorre porque C1 √© uma classe importante, que
precisa ser testada em diferentes contextos. Por outro lado, C2 n√£o
possui testes, ou porque os desenvolvedores esqueceram de implementar ou
porque ela √© uma classe menos importante.</p>
<p> Testes de unidade s√£o implementados usando-se frameworks constru√≠dos
especificamente para esse fim. Os mais conhecidos s√£o chamados de
frameworks <strong>xUnit</strong>, onde o <em>x</em> designa a linguagem
usada na implementa√ß√£o dos testes. O primeiro desses frameworks ‚Äî
chamado sUnit ‚Äî foi implementado por Kent Beck no final da d√©cada de 80
para Smalltalk. Neste cap√≠tulo, nossos testes ser√£o implementados em
Java, usando o <strong>JUnit</strong>. A primeira vers√£o do JUnit foi
implementada em conjunto por Kent Beck e Erich Gamma, em 1997, durante
uma viagem de avi√£o entre a Su√≠√ßa e os EUA.</p>
<p>Hoje, existem vers√µes de frameworks xUnit para as principais
linguagens. Logo, uma das vantagens de testes de unidade √© que os
desenvolvedores n√£o precisam aprender uma nova linguagem de programa√ß√£o,
pois os testes s√£o implementados na mesma linguagem do sistema que
pretende-se testar.</p>
<p>Para explicar os conceitos de testes de unidade, vamos usar uma
classe <code>Stack</code>:</p>
<pre><code>import java.util.ArrayList;
import java.util.EmptyStackException;

public class Stack&lt;T&gt; {

  private ArrayList&lt;T&gt; elements = new ArrayList&lt;T&gt;();
  private int size = 0;

  public int size() {
    return size;
  }

  public boolean isEmpty() {
    return (size == 0);
  }

  public void push(T elem) {
    elements.add(elem);
    size++;
  }

  public T pop() throws EmptyStackException {
    if (isEmpty())
      throw new EmptyStackException();
    T elem = elements.remove(size-1);
    size--;
    return elem;
  }
}</code></pre>
<p>JUnit permite implementar classes que v√£o testar ‚Äî de forma
autom√°tica ‚Äî classes da aplica√ß√£o, como a classe <code>Stack</code>. Por
conven√ß√£o, classes de teste t√™m o mesmo nome das classes testadas, mas
com um sufixo <code>Test</code>. Portanto, nossa primeira classe de
teste vai se chamar <code>StackTest</code>. J√° os m√©todos de teste
come√ßam com o prefixo <code>test</code> e devem, obrigatoriamente,
atender √†s seguintes condi√ß√µes: (1) serem p√∫blicos, pois eles ser√£o
chamados pelo JUnit; (2) n√£o possu√≠rem par√¢metros; (3) possu√≠rem a
anota√ß√£o <code>@Test</code>, a qual identifica m√©todos que dever√£o ser
executados durante um teste.</p>
<p>Mostramos a seguir nosso primeiro teste de unidade:</p>
<pre><code>import org.junit.Test;
import static org.junit.Assert.assertTrue;

public class StackTest {

  @Test
  public void testEmptyStack() {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    boolean empty = stack.isEmpty();
    assertTrue(empty);
  }

}</code></pre>
<p>Nessa primeira vers√£o, a classe <code>StackTest</code> possui um
√∫nico m√©todo de teste, p√∫blico, anotado com <code>@Test</code> e chamado
<code>testEmptyStack()</code>. Esse m√©todo apenas cria uma pilha e testa
se ela est√° vazia.</p>
<p>M√©todos de teste t√™m a seguinte estrutura:</p>
<ul>
<li><p>Primeiro, cria-se o contexto do teste, tamb√©m chamado de
<strong>fixture</strong>. Para isso, deve-se instanciar os objetos que
se pretende testar e, se for o caso, inicializ√°-los. No nosso primeiro
exemplo, essa parte do teste inclui apenas a cria√ß√£o de uma pilha de
nome <code>stack</code>.</p></li>
<li><p>Em seguida, o teste deve chamar um dos m√©todos da classe que est√°
sendo testada. No exemplo, chamamos o m√©todo <code>isEmpty()</code> e
armazenamos o seu resultado em uma vari√°vel local.</p></li>
<li><p>Por fim, devemos testar se o resultado do m√©todo √© aquele
esperado. Para isso, deve-se usar um comando chamado
<strong>assert</strong>. Na verdade, o JUnit oferece diversas varia√ß√µes
de <code>assert</code>, mas todas t√™m o mesmo objetivo: testar se um
determinado resultado √© igual a um valor esperado. No exemplo, usamos
<code>assertTrue</code>, que verifica se o valor passado como par√¢metro
√© verdadeiro.</p></li>
</ul>
<p> IDEs oferecem op√ß√µes para rodar apenas os testes de um sistema, por
exemplo, por meio de uma op√ß√£o de menu chamada <q>Run as Test</q>. Ou
seja, se o desenvolvedor chamar <q>Run</q>, ele ir√° executar o seu
programa normalmente, come√ßando pelo m√©todo <code>main</code>. No
entanto, se ele optar pela op√ß√£o <q>Run as Test</q> ele n√£o ir√° executar
o programa, mas apenas os seus testes de unidade.</p>
<p>A pr√≥xima figura mostra o resultado da execu√ß√£o do nosso primeiro
teste. O resultado √© mostrado na pr√≥pria IDE e a barra verde informa que
todos os testes passaram. Pode-se observar tamb√©m que o teste roda
rapidamente, em 0.025 segundos.</p>
<p><img src="figs/cap8/run1.png" style="width:80.0%" /></p>
<p>Por√©m, suponha que tiv√©ssemos cometido um erro na implementa√ß√£o da
classe <code>Stack</code>. Por exemplo, suponha que o atributo
<code>size</code> fosse inicializado com o valor 1, em vez de zero.
Nesse caso, a execu√ß√£o dos testes iria falhar, como mostrado pela barra
vermelha na IDE:</p>
<p><img src="figs/cap8/run2.png" style="width:80.0%" /></p>
<p>A mensagem de erro informa que houve uma falha durante a execu√ß√£o de
<code>testEmptyStack</code>. Falha (<em>failure</em>) √© o termo usado
pelo JUnit para indicar testes cujo comando <code>assert</code> n√£o foi
satisfeito. Em uma outra janela da IDE, pode-se descobrir que a asser√ß√£o
respons√°vel pela falha encontra-se na linha 19 do arquivo
<code>StackTest.java</code>.</p>
<p><img src="figs/cap8/run3.png" style="width:80.0%" /></p>
<p>Para concluir, vamos mostrar o c√≥digo completo do teste de
unidade:</p>
<pre><code>import org.junit.Test;
import org.junit.Before;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertEquals;

public class StackTest {

  Stack&lt;Integer&gt; stack;

  @Before
  public void init() {
    stack = new Stack&lt;&gt;();
  }

  @Test
  public void testEmptyStack() {
    assertTrue(stack.isEmpty());
  }

  @Test
  public void testNotEmptyStack() {
    stack.push(10);
    assertFalse(stack.isEmpty());
  }

  @Test
  public void testSizeStack() {
    stack.push(10);
    stack.push(20);
    stack.push(30);
    int size = stack.size();
    assertEquals(3,size);
  }

  @Test
  public void testPushPopStack() {
    stack.push(10);
    stack.push(20);
    stack.push(30);
    int result = stack.pop();
    result = stack.pop();
    assertEquals(20,result);
  }

  @Test(expected = java.util.EmptyStackException.class)
  public void testEmptyStackException() {
    stack.push(10);
    int result = stack.pop();
    result = stack.pop();
  }

}</code></pre>
<p>A classe <code>StackTest</code> tem cinco m√©todos de teste ‚Äî todos
com anota√ß√µes <code>@Test</code>. Existe ainda um m√©todo, chamado
<code>init()</code>, com uma anota√ß√£o <code>@Before</code>. Esse m√©todo
√© executado pelo JUnit antes de qualquer m√©todo de teste. O JUnit
funciona do seguinte modo: para cada classe de teste, ele chama cada um
de seus m√©todos <code>@Test</code>. Cada m√©todo executa em uma inst√¢ncia
diferente da classe de teste. Ou seja, antes de chamar um m√©todo
<code>@Test</code>, o JUnit instancia um objeto da sua classe. Se essa
classe tiver um m√©todo <code>@Before</code>, ele √© executado antes do
m√©todo <code>@Test</code>. No exemplo, usamos um m√©todo
<code>@Before</code> para criar uma inst√¢ncia de <code>Stack</code>, a
qual √© usada depois pelos m√©todos <code>@Test</code>. Assim, evitamos
repetir esse c√≥digo de instancia√ß√£o nos testes.</p>
<p>Para ficar um pouco mais claro, mostramos a seguir o algoritmo usado
pelo JUnit para executar os testes de um programa:</p>
<pre><code>para cada classe de teste TC
  para cada m√©todo m de TC com anota√ß√£o @Test
    o = new TC();       // instancia objeto de teste
    se TC possui um m√©todo b com anota√ß√£o @Before
         ent√£o o.b();   // chama m√©todo @Before
    o.m();              // chama m√©todo @Test</code></pre>
<p>Voltando √† classe <code>StackTest</code>, outro m√©todo interessante √©
aquele que testa a situa√ß√£o na qual a execu√ß√£o de um <code>pop()</code>
levanta uma <code>EmptyStackException</code>. Veja que esse m√©todo ‚Äî o
√∫ltimo do nosso teste ‚Äî n√£o possui <code>assert</code>. O motivo √© que
um <code>assert</code> seria um c√≥digo morto na sua implementa√ß√£o. A
chamada de um <code>pop()</code> em uma pilha vazia terminaria a
execu√ß√£o do m√©todo com uma exce√ß√£o <code>EmptyStackException</code>. Ou
seja, o <code>assert</code> n√£o seria executado. Por isso, a anota√ß√£o
<code>@Test</code> tem um atributo especial que serve para especificar a
exce√ß√£o que deve ser levantada pelo m√©todo de teste. Em resumo,
<code>testEmptyStackException</code> vai passar se a sua execu√ß√£o
levantar uma <code>EmptyStackException</code>. Caso contr√°rio, ele vai
falhar.</p>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo fonte de <code>Stack</code> e
<code>StackTest</code> est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/3601acd0b32a1d0a85b4a81a43af4284">link</a>.</p>
<p><strong>Aviso:</strong> O framework JUnit possui v√°rias vers√µes.
Neste cap√≠tulo, vamos usar a vers√£o 4.12.</p>
<h3 data-number="8.2.1" id="defini√ß√µes"><span
class="header-section-number">8.2.1</span> Defini√ß√µes <a
href="#defini√ß√µes" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>Antes de avan√ßar, vamos apresentar algumas defini√ß√µes:</p>
<ul>
<li><p><strong>Teste</strong>: m√©todo que implementa um teste. O nome
deriva da anota√ß√£o <code>@Test</code>. S√£o tamb√©m chamados de m√©todo de
teste (<em>test method</em>).</p></li>
<li><p><strong>Fixture</strong>: estado do sistema que ser√° testado por
um ou mais m√©todos de teste, incluindo dados, objetos, etc. O termo √©
reusado da ind√∫stria manufatureira, onde <em>fixture</em> √© um
equipamento que <q>fixa</q> uma pe√ßa que se pretende construir (veja uma
<a href="https://en.wikipedia.org/wiki/Fixture_(tool)">foto</a> na
Wikip√©dia). No contexto de testes de unidade, a fun√ß√£o de uma fixture √©
<q>fixar</q> o estado ‚Äî isto √©, os dados e objetos ‚Äî exercitados no
teste.</p></li>
<li><p><strong>Casos de Teste (Test Case)</strong>: classe com os
m√©todos de teste. O nome tem origem nas primeiras vers√µes do JUnit.
Nessas vers√µes, os m√©todos de testes eram implementados em classes que
herdavam de uma classe <code>TestCase</code>.</p></li>
<li><p><strong>Su√≠te de Testes (Test Suite)</strong>: conjunto de casos
de teste, os quais s√£o executados pelo framework de testes de unidade
(que no nosso caso √© o JUnit).</p></li>
<li><p><strong>Sistema sob Teste (System Under Test, SUT)</strong>:
sistema que est√° sendo testado. √â um nome gen√©rico, usado tamb√©m em
outros tipos de testes, n√£o necessariamente de unidades. √Äs vezes,
usa-se tamb√©m o termo <strong>c√≥digo de produ√ß√£o</strong>, ou seja,
c√≥digo que vai ser executado pelos clientes do sistema.</p></li>
</ul>
<h3 data-number="8.2.2" id="quando-escrever-testes-de-unidade"><span
class="header-section-number">8.2.2</span> Quando Escrever Testes de
Unidade? <a href="#quando-escrever-testes-de-unidade"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>Existem duas respostas principais para essa pergunta. Primeiro,
pode-se escrever os testes ap√≥s implementar uma pequena funcionalidade.
Por exemplo, pode-se implementar alguns m√©todos e, em seguida, seus
testes, que devem passar. Isto √©, pode-se programar um pouco e escrever
testes; programar mais um pouco e escrever novos testes, etc.</p>
<p>Alternativamente, pode-se escrever os testes primeiro, antes de
qualquer c√≥digo de produ√ß√£o. No in√≠cio, esses testes n√£o v√£o passar,
pois isso somente vai acontecer depois que o c√≥digo sob teste for
implementado. Em outras palavras, inicia-se com um c√≥digo que apenas
compila e cujos testes, portanto, falham. Implementa-se ent√£o o c√≥digo
de produ√ß√£o e testa-se novamente. Agora, os testes devem passar. Esse
estilo de desenvolvimento chama-se <strong>Test-Driven
Development</strong>. Iremos discuti-lo com detalhes na Se√ß√£o 8.7.</p>
<p>No entanto, existem duas respostas complementares para a quest√£o
sobre quando devemos escrever testes. Por exemplo, quando um usu√°rio
reportar um bug, pode-se come√ßar sua an√°lise escrevendo um teste que
reproduz o bug e que, portanto, vai falhar. No passo seguinte, deve-se
corrigir o bug. Se a corre√ß√£o for bem sucedida, o teste vai passar e
ganhamos mais um teste para a su√≠te de testes.</p>
<p>Pode-se escrever testes tamb√©m quando se estiver depurando um trecho
de c√≥digo. Por exemplo, evite escrever um
<code>System.out.println</code> para testar manualmente o resultado de
um m√©todo. Em vez disso, escreva um m√©todo de teste. Quando se usa um
comando <code>println</code>, ele em algum momento √© removido. J√° um
teste tem a vantagem de contribuir com mais um teste para a su√≠te de
testes.</p>
<p>Ainda sobre a pergunta principal desta se√ß√£o, o que n√£o √©
recomend√°vel √© deixar para implementar todos os testes ap√≥s o sistema
ficar pronto ‚Äî tal como ocorria, por exemplo, com desenvolvimento em
Waterfall. Se deixarmos para escrever os testes por √∫ltimo, eles podem
ser constru√≠dos de forma apressada e com baixa qualidade. Ou ent√£o pode
ser que eles nem sejam implementados, pois o sistema j√° estar√°
funcionando e novas prioridades podem ter sido alocadas para o time de
desenvolvimento. Por fim, n√£o √© recomend√°vel que os testes sejam
implementados por um outro time ou mesmo por uma outra empresa de
desenvolvimento. Em vez disso, recomenda-se que o desenvolvedor de uma
classe seja tamb√©m respons√°vel pela implementa√ß√£o de seus testes de
unidade.</p>
<h3 data-number="8.2.3" id="benef√≠cios"><span
class="header-section-number">8.2.3</span> Benef√≠cios <a
href="#benef√≠cios" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>O principal benef√≠cio de testes de unidade √© encontrar bugs, ainda na
fase de desenvolvimento e antes que o c√≥digo entre em produ√ß√£o, quando
os custos de corre√ß√£o e os preju√≠zos podem ser maiores. Portanto, se um
sistema de software tem bons testes, √© mais dif√≠cil que os usu√°rios
finais sejam surpreendidos com bugs.</p>
<p> Por√©m, existem dois outros benef√≠cios que tamb√©m s√£o muito
importantes. Primeiro, testes de unidade funcionam como uma rede de
prote√ß√£o contra <strong>regress√µes</strong> no c√≥digo. Dizemos que uma
regress√£o ocorre quando uma modifica√ß√£o realizada no c√≥digo de um
sistema ‚Äî seja para corrigir um bug, implementar uma nova funcionalidade
ou realizar uma refatora√ß√£o ‚Äî acaba por introduzir um bug ou outro
problema semelhante no c√≥digo. Ou seja, dizemos que o c√≥digo regrediu
porque algo que estava funcionando deixou de funcionar ap√≥s a mudan√ßa
que foi realizada. Regress√µes s√£o mais raras quando se tem bons testes.
Para isso, ap√≥s concluir uma mudan√ßa o desenvolvedor deve rodar a su√≠te
de testes. Se a mudan√ßa tiver introduzido alguma regress√£o, existe uma
boa chance de que ela seja detectada pelos testes. Ou seja, antes da
mudan√ßa os testes estavam passando, mas ap√≥s a mudan√ßa algum teste
come√ßou a falhar.</p>
<p>Al√©m de serem usados para detec√ß√£o prematura de bugs e regress√µes no
c√≥digo, testes de unidade tamb√©m ajudam na documenta√ß√£o e especifica√ß√£o
do c√≥digo de produ√ß√£o. De fato, ao olhar e analisar os testes
implementados em <code>StackTest</code> podemos entender diversos
aspectos do comportamento da classe <code>Stack</code>. Por isso, muitas
vezes, antes de manter um c√≥digo com o qual ele n√£o tenha familiaridade,
um desenvolvedor come√ßa analisando os seus testes.</p>
<p> </p>
<p><strong>Mundo Real</strong>: Dentre as pr√°ticas de desenvolvimento
propostas originalmente por m√©todos √°geis, testes de unidade √©
provavelmente a que alcan√ßou o maior impacto e que √© mais largamente
usada. Hoje, os mais diversos sistemas de software, de empresas dos mais
diferentes tamanhos, s√£o desenvolvidos com o apoio de testes de unidade.
A seguir, vamos destacar os casos de duas grandes empresas de software:
Google e Facebook. Os coment√°rios foram extra√≠dos de artigos que
documentam o processo e as pr√°ticas de desenvolvimento de software
dessas empresas:</p>
<ul>
<li><p><q>Testes de unidade s√£o fortemente encorajados e amplamente
praticados no Google. Todo c√≥digo de produ√ß√£o deve ter testes de unidade
e nossa ferramenta de revis√£o de c√≥digo automaticamente destaca c√≥digo
submetido sem os correspondentes testes. Os revisores de c√≥digo
normalmente exigem que qualquer mudan√ßa que adiciona novas
funcionalidades deve tamb√©m adicionar os respectivos testes.</q> (<a
href="https://arxiv.org/abs/1702.01715">link</a>)</p></li>
<li><p><q>No Facebook, engenheiros s√£o respons√°veis pelos testes de
unidade de qualquer c√≥digo novo que eles desenvolvam. Al√©m disso, esse
c√≥digo deve passar por testes de regress√£o, os quais s√£o executados
automaticamente, como parte dos processos de commit e push.</q> (<a
href="https://doi.org/10.1109/MIC.2013.25">link</a>)</p></li>
</ul>
<h2 data-number="8.3" id="princ√≠pios-e-smells"><span
class="header-section-number">8.3</span> Princ√≠pios e Smells <a
href="#princ√≠pios-e-smells" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>Nesta se√ß√£o, vamos agrupar a apresenta√ß√£o de princ√≠pios e
anti-padr√µes para implementa√ß√£o de testes de unidade. O objetivo √©
discutir quest√µes importantes para a implementa√ß√£o de testes que tenham
qualidade e que possam ser facilmente mantidos e entendidos.</p>
<h3 data-number="8.3.1" id="princ√≠pios-first"><span
class="header-section-number">8.3.1</span> Princ√≠pios FIRST <a
href="#princ√≠pios-first" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Testes de unidades devem satisfazer √†s seguintes propriedades (cujas
iniciais d√£o origem √† palavra FIRST, em Ingl√™s):</p>
<p><strong>R√°pidos (Fast)</strong>: desenvolvedores devem executar
testes de unidades frequentemente, para obter feedback r√°pido sobre bugs
e regress√µes no c√≥digo. Por isso, √© importante que eles sejam executados
rapidamente, em quest√µes de milissegundos. Se isso n√£o for poss√≠vel,
pode-se dividir uma su√≠te de testes em dois grupos: testes que executam
rapidamente e que, portanto, ser√£o frequentemente chamados; e testes
mais demorados, que ser√£o, por exemplo, executados uma vez por dia.</p>
<p><strong>Independentes</strong>: a ordem de execu√ß√£o dos testes de
unidade n√£o √© importante. Para quaisquer testes T1 e T2, a execu√ß√£o de
T1 seguida de T2 deve ter o mesmo resultado da execu√ß√£o de T2 e depois
T1. Pode acontecer ainda de T1 e T2 serem executados de forma
concorrente. Para que os testes sejam independentes, T1 n√£o deve alterar
alguma parte do estado global do sistema que depois ser√° usada para
computar o resultado de T2 e vice-versa.</p>
<p> <strong>Determin√≠sticos (Repeatable)</strong>: testes de unidade
devem ter sempre o mesmo resultado. Ou seja, se um teste T √© chamado
<em>n</em> vezes, o resultado deve ser o mesmo nas <em>n</em> execu√ß√µes.
Isto √©, ou T passa em todas as execu√ß√µes; ou ele sempre falha. Testes
com resultados n√£o-determin√≠sticos s√£o chamados de <strong>Testes
Flaky</strong> (ou <strong>Testes Err√°ticos</strong>). Concorr√™ncia √©
uma das principais respons√°veis por comportamento flaky. Um exemplo √©
mostrado a seguir:</p>
<pre><code>@Test
public void exemploTesteFlaky {
  TaskResult resultado;
  MyMath m = new MyMath();
  m.asyncPI(10,resultado);
  Thread.sleep(1000);
  assertEquals(3.1415926535, resultado.get());
}</code></pre>
<p>Esse teste chama uma fun√ß√£o que calcula o valor de PI, com uma certa
precis√£o, e de forma ass√≠ncrona ‚Äî isto √©, a fun√ß√£o realiza o seu c√°lculo
em uma nova thread, que ela mesmo cria internamente. No exemplo, a
precis√£o requerida s√£o 10 casas decimais. O teste faz uso de um
<code>sleep</code> para esperar que a fun√ß√£o ass√≠ncrona termine. No
entanto, isso torna o seu comportamento n√£o-determin√≠stico: se a fun√ß√£o
terminar antes de 1000 milissegundos, o teste ir√° passar; mas se a
execu√ß√£o, por alguma circunst√¢ncia particular, demorar mais, o teste ir√°
falhar. Uma poss√≠vel alternativa seria testar apenas a vers√£o s√≠ncrona
da fun√ß√£o. Se essa vers√£o n√£o existir, um refactoring poderia ser
realizado para extra√≠-la do c√≥digo da vers√£o ass√≠ncrona. Na Se√ß√£o 8.5,
iremos discutir mais sobre quest√µes relativas √† testabilidade do c√≥digo
de produ√ß√£o.</p>
<p>Pode parecer que testes flaky s√£o raros, mas um estudo divulgado pelo
Google, com seus pr√≥prios testes, revelou que cerca de 16% deles est√£o
sujeitos a resultados n√£o-determin√≠sticos (<a
href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html">link</a>).
Ou seja, esses testes podem falhar n√£o porque um bug foi introduzido no
c√≥digo, mas por causa de eventos n√£o determin√≠sticos, como uma thread
que levou mais tempo para executar. Testes flaky s√£o ruins porque eles
atrasam o desenvolvimento: os programadores perdem um tempo para
investigar a falha, para ent√£o descobrir que ela √© um alarme falso.</p>
<p><strong>Auto-verific√°veis (Self-checking)</strong>: O resultado de um
teste de unidades deve ser facilmente verific√°vel. Para interpretar o
resultado do teste, o desenvolvedor n√£o deve, por exemplo, ter que abrir
e analisar um arquivo de sa√≠da ou fornecer dados manualmente. Em vez
disso, o resultado dos testes deve ser bin√°rio e mostrado na IDE,
normalmente por meio de componentes que ficam com a cor verde (para
indicar que todos os testes passaram) ou com a cor vermelha (para
indicar que algum teste falhou). Adicionalmente, quando um teste falha,
deve ser poss√≠vel identificar essa falha de forma r√°pida, incluindo a
localiza√ß√£o do comando <code>assert</code> que falhou.</p>
<p><strong>Escritos o quanto antes (Timely)</strong>, se poss√≠vel antes
mesmo do c√≥digo que vai ser testado, como j√° comentamos no final da
Se√ß√£o 8.2 e iremos discutir com mais profundidade na se√ß√£o sobre
Desenvolvimento Dirigido por Testes (Se√ß√£o 8.7).</p>
<h3 data-number="8.3.2" id="test-smells"><span
class="header-section-number">8.3.2</span> Test Smells <a
href="#test-smells" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p><strong>Test Smells</strong> representam estruturas e caracter√≠sticas
<q>preocupantes</q> no c√≥digo de testes de unidade, as quais, a
princ√≠pio deveriam ser evitadas. O nome √© uma adapta√ß√£o, para o contexto
de testes, do conceito de <strong>Code Smells</strong> ou <strong>Bad
Smells</strong>, que iremos estudar no Cap√≠tulo 9. No entanto, neste
cap√≠tulo, vamos aproveitar e j√° comentar sobre smells que podem ocorrer
no c√≥digo de testes.</p>
<p>Um <strong>Teste Obscuro</strong> √© um teste longo, complexo e
dif√≠cil de entender. Como afirmamos, testes devem ser usados tamb√©m para
auxiliar na documenta√ß√£o do sistema sob teste. Por isso, √© importante
que eles tenham uma l√≥gica clara e de r√°pido entendimento. Idealmente,
um teste deve, por exemplo, testar um √∫nico requisito do sistema sob
teste.</p>
<p>Um <strong>Teste com L√≥gica Condicional</strong> inclui c√≥digo que
pode ou n√£o ser executado. Isto √©, s√£o testes com comandos
<code>if</code> ou la√ßos, enquanto que o ideal √© que os testes de
unidade sejam lineares. L√≥gica condicional em testes √© considerada um
smell porque ela prejudica o entendimento do teste.</p>
<p><strong>Duplica√ß√£o de C√≥digo em Testes</strong> ocorre, como o
pr√≥prio nome sugere, quando temos c√≥digo repetido em diversos m√©todos de
teste.</p>
<p>No entanto, um test smell n√£o deve ser interpretado ao p√© da letra,
isto √©, como sendo uma situa√ß√£o que deve ser evitada a todo custo. Em
vez disso, eles devem ser considerados como um alerta para os
implementadores do teste. Ao identificar um test smell, os
desenvolvedores devem refletir sobre se n√£o √© poss√≠vel ter um teste mais
simples e menor, com um c√≥digo linear e sem duplica√ß√£o de comandos.</p>
<p>Por fim, assim como ocorre com c√≥digo de produ√ß√£o, c√≥digo de testes
deve ser frequentemente refatorado, de modo a garantir que ele permane√ßa
simples, f√°cil de entender e livre dos test smells que comentamos nesta
se√ß√£o.</p>
<h3 data-number="8.3.3" id="n√∫mero-de-assert-por-teste"><span
class="header-section-number">8.3.3</span> N√∫mero de assert por Teste <a
href="#n√∫mero-de-assert-por-teste" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Alguns autores (<a
href="https://dl.acm.org/citation.cfm?id=1388398">link</a>) recomendam
que deve existir no m√°ximo um <code>assert</code> por teste. Ou seja,
eles recomendam escrever um c√≥digo como o seguinte.</p>
<pre><code>@Test
public void testEmptyStack() {
  assertTrue(stack.isEmpty());
}

@Test
public void testNotEmptyStack() {
  stack.push(10);
  assertFalse(stack.isEmpty());
}</code></pre>
<p>Em outras palavras, <em>n√£o</em> se recomenda usar dois comandos
<code>assert</code> no mesmo m√©todo, como no c√≥digo a seguir:</p>
<pre><code>@Test
public void testEmptyStack() {
  assertTrue(stack.isEmpty());
  stack.push(10);
  assertFalse(stack.isEmpty());
}</code></pre>
<p>O primeiro exemplo, que divide o teste de pilha vazia em dois testes,
tende a ser mais leg√≠vel e f√°cil de entender do que o segundo, que faz
tudo em um √∫nico teste. Al√©m disso, quando o teste do primeiro exemplo
falha, √© mais simples detectar o motivo da falha do que no segundo
exemplo, que pode falhar por dois motivos.</p>
<p>No entanto, n√£o devemos ser dogm√°ticos no emprego dessa regra (<a
href="https://dl.acm.org/citation.cfm?id=1076526">link</a>, Cap√≠tulo 4).
O motivo √© que existem casos nos quais justifica-se ter mais de um
<code>assert</code> por m√©todo. Por exemplo, suponha que precisamos
testar uma fun√ß√£o <code>getBook</code> que retorna um objeto com dados
de um livro, incluindo t√≠tulo, autor, ano e editora. Nesse caso,
justifica-se ter quatro comandos <code>assert</code> no mesmo teste,
cada um verificando um dos campos do objeto retornado pela fun√ß√£o, como
mostra o seguinte c√≥digo.</p>
<pre><code>@Test
public void testBookService() {
  BookService bs = new BookService();
  Book b = bs.getBook(1234);
  assertEquals(&quot;Engenharia Software Moderna&quot;, b.getTitle());
  assertEquals(&quot;Marco Tulio Valente&quot;, b.getAuthor());
  assertEquals(&quot;2020&quot;, b.getYear());
  assertEquals(&quot;ASERG/DCC/UFMG&quot;, b.getPublisher());
}</code></pre>
<p>Uma segunda exce√ß√£o √© quando temos um m√©todo simples, que pode ser
testado por meio de um √∫nico <code>assert</code>. Para ilustrar,
mostramos o teste da fun√ß√£o <code>repeat</code> da classe
<code>Strings</code> da biblioteca <code>google/guava</code> (<a
href="https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StringsTest.java">link</a>):</p>
<pre><code>@Test
public void testRepeat() {
  String input = &quot;20&quot;;
  assertEquals(&quot;&quot;, Strings.repeat(input,0));
  assertEquals(&quot;20&quot;, Strings.repeat(input,1));
  assertEquals(&quot;2020&quot;, Strings.repeat(input,2));
  assertEquals(&quot;202020&quot;, Strings.repeat(input,3));
  ...
}</code></pre>
<p>Nesse teste, temos quatro comandos <code>assertEquals</code>, os
quais testam, respectivamente, o resultado da repeti√ß√£o de uma
determinada string zero, uma, duas e tr√™s vezes.</p>
<h2 data-number="8.4" id="cobertura-de-testes"><span
class="header-section-number">8.4</span> Cobertura de Testes <a
href="#cobertura-de-testes" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p> Cobertura de testes √© uma m√©trica que ajuda a definir o n√∫mero de
testes que precisamos escrever para um programa. Ela mede o percentual
de comandos de um programa que s√£o cobertos por testes, isto √©:</p>
<blockquote>
<p>cobertura de testes = (n√∫mero de comandos executados pelos testes) /
(total de comandos do programa)</p>
</blockquote>
<p>Existem ferramentas para c√°lculo de cobertura de testes. Na pr√≥xima
figura, mostramos um exemplo de uso da ferramenta que acompanha a IDE
Eclipse. As linhas com fundo verde ‚Äî coloridas automaticamente por essa
ferramenta ‚Äî indicam as linhas cobertas pelos cinco testes implementados
em <code>StackTest</code>. As √∫nicas linhas n√£o coloridas de verde s√£o
respons√°veis pela assinatura dos m√©todos de <code>Stack</code> e,
portanto, n√£o correspondem a comandos execut√°veis. Assim, a cobertura
dos testes do nosso primeiro exemplo √© de 100%, pois a execu√ß√£o dos
m√©todos de testes resulta na execu√ß√£o de todos os comandos da classe
<code>Stack</code>.</p>
<p><img src="figs/cap8/cobertura1.png" style="width:70.0%" /></p>
<p>Suponha agora que n√£o tiv√©ssemos implementado
<code>testEmptyStackException</code>. Isto √©, n√£o ir√≠amos testar o
levantamento de uma exce√ß√£o pelo m√©todo <code>pop()</code>, quando
chamado com uma pilha vazia. Nesse caso, a cobertura dos testes cairia
para 92.9%, como ilustrado a seguir:</p>
<p><img src="figs/cap8/cobertura3.png" style="width:100.0%" /></p>
<p>Nesse caso, a ferramenta de c√°lculo de cobertura de testes marcaria
as linhas da classe <code>Stack</code> da seguinte forma:</p>
<p><img src="figs/cap8/cobertura2.png" style="width:70.0%" /></p>
<p>Como afirmamos, as linhas verdes s√£o cobertas pela execu√ß√£o dos
testes. Por√©m, existe um comando marcado de amarelo. Essa cor indica que
o comando √© um desvio (no caso, um <code>if</code>) e que apenas um dos
caminhos poss√≠veis do desvio (no caso, o caminho <code>false</code>) foi
exercitado pelos testes de unidade. Por fim, o leitor j√° deve ter
observado que existe uma linha em vermelho. Essa cor indica linhas que
n√£o foram cobertas pelos testes de unidade.</p>
<p>Em Java, ferramentas de cobertura de testes trabalham instrumentando
os bytecodes gerados pelo compilador da linguagem. Como mostrado na
figura com as estat√≠sticas de cobertura, o programa anterior, ap√≥s
compilado, possui 52 instru√ß√µes cobertas por testes de unidade, de um
total de 56 instru√ß√µes. Portanto, sua cobertura √© 52 / 56 = 92.9%.</p>
<h3 data-number="8.4.1" id="qual-a-cobertura-de-testes-ideal"><span
class="header-section-number">8.4.1</span> Qual a Cobertura de Testes
Ideal? <a href="#qual-a-cobertura-de-testes-ideal" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>N√£o existe um n√∫mero m√°gico e absoluto para cobertura de testes. A
resposta varia de projeto para projeto, dependendo da complexidade dos
requisitos, da criticidade do projeto, etc. Mas, em geral, n√£o precisa
ser 100%, pois sempre existem m√©todos triviais em um sistema; por
exemplo, <em>getters</em> e <em>setters</em>. Tamb√©m sempre temos
m√©todos cujo teste √© mais desafiador, como m√©todos de interface com o
usu√°rio ou m√©todos com comportamento ass√≠ncrono.</p>
<p>Portanto, n√£o recomenda-se fixar um valor de cobertura que tenha que
ser sempre atingido. Em vez disso, deve-se monitorar a evolu√ß√£o dos
valores de cobertura ao longo do tempo, para verificar se os
desenvolvedores, por exemplo, n√£o est√£o relaxando na escrita de testes.
Recomenda-se tamb√©m avaliar cuidadosamente os trechos n√£o cobertos por
testes, para confirmar que eles n√£o s√£o relevantes ou ent√£o s√£o dif√≠ceis
de serem testados.</p>
<p>Feitas essas considera√ß√µes, times que valorizam a escrita de testes
costumam atingir facilmente valores de cobertura pr√≥ximos de 70% (<a
href="https://dl.acm.org/citation.cfm?id=2808995">link</a>). Por outro
lado, valores abaixo de 50% tendem a ser preocupantes (<a
href="https://martinfowler.com/bliki/TestCoverage.html">link</a>). Por
fim, mesmo quando se usa TDD, a cobertura de testes costuma n√£o chegar a
100%, embora normalmente fique acima de 90% (<a
href="https://dl.acm.org/citation.cfm?id=2808995">link</a>).</p>
<p></p>
<p><strong>Mundo Real</strong>: Em uma confer√™ncia de desenvolvedores do
Google, em 2014, foram apresentadas algumas estat√≠sticas sobre a
cobertura de testes dos sistemas da empresa (veja os <a
href="https://bit.ly/2VhXlpg">slides</a> e tamb√©m o <a
href="https://youtu.be/4bublRBCLVQ">v√≠deo</a>). Na mediana, os sistemas
do Google tinham 78% de cobertura, em n√≠vel de comandos. Segundo
afirmou-se na palestra, a recomenda√ß√£o seria atingir 85% de cobertura na
maioria dos sistemas, embora essa recomenda√ß√£o n√£o seria <q>escrita em
pedra</q>, ou seja, n√£o teria que ser seguida de forma dogm√°tica.
Mostrou-se tamb√©m que a cobertura variava por linguagem de programa√ß√£o.
A menor cobertura era dos sistemas em C++, um pouco inferior a 60% na
m√©dia dos projetos. A maior foi medida para sistemas implementados em
Python, um pouco acima de 80%.</p>
<h3 data-number="8.4.2"
id="outras-defini√ß√µes-de-cobertura-de-testes"><span
class="header-section-number">8.4.2</span> Outras Defini√ß√µes de
Cobertura de Testes <a href="#outras-defini√ß√µes-de-cobertura-de-testes"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> A defini√ß√£o de m√©trica de cobertura, apresentada acima, foi baseada
em comandos, pois trata-se de sua defini√ß√£o mais comum. Por√©m, existem
defini√ß√µes alternativas, tais como <strong>cobertura de fun√ß√µes</strong>
(percentual de fun√ß√µes que s√£o executadas por um teste),
<strong>cobertura de chamadas de fun√ß√µes</strong> (dentre todas as
linhas de um programa que chamam fun√ß√µes, quantas s√£o, de fato,
exercitadas por testes), <strong>cobertura de branches</strong> (% de
branches de um programa que s√£o executados por testes; um comando
<code>if</code> sempre gera dois branches: quando a condi√ß√£o √©
verdadeira e quando ela √© falsa). Cobertura de comandos e de branches
s√£o tamb√©m chamadas de <strong>Cobertura C0</strong> e <strong>Cobertura
C1</strong>, respectivamente. Para ilustrar a diferen√ßa entre ambas
vamos usar a seguinte classe (primeiro c√≥digo) e seu teste de unidade
(segundo c√≥digo):</p>
<pre><code>public class Math {

  public int abs(int x) {
    if (x &lt; 0) {  
      x = -x;
    }  
    return x;
  }

}</code></pre>
<pre><code>public class MathTest {

  @Test
  public void testAbs() {
    Math m = new Math();
    assertEquals(1,m.abs(-1));
  }

}</code></pre>
<p>Supondo cobertura de comandos, temos uma cobertura de 100%. Por√©m,
supondo uma cobertura de branches, o valor √© 50%, pois dentre as duas
condi√ß√µes poss√≠veis do comando <code>if(x &lt; 0)</code>, testamos
apenas uma delas (a condi√ß√£o verdadeira). Se quisermos ter uma cobertura
de branches de 100% ter√≠amos que adicionar mais um comando
<code>assert</code>, como: <code>assertEquals(1,m.abs(1))</code>. Logo,
cobertura de branches √© mais rigorosa do que cobertura de comandos.</p>
<h2 data-number="8.5" id="testabilidade"><span
class="header-section-number">8.5</span> Testabilidade <a
href="#testabilidade" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Testabilidade √© uma medida de qu√£o f√°cil √© implementar testes para um
sistema. Como vimos, √© importante que os testes sigam os princ√≠pios
FIRST, que eles tenham poucos <code>assert</code> e uma alta cobertura.
No entanto, √© importante tamb√©m que o projeto do c√≥digo de produ√ß√£o
favore√ßa a implementa√ß√£o de testes. O termo em ingl√™s para isso √©
<strong>design for testability</strong>. Em outras palavras, √†s vezes,
parte relevante do esfor√ßo para escrita de bons testes deve ser alocada
no projeto do sistema sob teste e n√£o exatamente no projeto dos
testes.</p>
<p>A boa not√≠cia √© que c√≥digo que segue as propriedades e princ√≠pios de
projeto que discutimos no Cap√≠tulo 5 ‚Äî tais como coes√£o alta,
acoplamento baixo, responsabilidade √∫nica, separa√ß√£o entre apresenta√ß√£o
e modelo, invers√£o de depend√™ncias, Demeter, dentre outros ‚Äî tende a
apresentar boa testabilidade.</p>
<h3 data-number="8.5.1" id="exemplo-servlet"><span
class="header-section-number">8.5.1</span> Exemplo: Servlet <a
href="#exemplo-servlet" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Servlet √© uma tecnologia de Java para implementa√ß√£o de p√°ginas Web
din√¢micas. A seguir mostramos uma servlet que calcula o √≠ndice de massa
corporal de uma pessoa, dado o seu peso e altura. O nosso objetivo √©
did√°tico. Logo, n√£o vamos detalhar todo o protocolo para implementa√ß√£o
de servlets. Al√©m disso, a l√≥gica de dom√≠nio desse exemplo √© simples,
consistindo na seguinte f√≥rmula: <code>peso / (altura * altura)</code>.
Mas tente imaginar que essa l√≥gica poderia ser mais complexa e que,
mesmo assim, a solu√ß√£o que vamos apresentar continuaria v√°lida.</p>
<pre><code>public class IMCServlet extends HttpServlet {

  public void doGet(HttpServletRequest req, 
                    HttpServletResponse res) {
    res.setContentType(&quot;text/html&quot;);
    PrintWriter out = res.getWriter();
    String peso = req.getParameter(&quot;peso&quot;);
    String altura = req.getParameter(&quot;altura&quot;);
      try {
        double p = Double.parseDouble(peso);
        double a = Double.parseDouble(altura);
        double imc = p / (a * a);
        out.println(&quot;√çndice de Massa Corporal (IMC): &quot;+imc);
      }
      catch (NumberFormatException e) {
        out.println(&quot;Dados devem ser num√©ricos&quot;);
      }
  }
}  </code></pre>
<p>Primeiro, veja que n√£o √© simples escrever um teste para
<code>IMCServlet</code>, pois essa classe depende de diversos tipos do
pacote de Servlets de Java. Por exemplo, n√£o √© trivial instanciar um
objeto do tipo <code>IMCServlet</code> e depois chamar
<code>doGet</code>. Se tomarmos esse caminho, ter√≠amos que criar tamb√©m
objetos dos tipos <code>HTTPServletRequest</code> e
<code>HTTPServletResponse</code>, para passar como par√¢metro de
<code>doGet</code>. No entanto, esses dois tipos podem depender de
outros tipos e assim sucessivamente. Portanto, a testabilidade de
<code>IMCServlet</code> √© baixa.</p>
<p>Uma alternativa para testar o exemplo mostrado seria extrair a sua
l√≥gica de dom√≠nio para uma classe separada, como feito no c√≥digo a
seguir. Ou seja, a ideia consiste em separar apresenta√ß√£o (via Servlet)
de l√≥gica de dom√≠nio. Com isso, fica mais f√°cil testar a classe
extra√≠da, chamada <code>IMCModel</code>, pois ela n√£o depende de tipos
relacionados com Servlet. Por exemplo, √© mais f√°cil instanciar um objeto
da classe <code>IMCModel</code> do que da classe
<code>IMCServlet</code>. √â verdade que com essa refatora√ß√£o n√£o vamos
testar o c√≥digo completo. Por√©m, √© melhor testar a parte de dom√≠nio do
sistema do que deixar o c√≥digo inteiramente descoberto de testes.</p>
<pre><code>class IMCModel {
  public double calculaIMC(String p1, String a1) 
                throws NumberFormatException {
    double p = Double.parseDouble(p1);
    double a = Double.parseDouble(a1);
    return p / (a * a);
  }
}

public class IMCServlet extends HttpServlet {
  IMCModel model = new IMCModel();

  public void doGet(HttpServletRequest req, 
                    HttpServletResponse res) {
    res.setContentType(&quot;text/html&quot;);
    PrintWriter out = res.getWriter();
    String peso = req.getParameter(&quot;peso&quot;);
    String altura = req.getParameter(&quot;altura&quot;);
    try {
      double imc = model.calculaIMC(peso, altura);
      out.println(&quot;√çndice de Massa Corporal (IMC): &quot; + imc);
    }
    catch (NumberFormatException e) {
      out.println(&quot;Dados devem ser num√©ricos&quot;);
    }
  }
}  </code></pre>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo dessa servlet est√° dispon√≠vel
neste <a
href="https://gist.github.com/mtov/72a7da4aed79818fbd6aae4e0774d6a5">link</a>.</p>
<h3 data-number="8.5.2" id="exemplo-chamada-ass√≠ncrona"><span
class="header-section-number">8.5.2</span> Exemplo: Chamada Ass√≠ncrona
<a href="#exemplo-chamada-ass√≠ncrona" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>O pr√≥ximo c√≥digo mostra a implementa√ß√£o da fun√ß√£o
<code>asyncPI</code> que mencionamos na Se√ß√£o 8.3 quando tratamos dos
princ√≠pios FIRST e, especificamente, de testes determin√≠sticos. Conforme
explicamos nessa se√ß√£o, n√£o √© simples testar uma fun√ß√£o ass√≠ncrona, pois
seu resultado √© computado por uma thread independente. O exemplo que
mostramos na Se√ß√£o 8.3 usava um sleep para esperar o resultado ficar
dispon√≠vel. Por√©m, o uso desse comando torna o teste
n√£o-determin√≠stico.</p>
<pre><code>public class MyMath {

  public void asyncPI(int prec, TaskResult task) {
    new Thread (new Runnable() {
      public void run() {
        double pi = &quot;calcula PI com precis√£o prec&quot;
        task.setResult(pi);
      }
    }).start();
  }

} </code></pre>
<p>A seguir mostramos uma solu√ß√£o para incrementar a testabilidade dessa
classe. Primeiro, extra√≠mos o c√≥digo que implementa a computa√ß√£o de PI
para uma fun√ß√£o separada, chamada <code>syncPI</code>. Assim, apenas
essa fun√ß√£o seria testada por um teste de unidade. Em suma, vale a
observa√ß√£o que fizemos antes: √© melhor extrair uma fun√ß√£o que seja f√°cil
de ser testada, do que deixar o c√≥digo sem testes.</p>
<pre><code>public class MyMath {
  public double syncPI(int prec) {
    double pi = &quot;calcula PI com precis√£o prec&quot;
    return pi;
  }
  public void asyncPI(int prec, TaskResult task) {
    new Thread (new Runnable() {
      public void run() {
        double pi = syncPI(prec);
        task.setResult(pi);
      }    
    }).start();
  }
}  </code></pre>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo desse exemplo de chamada
ass√≠ncrona est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/a3f73350010758925172a7f433e2ba71">link</a>.</p>
<h2 data-number="8.6" id="mocks"><span
class="header-section-number">8.6</span> Mocks <a href="#mocks"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Para explicar o papel desempenhado por mocks em testes de unidade,
vamos come√ßar com um exemplo motivador e discutir porque √© dif√≠cil
escrever um teste de unidade para ele. Em seguida, vamos introduzir o
conceito de mocks como uma poss√≠vel solu√ß√£o para testar esse
exemplo.</p>
<p></p>
<p><strong>Aviso:</strong> Neste cap√≠tulo, inicialmente, usamos
<strong>mock</strong> como sin√¥nimo de <strong>stub</strong>. No
entanto, inclu√≠mos uma subse√ß√£o mais √† frente para ressaltar que alguns
autores fazem uma distin√ß√£o entre esses termos.</p>
<p><strong>Exemplo Motivador:</strong> Para explicar o conceito de
mocks, vamos partir de uma classe simples para pesquisa de livros, cujo
c√≥digo √© mostrado a seguir. Essa classe, chamada
<code>BookSearch</code>, implementa um m√©todo <code>getBook</code>, que
pesquisa os dados de um livro em um servi√ßo remoto. Esse servi√ßo, por
sua vez, implementa a interface <code>BookService</code>. Para o exemplo
ficar mais real, suponha que <code>BookService</code> √© uma API REST ou
uma base de dados. O importante √© que a pesquisa √© realizada em outro
sistema, que fica abstra√≠do pela interface <code>BookService</code>.
Esse servi√ßo retorna o seu resultado como um documento JSON, isto √©, um
documento textual. Assim, cabe ao m√©todo <code>getBook</code> acessar o
servi√ßo remoto, obter a resposta em formato JSON e criar um objeto da
classe <code>Book</code> para armazenar a resposta. Para simplificar o
exemplo, n√£o mostramos o c√≥digo da classe <code>Book</code>, mas ela √©
apenas uma classe com dados de livros e seus respectivos m√©todos
<code>get</code>. Na verdade, para simplificar um pouco mais, o exemplo
considera que <code>Book</code> possui um √∫nico campo, relativo ao seu
t√≠tulo. Em um programa real, <code>Book</code> teria outros campos, que
tamb√©m seriam tratados em <code>getBook</code>.</p>
<pre><code>import org.json.JSONObject;

public class BookSearch {

  BookService rbs;

  public BookSearch(BookService rbs) {
    this.rbs = rbs;
  }

  public Book getBook(int isbn) {
    String json = rbs.search(isbn);
    JSONObject obj = new JSONObject(json);
    String titulo;
    titulo = (String) obj.get(&quot;titulo&quot;);
    return new Book(titulo);
  }

}

public interface BookService {
  String search(int isbn);
}</code></pre>
<p><strong>Problema</strong>: Precisamos implementar um teste de unidade
para <code>BookSearch</code>. Por√©m, por defini√ß√£o, um teste de unidade
exercita um componente pequeno do c√≥digo, como uma √∫nica classe. O
problema √© que para testar <code>BookSearch</code> precisamos de um
<code>BookService</code>, que √© um servi√ßo externo. Ou seja, se n√£o
tomarmos cuidado, o teste de <code>getBook</code> vai alcan√ßar um
servi√ßo externo. Isso √© ruim por dois motivos: (1) o escopo do teste
ficar√° maior do que uma √∫nica unidade de c√≥digo; (2) o teste ficar√° mais
lento, pois o servi√ßo externo pode ser uma base de dados, armazenada em
disco, ou ent√£o um servi√ßo remoto, acessado via HTTP ou um protocolo
similar. E devemos lembrar que testes de unidades devem executar
rapidamente, conforme recomendado pelos princ√≠pios FIRST (Se√ß√£o
8.3).</p>
<p><strong>Solu√ß√£o</strong>: Uma solu√ß√£o consiste em criar um objeto que
<q>emula</q> o objeto real, mas apenas para permitir o teste do
programa. Esse tipo de objeto √© chamado de <strong>mock</strong> (ou
ent√£o <strong>stub</strong>). No nosso exemplo, o mock deve implementar
a interface <code>BookService</code> e, portanto, o m√©todo
<code>search</code>. Por√©m, essa implementa√ß√£o √© parcial, pois o mock
retorna apenas os t√≠tulos de alguns livros, sem acessar servidores
remotos ou bancos de dados. Um exemplo √© mostrado a seguir:</p>
<pre><code>import static org.junit.Assert.*;
import org.junit.*;


class BookConst {

  public static String ESM = 
          &quot;{ \&quot;titulo\&quot;: \&quot;Eng Soft Moderna\&quot; }&quot;;

  public static String NULLBOOK = 
          &quot;{ \&quot;titulo\&quot;: \&quot;NULL\&quot; }&quot;;

}

class MockBookService implements BookService {

   public String search(int isbn) {
     if (isbn == 1234)
        return BookConst.ESM;
     return BookConst.NULLBOOK;
   }

}

public class BookSearchTest {

  private BookService service;

  @Before
  public void init() {
    service = new MockBookService();
  }

  @Test
  public void testGetBook() {
    BookSearch bs = new BookSearch(service);
    String titulo = bs.getBook(1234).getTitulo();
    assertEquals(&quot;Eng Soft Moderna&quot;, titulo);
  }

}</code></pre>
<p>Nesse exemplo, <code>MockBookService</code> √© uma classe usada para
criar mocks de <code>BookService</code>, isto √©, objetos que implementam
essa interface, mas com um comportamento trivial. No exemplo, o objeto
mock, de nome <code>service</code>, somente retorna dados do livro cujo
ISBN √© 1234. O leitor pode ent√£o estar se perguntando: qual a utilidade
de um servi√ßo que pesquisa dados de um √∫nico livro? A resposta √© que
esse mock nos permite implementar um teste de unidade que n√£o precisa
acessar um servi√ßo remoto, externo e lento. No m√©todo
<code>testGetBook</code>, usa-se o mock para criar um objeto do tipo
<code>BookSearch</code>. Em seguida, chama-se o m√©todo
<code>getBook</code> para pesquisar por um livro e retornar o seu
t√≠tulo. Por fim, executa-se um <code>assert</code>. Como o teste √©
baseado em um <code>MockBookService</code>, ele verifica se o t√≠tulo
retornado √© aquele do √∫nico livro <q>pesquisado</q> por tal mock.</p>
<p>Por√©m, talvez ainda reste uma pergunta: o que, de fato,
<code>testGetBook</code> testa? Em outras palavras, qual requisito do
sistema est√° sendo testado por meio de um objeto mock t√£o simples?
Claro, nesse caso, n√£o estamos testando o acesso ao servi√ßo remoto. Como
foi afirmado, esse √© um requisito muito <q>extenso</q> para ser
verificado via testes de unidade. Em vez disso, estamos testando se a
l√≥gica de instanciar um <code>Book</code> a partir de um documento JSON
est√° funcionando. Em um teste mais real, poder√≠amos incluir mais campos
em <code>Book</code>, al√©m do t√≠tulo. Poder√≠amos tamb√©m testar com mais
alguns livros, bastando estender a capacidade do mock: em vez de
retornar sempre o JSON do mesmo livro, ele retornaria dados de mais
livros, dependendo do ISBN.</p>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo do exemplo de mock usado
nesta se√ß√£o est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/c162dce743cc2cb8fdbc25605c35cc2b">link</a>.</p>
<h3 data-number="8.6.1" id="frameworks-de-mocks"><span
class="header-section-number">8.6.1</span> Frameworks de Mocks <a
href="#frameworks-de-mocks" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Mocks s√£o t√£o comuns em testes de unidade que existem frameworks para
facilitar a cria√ß√£o e <q>programa√ß√£o</q> de mocks (e/ou stubs). N√£o
vamos entrar em detalhes desses frameworks, mas abaixo mostramos o teste
anterior, mas com um mock instanciado por um framework chamado
<strong>mockito</strong> (<a href="https://site.mockito.org/">link</a>),
muito usado quando se escreve testes de unidade em Java que requerem
mocks.</p>
<pre><code>import org.junit.*;
import static org.junit.Assert.*;
import org.mockito.Mockito;
import static org.mockito.Mockito.when;
import static org.mockito.Matchers.anyInt;

public class BookSearchTest {

  private BookService service;

  @Before
  public void init() {
    service = Mockito.mock(BookService.class);
    when(service.search(anyInt())).
                 thenReturn(BookConst.NULLBOOK);
    when(service.search(1234)).thenReturn(BookConst.ESM);
  }        


  @Test
  public void testGetBook() {
    BookSearch bs = new BookSearch(service);
    String titulo = bs.getBook(1234).getTitulo();
    assertEquals(&quot;Eng Soft Moderna&quot;, titulo);
  }

}</code></pre>
<p>Primeiro, podemos ver que n√£o existe mais uma classe
<code>MockBookService</code>. O principal ganho de se usar um framework
como o mockito √© exatamente esse: n√£o ter mais que escrever classes de
mock manualmente. Em vez disso, um mock para <code>BookService</code> √©
criado pelo pr√≥prio framework usando-se dos recursos de <strong>reflex√£o
computacional</strong> de Java. Para isso, basta usar a fun√ß√£o
<code>mock(type)</code>, como a seguir:</p>
<p><code>service = Mockito.mock(BookService.class);</code></p>
<p>No entanto, o mock <code>service</code> ainda est√° vazio e sem nenhum
comportamento. Temos ent√£o que ensin√°-lo a se comportar pelo menos em
algumas situa√ß√µes. Especificamente, temos que ensin√°-lo a responder a
algumas pesquisas de livros. Para isso, o mockito oferece uma
<strong>linguagem de dom√≠nio espec√≠fico</strong> simples, baseada na
mesma sintaxe de Java. Um exemplo √© mostrado a seguir:</p>
<p><code>when(service.search(anyInt())).thenReturn(BookConst.NULLBOOK);</code></p>
<p><code>when(service.search(1234)).thenReturn(BookConst.ESM);</code></p>
<p>Essa duas linhas <q>programam</q> o mock <code>service</code>.
Primeiro, dizemos para ele retornar <code>BookConst.NULLBOOK</code>
quando o seu m√©todo <code>search</code> for chamado com qualquer inteiro
como argumento. Em seguida, abrimos uma exce√ß√£o a essa regra geral:
quando <code>search</code> for chamado com o inteiro 1234, ele deve
retornar a string JSON com os dados do livro
<code>BookConst.ESM</code>.</p>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo desse exemplo, usando o
mockito, est√° neste <a
href="https://gist.github.com/mtov/f7781e3f164a62c85cf4294271b9c2fd">link</a>.</p>
<h3 data-number="8.6.2" id="mocks-vs-stubs"><span
class="header-section-number">8.6.2</span> Mocks vs Stubs <a
href="#mocks-vs-stubs" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p> Alguns autores, como Gerard Meszaros (<a
href="https://dl.acm.org/citation.cfm?id=1076526">link</a>), fazem uma
distin√ß√£o entre <strong>mocks</strong> e <strong>stubs</strong>. Segundo
eles, mocks devem verificar n√£o apenas o estado do Sistema sob Testes
(SUT), mas tamb√©m o seu comportamento. Se os mocks verificam apenas o
estado, eles deveriam ser chamados de stubs. No entanto, neste livro,
n√£o vamos fazer essa distin√ß√£o, pois achamos que ela √© sutil e,
portanto, os benef√≠cios n√£o compensam o custo de p√°ginas extras para
explicar conceitos semelhantes. Por√©m, apenas para esclarecer um pouco
mais, um <strong>teste comportamental</strong> ‚Äî tamb√©m chamado de teste
de intera√ß√£o ‚Äî verifica eventos que ocorreram no SUT. Segue um
exemplo:</p>
<pre><code>void testBehaviour {
  Mailer m = mock(Mailer.class);
  sut.someBusinessLogic(m);
  verify(m).send(anyString());
}</code></pre>
<p>Nesse exemplo, o comando <code>verify</code> ‚Äî implementado pelo
mockito ‚Äî √© parecido com um <code>assert</code>. No entanto, ele
verifica se um evento ocorreu com o mock passado como argumento. No
caso, verificamos se o m√©todo <code>send</code> do mock foi executado
pelo menos uma vez, usando qualquer string como argumento.</p>
<p> Segundo Gerard Meszaros, mocks e stubs s√£o casos especiais de
<strong>objetos dubl√™</strong> (<em>double</em>). O termo √© inspirado em
dubl√™s de atores em filmes. Segundo Meszaros, existem pelo menos mais
dois outros tipos de objetos dubl√™:</p>
<ul>
<li><p><strong>Objetos Dummy</strong> s√£o objetos que s√£o passados como
argumento para um m√©todo, mas que n√£o s√£o usados. Trata-se, portanto, de
uma forma de dubl√™ usada apenas para satisfazer o sistema de tipos da
linguagem.</p></li>
<li><p><strong>Objeto Fake</strong> s√£o objetos que possuem uma
implementa√ß√£o mais simples do que o objeto real. Por exemplo, um objeto
que simula em mem√≥ria principal, por meio de tabelas hash, um objeto de
acesso a bancos de dados.</p></li>
</ul>
<h3 data-number="8.6.3" id="exemplo-servlet-1"><span
class="header-section-number">8.6.3</span> Exemplo: Servlet <a
href="#exemplo-servlet-1" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Na se√ß√£o anterior, mostramos o teste de uma servlet que calcula o
√çndice de Massa Corporal (IMC) de uma pessoa. No entanto, argumentamos
que n√£o ir√≠amos testar a servlet completa porque ela possui depend√™ncias
dif√≠ceis de serem recriadas em um teste. No entanto, agora sabemos que
podemos criar mocks para essas depend√™ncias, isto √©, objetos que v√£o
<q>simular</q> as depend√™ncias reais, por√©m respondendo apenas √†s
chamadas que precisamos no teste.</p>
<p>Primeiro, vamos reapresentar o c√≥digo da servlet que queremos
testar:</p>
<pre><code>public class IMCServlet extends HttpServlet {

  IMCModel model = new IMCModel();

  public void doGet(HttpServletRequest req, 
                    HttpServletResponse res) {
    res.setContentType(&quot;text/html&quot;);
    PrintWriter out = res.getWriter();
    String peso = req.getParameter(&quot;peso&quot;);
    String altura = req.getParameter(&quot;altura&quot;);
    double imc = model.calculaIMC(peso,altura);
    out.println(&quot;IMC: &quot; + imc);
  }

}</code></pre>
<p>Segue ent√£o o novo teste dessa servlet (ele √© uma adapta√ß√£o de um
exemplo dispon√≠vel em um <a
href="https://doi.ieeecomputersociety.org/10.1109/MS.2002.1003449">artigo</a>
de autoria de Dave Thomas e Andy Hunt). Primeiro, podemos ver, no m√©todo
<code>init</code>, que foram criados mocks para objetos dos tipos
<code>HttpServletRequest</code> e <code>HttpServletResponse</code>.
Esses mocks ser√£o usados como par√¢metros da chamada de
<code>doGet</code> que faremos no m√©todo de teste. Ainda em
<code>init</code>, criamos um objeto do tipo <code>StringWriter</code>
que permite gerar sa√≠das na forma de uma lista de Strings. Em seguida,
esse objeto √© encapsulado por um <code>PrintWriter</code>, que √© o
objeto usado como sa√≠da pela servlet ‚Äî ou seja, trata-se de uma
aplica√ß√£o padr√£o de projeto Decorador, que estudamos no Cap√≠tulo 6. Por
fim, programamos o mock de resposta: quando a servlet pedir um objeto de
sa√≠da, por meio de uma chamada a <code>getWriter()</code>, ele deve
retornar o objeto <code>PrintWriter</code> que acabamos de criar. Em
resumo, fizemos tudo isso com o objetivo de alterar a sa√≠da da servlet
para uma lista de strings.</p>
<pre><code>public class IMCServletTest {

  HttpServletRequest req;
  HttpServletResponse res;

  StringWriter sw;

  @Before
  public void init() {
    req = Mockito.mock(HttpServletRequest.class);
    res = Mockito.mock(HttpServletResponse.class);
    sw = new StringWriter();
    PrintWriter pw = new PrintWriter(sw);
    when(res.getWriter()).thenReturn(pw);
  }
  // ...continua a seguir</code></pre>
<p>Para concluir, temos o m√©todo de teste, mostrado a seguir.</p>
<pre><code>  // continua√ß√£o de IMCServletTest
  @Test
  public void testDoGet() {
    when(req.getParameter(&quot;peso&quot;)).thenReturn(&quot;82&quot;);
    when(req.getParameter(&quot;altura&quot;)).thenReturn(&quot;1.80&quot;);
    new IMCServlet().doGet(req,res);
    assertEquals(&quot;IMC: 25.3\n&quot;, sw.toString());
  }

}</code></pre>
<p>Nesse teste, come√ßamos programando o mock do objeto com os par√¢metros
de entrada da servlet. Quando a servlet pedir o par√¢metro <q>peso</q>, o
mock vai retornar 82; quando a servlet pedir o par√¢metro <q>altura</q>,
ele deve retornar 1.80. Feito isso, o teste segue o fluxo normal de
testes de unidades: chamamos o m√©todo que queremos testar,
<code>doGet</code>, e verificamos se ele retorna o resultado
esperado.</p>
<p>Esse exemplo serve tamb√©m para ilustrar as desvantagens do uso de
mocks. A principal delas √© o fato de mocks aumentarem o acoplamento
entre o teste e o m√©todo testado. Tipicamente, em testes de unidade, o
m√©todo de teste chama o m√©todo testado e verifica seu resultado. Logo,
ele se acopla apenas √† assinatura deste m√©todo. Por isso, o teste n√£o √©
<q>quebrado</q> quando apenas o c√≥digo interno do m√©todo testado √©
modificado. No entanto, quando usamos mocks, isso deixa de ser verdade,
pois o mock pode depender de estruturas internas do m√©todo testado, o
que torna os testes mais fr√°geis. Por exemplo, suponha que a sa√≠da da
servlet mude para <q>√çndice de Massa Corporal (IMC):</q> [valor]. Nesse
caso, teremos que lembrar de atualizar tamb√©m o
<code>assertEquals</code> do teste de unidade.</p>
<p>Por fim, n√£o conseguimos criar mocks para todos os objetos e m√©todos.
Em geral, as seguintes constru√ß√µes n√£o s√£o <q>mock√°veis</q>: classes e
m√©todos finais, m√©todos est√°ticos e construtores.</p>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo do teste dessa servlet,
usando mocks, est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/5372c7ffebe79c21768d0b1290c409b1">link</a>.</p>
<h2 data-number="8.7" id="desenvolvimento-dirigido-por-testes-tdd"><span
class="header-section-number">8.7</span> Desenvolvimento Dirigido por
Testes (TDD) <a href="#desenvolvimento-dirigido-por-testes-tdd"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p></p>
<p>Desenvolvimento Dirigido por Testes (<em>Test Driven
Development</em>, TDD) √© uma das pr√°ticas de programa√ß√£o propostas por
Extreme Programming (XP). A ideia a princ√≠pio pode parecer estranha,
talvez at√© absurda: dado um teste de unidade T para uma classe C, TDD
defende que T deve ser escrito antes de C. Por isso, TDD √© conhecido
tamb√©m como <em>Test-First Development</em>.</p>
<p>Quando se escreve o teste primeiro, ele vai falhar. Ent√£o, no fluxo
de trabalho defendido por TDD, o pr√≥ximo passo consiste em escrever o
c√≥digo que faz esse teste passar, mesmo que seja um c√≥digo trivial. Em
seguida, esse primeiro c√≥digo deve ser finalizado e refinado. Por fim,
se necess√°rio, ele deve ser refatorado, para melhorar seu projeto,
legibilidade, manutenibilidade, para seguir princ√≠pios e padr√µes de
projeto, etc.</p>
<p>TDD foi proposto com tr√™s objetivos principais em mente:</p>
<ul>
<li><p>TDD ajuda a evitar que os desenvolvedores esque√ßam de escrever
testes. Para isso, TDD promove testes √† primeira atividade de qualquer
tarefa de programa√ß√£o, seja ela corrigir um bug ou implementar uma nova
funcionalidade. Sendo a primeira atividade, √© mais dif√≠cil que a escrita
de testes seja deixada para um segundo momento.</p></li>
<li><p>TDD favorece a escrita de c√≥digo com alta testabilidade. Essa
caracter√≠stica √© uma consequ√™ncia natural da invers√£o do fluxo de
trabalho proposta por TDD: como o desenvolvedor sabe que ele ter√° que
escrever o teste T e depois a classe C, √© natural que desde o in√≠cio ele
planeje C de forma a facilitar a escrita de seu teste. De fato, como
mencionamos na Se√ß√£o 8.4, sistemas que usam TDD t√™m alta cobertura de
testes, normalmente acima de 90%.</p></li>
<li><p>TDD √© uma pr√°tica relacionada n√£o apenas com testes, mas tamb√©m
com a melhoria do design de um sistema. Isso acontece porque o
desenvolvedor, ao come√ßar pela escrita de um teste T, coloca-se na
posi√ß√£o de um usu√°rio da classe C. Em outras palavras, com TDD, o
primeiro usu√°rio da classe √© seu pr√≥prio desenvolvedor ‚Äî lembre que T √©
um cliente de C, pois ele chama m√©todos de C. Por isso, espera-se que o
desenvolvedor simplifique a interface de C, use nomes de identificadores
leg√≠veis, evite muitos par√¢metros, etc.</p></li>
</ul>
<p></p>
<p>Quando se trabalha com TDD, o desenvolvedor segue um ciclo composto
por tr√™s estados, conforme mostra a pr√≥xima figura.</p>
<figure>
<img src="figs/cap8/ciclos-tdd.svg" style="width:75.0%"
alt="Ciclos de TDD" />
<figcaption aria-hidden="true">Ciclos de TDD</figcaption>
</figure>
<p>De acordo com esse diagrama, a primeira meta √© chegar no estado
vermelho, quando o teste ainda n√£o est√° passando. Pode parecer estranho,
mas o estado vermelho j√° √© uma pequena vit√≥ria: ao escrever um teste que
falha, o desenvolvedor pelo menos tem em m√£os uma especifica√ß√£o da
classe que ele precisar√° implementar em seguida. Ou seja, ele j√° sabe o
que tem que fazer. Conforme j√° mencionamos, nesse estado, √© importante
que o desenvolvedor pense tamb√©m na interface da classe que ele ter√° que
implementar, colocando-se na posi√ß√£o de um usu√°rio da mesma. Por fim, √©
importante que ele entregue o c√≥digo compilando. Para isso, ele deve
escrever pelo menos o esqueleto da classe sob teste, isto √©, a
assinatura da classe e de seus m√©todos.</p>
<p>Em seguida, a meta √© alcan√ßar o estado verde. Para isso, deve-se
implementar a funcionalidade completa da classe sob teste; quando isso
ocorrer, os testes que estavam falhando v√£o come√ßar a passar. No
entanto, pode-se dividir essa implementa√ß√£o em pequenos passos. Talvez,
nos passos iniciais, o c√≥digo estar√° funcionando de forma parcial, por
exemplo, retornando apenas constantes. Isso ficar√° mais claro no exemplo
que daremos a seguir.</p>
<p>Por fim, deve-se analisar se existem oportunidades para refatorar o
c√≥digo da classe e do teste. Quando se usa TDD, o objetivo n√£o √© apenas
alcan√ßar o estado verde, no qual o programa est√° funcionando. Al√©m
disso, deve-se verificar a possibilidade de melhorar a qualidade do
projeto do c√≥digo. Por exemplo, verificar se n√£o existe c√≥digo
duplicado, se n√£o existem m√©todos muito longos que possam ser quebrados
em m√©todos menores, se algum m√©todo pode ser movido para uma classe
diferente, etc. Terminado o passo de refatora√ß√£o, podemos parar ou ent√£o
reiniciar o ciclo, para implementar mais alguma funcionalidade.</p>
<h3 data-number="8.7.1" id="exemplo-carrinho-de-compras"><span
class="header-section-number">8.7.1</span> Exemplo: Carrinho de Compras
<a href="#exemplo-carrinho-de-compras" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Para concluir, vamos ilustrar uma sess√£o de uso de TDD. Para isso,
usaremos como exemplo o sistema de uma livraria virtual. Nesse sistema,
temos uma classe <code>Book</code>, com atributos <code>titulo</code>,
<code>isbn</code> e <code>preco</code>. E temos tamb√©m a classe
<code>ShoppingCart</code>, que armazena os livros que um cliente deseja
comprar. Essa classe deve implementar m√©todos para: adicionar um livro
no carrinho; retornar o pre√ßo total dos livros no carrinho; e remover um
livro do carrinho. A seguir, mostramos a implementa√ß√£o desses m√©todos
usando TDD.</p>
<p><strong>Estado Vermelho:</strong> Come√ßamos definindo que
<code>ShoppingCart</code> ter√° um m√©todo <code>add</code> e um m√©todo
<code>getTotal</code>. Al√©m de decidir o nome de tais m√©todos, definimos
os seus par√¢metros e escrevemos o primeiro teste:</p>
<pre><code>@Test
void testAddGetTotal() {
  Book b1 = new Book(&quot;book1&quot;, 10, &quot;1&quot;);
  Book b2 = new Book(&quot;book2&quot;, 20, &quot;2&quot;);
  ShoppingCart cart = new ShoppingCart();
  cart.add(b1);
  cart.add(b2);
  assertEquals(30.0, cart.getTotal());
}</code></pre>
<p>Apesar de simples e de f√°cil entendimento, esse teste ainda n√£o
compila, pois n√£o existe implementa√ß√£o para as classes <code>Book</code>
e <code>ShoppingCart</code>. Ent√£o, temos que providenciar isso, como
mostrado a seguir:</p>
<pre><code>public class Book {
  public String title;
  public double price;
  public String isbn;

  public Book(String title, double price, String isbn) {
    this.title = title;
    this.price = price;
    this.isbn = isbn;
  }

}

public class ShoppingCart {

  public ShoppingCart() {}

  public void add(Book b) {}

  public double getTotal() {
    return 0.0;
  }
}</code></pre>
<p>A implementa√ß√£o de ambas as classes √© muito simples. Implementamos
apenas o m√≠nimo para que o programa e o teste compilem. Observe, por
exemplo, o m√©todo <code>getTotal</code> de <code>ShoppingCart</code>.
Nessa implementa√ß√£o, ele sempre retorna 0.0. Apesar disso atingimos
nosso objetivo: temos um teste compilando, executando e falhando! Ou
seja, chegamos ao estado vermelho.</p>
<p><strong>Estado Verde</strong>: o teste anterior funciona como uma
especifica√ß√£o. Isto √©, ele define o que temos que implementar em
<code>ShoppingCart</code>. Logo, m√£os √† obra:</p>
<pre><code>public class ShoppingCart {
  public ShoppingCart() {}
  public void add(Book b) {}
  double getTotal() {
    return 30.0;
  }
}</code></pre>
<p>Por√©m, o leitor deve estar agora surpreso: essa implementa√ß√£o est√°
incorreta! A construtora de <code>ShoppingCart</code> est√° vazia, a
classe n√£o possui nenhuma estrutura de dados para armazenar os itens do
carrinho, <code>getTotal</code> retorna sempre 30.0, etc. Tudo isso √©
verdade, mas j√° temos uma nova pequena vit√≥ria: o teste mudou de cor, de
vermelho para verde. Ou seja, ele est√° passando. Com TDD, os avan√ßos s√£o
sempre pequenos. Em XP, esses avan√ßos s√£o chamados de <strong>baby
steps</strong>.</p>
<p>Mas temos que prosseguir e dar uma implementa√ß√£o mais realista para
<code>ShoppingCart</code>. Segue ent√£o ela:</p>
<pre><code>public class ShoppingCart {

  private ArrayList&lt;Book&gt; items;

  private double total;

  public ShoppingCart() {
    items = new ArrayList&lt;Book&gt;();
    total = 0.0;  
  }

  public void add(Book b) {
    items.add(b);
    total += b.price;
  }

  double getTotal() {
    return total;
  }

}</code></pre>
<p>Agora dispomos de uma estrutura de dados para armazenar os itens do
carrinho, um atributo para armazenar o valor total do carrinho, uma
classe construtora, um m√©todo <code>add</code> que adiciona os livros na
estrutura de dados e incrementa o <code>total</code> do carrinho e assim
por diante. No melhor do nosso ju√≠zo, essa implementa√ß√£o j√° implementa o
que foi pedido e, por isso, podemos declarar que chegamos ao estado
verde.</p>
<p><strong>Estado Amarelo</strong>: agora temos que olhar para o c√≥digo
que foi implementado ‚Äî um teste e duas classes ‚Äî e colocar em pr√°tica as
propriedades, princ√≠pios e padr√µes de projeto que aprendemos em
cap√≠tulos anteriores. Ou seja: existe alguma coisa que podemos fazer
para tornar esse c√≥digo mais leg√≠vel, f√°cil de entender e de manter? No
caso, a ideia que pode surgir √© encapsular os campos de
<code>Book</code>. Todos eles atualmente s√£o p√∫blicos e, por isso, seria
melhor implementar apenas m√©todos <code>get</code> e <code>set</code>
para dar acesso a eles. Como essa implementa√ß√£o √© simples, n√£o vamos
mostrar o c√≥digo refatorado de <code>Book</code>.</p>
<p>Ent√£o, fechamos uma volta no ciclo vermelho-verde-refatorar de TDD.
Agora, podemos parar ou ent√£o pensar em implementar mais um requisito.
Por exemplo, podemos implementar um m√©todo para remover livros do
carrinho. Para isso, temos que come√ßar mais um ciclo.</p>
<h2 data-number="8.8" id="testes-de-integra√ß√£o"><span
class="header-section-number">8.8</span> Testes de Integra√ß√£o <a
href="#testes-de-integra√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Com testes de integra√ß√£o ‚Äî tamb√©m chamados de <strong>testes de
servi√ßos</strong> ‚Äî subimos para um n√≠vel intermedi√°rio da pir√¢mide de
testes (veja uma figura com essa pir√¢mide na primeira se√ß√£o do
cap√≠tulo). Assim, o objetivo deixa de ser o teste de uma unidade pequena
de c√≥digo, como uma classe apenas. Em vez disso, testes de integra√ß√£o
exercitam um servi√ßo completo, isto √©, uma funcionalidade de maior
granularidade do sistema. Por isso, eles envolvem mais classes, √†s vezes
de pacotes distintos. Tamb√©m envolvem depend√™ncias e sistemas reais,
como bancos de dados e servi√ßos remotos. Al√©m disso, quando se
implementa testes de integra√ß√£o n√£o faz mais sentido usar mocks ou
stubs. Como s√£o testes maiores, eles levam mais tempo para executar e,
consequentemente, s√£o chamados com menor frequ√™ncia.</p>
<h3 data-number="8.8.1" id="exemplo-agenda-de-compromissos"><span
class="header-section-number">8.8.1</span> Exemplo: Agenda de
Compromissos <a href="#exemplo-agenda-de-compromissos"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p>Suponha uma agenda simples que permita adicionar, remover e editar
compromissos, conforme ilustrado na pr√≥xima figura.</p>
<figure>
<img src="figs/cap8/myappointments.png" style="width:65.0%"
alt="Interface da Agenda de Compromissos" />
<figcaption aria-hidden="true">Interface da Agenda de
Compromissos</figcaption>
</figure>
<p>Nesse sistema, existe uma classe com m√©todos para manipular a agenda,
como mostrado a seguir:</p>
<pre><code>public class AgendaFacade {
  public AgendaFacade(DB db);
  int addAppointment(Appointment p);
  void removeAppointment(int id);
  Appointmemt[] listAppointments();
}</code></pre>
<p>Assim, podemos escrever o seguinte teste de integra√ß√£o para essa
classe:</p>
<pre><code>@Test
void AgendaFacadeTest() {
  DB db = DB.create();
  AgendaFacade agenda = new AgendaFacade(db);
  Appointment app1 = new Appointmemt(...);
  Appointment app2 = new Appointmemt(...);
  Appointment app3 = new Appointmemt(...);
  int id1 = agenda.addAppointmemt(app1);
  int id2 = agenda.addAppointmemt(app2);
  int id3 = agenda.addAppointmemt(app3);
  Appointment [] apps = agenda.listAppointments();
  assertEquals(3,apps.length);
}</code></pre>
<p>Vale a pena mencionar dois pontos sobre esse teste. Primeiro, ele √©
implementado usando o JUnit, como os testes anteriores, de unidade, que
estudamos neste cap√≠tulo. Ou seja, JUnit poder ser usado tanto para
testes de unidade como para testes de integra√ß√£o. Segundo, ele √© um
teste de integra√ß√£o, pois a classe √© testada com depend√™ncias reais, no
caso para um banco de dados. No in√≠cio do teste, cria-se um banco de
dados com todas as tabelas vazias. Em seguida, tr√™s objetos s√£o
persistidos e depois lidos do banco de dados. Por fim, chama-se um
<code>assert</code>. Assim, esse teste exercita os principais servi√ßos
da agenda, exceto aqueles relacionados com sua interface gr√°fica. Por
isso, ele ainda n√£o √© um teste de sistema.</p>
<h2 data-number="8.9" id="testes-de-sistema"><span
class="header-section-number">8.9</span> Testes de Sistema <a
href="#testes-de-sistema" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Testes de sistema est√£o posicionados no topo da pir√¢mide de testes.
Trata-se de testes que simulam o uso de um sistema por um usu√°rio real.
Testes de sistema s√£o tamb√©m chamados de testes
<strong>ponta-a-ponta</strong> (<em>end-to-end</em>) ou ent√£o
<strong>testes de interfaces</strong>. S√£o os testes mais caros, que
demandam maior esfor√ßo para implementa√ß√£o e que executam em mais
tempo.</p>
<h3 data-number="8.9.1" id="exemplo-teste-de-sistemas-web"><span
class="header-section-number">8.9.1</span> Exemplo: Teste de Sistemas
Web <a href="#exemplo-teste-de-sistemas-web" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Selenium √© um framework para automatizar testes de sistemas Web. O
framework permite criar programas que funcionam como rob√¥s que abrem
p√°ginas Web, preenchem formul√°rios, clicam em bot√µes, testam respostas,
etc. Um exemplo ‚Äî extra√≠do e adaptado da documenta√ß√£o do Selenium (<a
href="https://www.seleniumhq.org/docs/03_webdriver.jsp">link</a>) ‚Äî √©
mostrado a seguir. Esse c√≥digo simula um usu√°rio de um navegador Firefox
fazendo uma pesquisa no Google pela palavra <q>software</q>. O c√≥digo
tamb√©m imprime no console o t√≠tulo da p√°gina que lista os resultados da
pesquisa.</p>
<pre><code>public class SeleniumExample {

  public static void main(String[] args) {
    // cria um driver para acessar um servidor Web
    WebDriver driver = new FirefoxDriver();

    // instrui o driver para &quot;navegar&quot; pelo Google
    driver.navigate().to(&quot;http://www.google.com&quot;);

    // obt√©m um campo de entrada de dados, de nome &quot;q&quot;
    WebElement element = driver.findElement(By.name(&quot;q&quot;));

    // preenche esse campo com as palavras &quot;software&quot;
    element.sendKeys(&quot;software&quot;);

    // submete os dados; como se fosse dado um &quot;enter&quot;
    element.submit();

    // espera a p√°gina de resposta carregar (timeout de 8s)
    (new WebDriverWait(driver,8)).
         until(new ExpectedCondition&lt;Boolean&gt;() {
    public Boolean apply(WebDriver d) {
    return d.getTitle().toLowerCase().startsWith(&quot;software&quot;);
    }
    });

    // resultado deve ser: &quot;software - Google Search&quot;
    System.out.println(&quot;Page title is: &quot;+driver.getTitle());

    // fecha o navegador
    driver.quit();
  }
}</code></pre>
<p>Testes de interface s√£o mais dif√≠ceis de escrever, pelo menos do que
testes de unidade e mesmo do que testes de integra√ß√£o. Por exemplo, a
API do Selenium √© mais complexa do que aquela do JUnit. Al√©m disso, o
teste deve tratar eventos de interfaces, como timeouts que ocorrem
quando uma p√°gina demora mais tempo do que o usual para ser carregada.
Testes de interface tamb√©m s√£o mais fr√°geis, isto √©, eles podem quebrar
devido a pequenas mudan√ßas na interface. Por exemplo, se o nome do campo
de pesquisa da tela principal do Google mudar, o teste acima ter√° que
ser atualizado. Por√©m, se compararmos com a alternativa ‚Äî realizar o
teste manualmente ‚Äî eles ainda s√£o competitivos e apresentam ganhos.</p>
<h3 data-number="8.9.2" id="exemplo-teste-de-um-compilador"><span
class="header-section-number">8.9.2</span> Exemplo: Teste de um
Compilador <a href="#exemplo-teste-de-um-compilador" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Quando se desenvolve um compilador, pode-se usar testes de unidade ou
de integra√ß√£o. J√° os testes de sistema de um compilador tendem a ser
conceitualmente mais simples. O motivo √© que a interface de um
compilador n√£o inclui janelas e telas com elementos gr√°ficos. Em vez
disso, um compilador recebe um arquivo de entrada e produz um arquivo de
sa√≠da. Assim, o teste de sistema de um compilador C para uma linguagem X
demanda a implementa√ß√£o de v√°rios programas em X, exercitando diversos
aspectos dessa linguagem. Para cada programa P, deve-se definir um
conjunto de dados de entrada e um conjunto de dados de sa√≠da.
Preferencialmente, essa sa√≠da deve ser em um formato simples, como uma
lista de strings. Ent√£o, o teste de sistema do compilador ocorre da
seguinte forma: chama-se C para compilar cada programa P; em seguida,
executamos o resultado da compila√ß√£o com a entrada definida
anteriormente e verificamos se o resultado √© o esperado. Esse teste √© um
teste de sistema, pois estamos exercitando todas as funcionalidades do
compilador.</p>
<p>Quando comparados com testes de unidade, √© mais dif√≠cil localizar o
trecho de c√≥digo respons√°vel por uma falha em testes de sistema. Por
exemplo, no caso do compilador, teremos a indica√ß√£o de que um programa
n√£o est√° executando corretamente. Por√©m, normalmente n√£o √© trivial
mapear essa falha para a unidade do compilador que gerou c√≥digo de forma
incorreta.</p>
<h2 data-number="8.10" id="outros-tipos-de-testes"><span
class="header-section-number">8.10</span> Outros Tipos de Testes <a
href="#outros-tipos-de-testes" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<h3 data-number="8.10.1" id="testes-caixa-preta-e-caixa-branca"><span
class="header-section-number">8.10.1</span> Testes Caixa-Preta e
Caixa-Branca <a href="#testes-caixa-preta-e-caixa-branca"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>T√©cnicas de teste podem ser classificadas como caixa-preta ou
caixa-branca. Quando se usa uma <strong>t√©cnica caixa-preta</strong>, os
testes s√£o escritos com base apenas na interface do sistema sob testes.
Por exemplo, se a miss√£o for testar um m√©todo como uma caixa-preta, a
√∫nica informa√ß√£o dispon√≠vel incluir√° seu nome, par√¢metros, tipos e
exce√ß√µes de retorno. Por outro lado, quando se usa uma <strong>t√©cnica
caixa-branca</strong>, a escrita dos testes considera informa√ß√µes sobre
o c√≥digo e a estrutura do sistema sob teste. Por isso, t√©cnicas de teste
caixa-preta s√£o tamb√©m chamadas de <strong>testes funcionais</strong>. E
t√©cnicas caixa-branca s√£o chamadas de <strong>testes
estruturais</strong>.</p>
<p>No entanto, n√£o √© trivial classificar testes de unidade em uma dessas
categorias. Na verdade, a classifica√ß√£o vai depender de como os testes
s√£o escritos. Se os testes de unidade forem escritos usando-se
informa√ß√µes apenas sobre a interface dos m√©todos sob teste, eles s√£o
considerados como caixa-preta. Por√©m, se a escrita considerar
informa√ß√µes sobre a cobertura dos testes, tais como desvios que s√£o
cobertos ou n√£o, ent√£o eles s√£o testes caixa-branca. Em resumo, testes
de unidade sempre testam uma unidade pequena e isolada de c√≥digo. Essa
unidade pode ser testada na forma de uma caixa-preta (conhecendo-se
apenas a sua interface e requisitos externos) ou na forma de uma
caixa-branca (conhecendo-se e tirando-se proveito da sua estrutura
interna, para elabora√ß√£o de testes mais efetivos).</p>
<p> Uma observa√ß√£o semelhante pode ser feita sobre a rela√ß√£o entre TDD e
testes caixa-preta/branca. Para esclarecer essa rela√ß√£o, vamos usar um
coment√°rio do pr√≥prio Kent Beck (fonte: <em>Test-Driven Development
Violates the Dichotomies of Testing</em>, Three Rivers Institute,
2007):</p>
<blockquote>
<p><q>No contexto de TDD, uma dicotomia incorreta ocorre entre testes
caixa-preta e testes caixa-branca. Como testes em TDD s√£o escritos antes
do c√≥digo que eles testam, eles talvez pudessem ser considerados como
testes caixa-preta. No entanto, eu normalmente ganho inspira√ß√£o para
escrever o pr√≥ximo teste depois que implemento e analiso o c√≥digo
verificado pelo teste anterior, o que √© uma caracter√≠stica marcante de
testes caixa-branca.</q></p>
</blockquote>
<h3 data-number="8.10.2" id="sele√ß√£o-de-dados-de-teste"><span
class="header-section-number">8.10.2</span> Sele√ß√£o de Dados de Teste <a
href="#sele√ß√£o-de-dados-de-teste" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Quando se adota testes caixa-preta, existem t√©cnicas para auxiliar na
sele√ß√£o das entradas que ser√£o verificadas no teste. Parti√ß√£o via
<strong>Classe de Equival√™ncia</strong> √© uma t√©cnica que recomenda
dividir as entradas de um problema em conjuntos de valores que t√™m a
mesma chance de apresentar um bug. Esses conjuntos s√£o chamados de
classes de equival√™ncia. Para cada classe de equival√™ncia, recomenda-se
testar apenas um dos seus valores, que pode ser escolhido
randomicamente. Suponha uma fun√ß√£o para calcular o valor a pagar de
imposto de renda, para cada faixa de sal√°rio, conforme tabela a seguir.
Particionamento via classe de equival√™ncia recomendaria testar essa
fun√ß√£o com quatro sal√°rios, um de cada faixa salarial.</p>
<table>
<thead>
<tr>
<th style="text-align: left;"><strong>Sal√°rio</strong></th>
<th style="text-align: left;"><strong>Al√≠quota</strong></th>
<th style="text-align: left;"><strong>Parcela a Deduzir</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">De 1.903,99 at√© 2.826,65</td>
<td style="text-align: left;">7,5%</td>
<td style="text-align: left;">142,80</td>
</tr>
<tr>
<td style="text-align: left;">De 2.826,66 at√© 3.751,05</td>
<td style="text-align: left;">15%</td>
<td style="text-align: left;">354,80</td>
</tr>
<tr>
<td style="text-align: left;">De 3.751,06 at√© 4.664,68</td>
<td style="text-align: left;">22,5%</td>
<td style="text-align: left;">636,13</td>
</tr>
<tr>
<td style="text-align: left;">Acima de 4.664,68</td>
<td style="text-align: left;">27,5%</td>
<td style="text-align: left;">869,36</td>
</tr>
</tbody>
</table>
<p> <strong>An√°lise de Valor Limite</strong> (<em>Boundary Value
Analysis</em>) √© uma t√©cnica complementar que recomenda testar uma
unidade com os valores limites de cada classe de equival√™ncia e seus
valores subsequentes (ou antecedentes). O motivo √© que bugs com
frequ√™ncia s√£o causados por um tratamento inadequado desses valores de
fronteira. Assim, no nosso exemplo, para a primeira faixa salarial,
dever√≠amos testar com os seguintes valores:</p>
<ul>
<li>1.903,98: valor imediatamente inferior ao limite inferior da
primeira faixa salarial</li>
<li>1.903,99: limite inferior da primeira faixa salarial</li>
<li>2.826,65: limite superior da primeira faixa salarial</li>
<li>2.826,66: valor imediatamente superior ao limite superior da
primeira faixa salarial</li>
</ul>
<p>No entanto, como o leitor deve estar pensando, nem sempre √© trivial
encontrar as classes de equival√™ncia para o dom√≠nio de entrada de uma
fun√ß√£o. Isto √©, nem sempre todos os requisitos de um sistema s√£o
organizados em faixas de valores bem definidas como aquelas de nosso
exemplo.</p>
<p>Para concluir, gostar√≠amos de lembrar que <strong>testes
exaustivos</strong>, isto √©, testar um programa com todas as entradas
poss√≠veis, na pr√°tica, √© imposs√≠vel, mesmo em programas pequenos. Por
exemplo, imagine um compilador de uma linguagem X. √â imposs√≠vel testar
esse compilador com todos os programas que podem ser implementados em X,
at√© porque o n√∫mero deles √© infinito. Na verdade, mesmo uma fun√ß√£o com
apenas dois inteiros como par√¢metro pode levar s√©culos para ser testada
exaustivamente com todos os poss√≠veis pares de inteiros. <strong>Testes
rand√¥micos</strong>, quando os dados de teste s√£o escolhidos
aleatoriamente, tamb√©m n√£o s√£o recomendados, na maioria dos casos. O
motivo √© que pode-se selecionar diferentes valores de uma mesma classe
de equival√™ncia, o que n√£o √© necess√°rio. Por outro lado, algumas classes
de equival√™ncia podem ficar sem testes.</p>
<h3 data-number="8.10.3" id="testes-de-aceita√ß√£o"><span
class="header-section-number">8.10.3</span> Testes de Aceita√ß√£o <a
href="#testes-de-aceita√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>S√£o testes realizados pelo cliente, com dados do cliente. Os
resultados desses testes ir√£o determinar se o cliente est√° de acordo ou
n√£o com a implementa√ß√£o realizada. Se estiver de acordo, o sistema pode
entrar em produ√ß√£o. Se n√£o estiver de acordo, os devidos ajustes devem
ser realizados. Por exemplo, quando se usa m√©todos √°geis, uma hist√≥ria
somente √© considerada completa ap√≥s passar por testes de aceita√ß√£o,
realizados pelos usu√°rios, ao final de um sprint, conforme estudamos no
Cap√≠tulo 2.</p>
<p>Testes de aceita√ß√£o possuem duas caracter√≠sticas que os distinguem de
todos os testes que estudamos antes neste cap√≠tulo. Primeiro, s√£o
<strong>testes manuais</strong>, realizados pelos clientes finais do
sistema. Segundo, eles n√£o constituem exclusivamente uma atividade de
verifica√ß√£o (como os testes anteriores), mas tamb√©m uma atividade de
valida√ß√£o do sistema. Lembre-se do cap√≠tulo de Introdu√ß√£o: verifica√ß√£o
testa se fizemos o sistema corretamente, isto √©, de acordo com a sua
especifica√ß√£o e/ou requisitos. J√° valida√ß√£o testa se fizemos o sistema
correto, isto √©, aquele que o cliente pediu e precisa.</p>
<p> </p>
<p>Testes de aceita√ß√£o podem ser divididos em duas fases. <strong>Testes
alfa</strong> s√£o realizados com alguns usu√°rios, mas em um ambiente
controlado, como a pr√≥pria m√°quina do desenvolvedor. Se o sistema for
aprovado nos testes alfa, pode-se realizar um teste com um grupo maior
de usu√°rios e n√£o mais em um ambiente controlado. Esses testes s√£o
chamados de <strong>testes beta</strong>.</p>
<h3 data-number="8.10.4" id="testes-de-requisitos-n√£o-funcionais"><span
class="header-section-number">8.10.4</span> Testes de Requisitos
N√£o-Funcionais <a href="#testes-de-requisitos-n√£o-funcionais"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>Os testes anteriores, com exce√ß√£o dos testes de aceita√ß√£o, verificam
apenas requisitos funcionais; logo, eles t√™m como objetivo encontrar
bugs. Por√©m, √© poss√≠vel realizar tamb√©m testes para verificar ou validar
requisitos n√£o-funcionais. Por exemplo, existem ferramentas que permitem
a realiza√ß√£o de <strong>testes de desempenho</strong>, para verificar o
comportamento de um sistema com alguma carga. Uma empresa de com√©rcio
eletr√¥nico pode usar uma dessas ferramentas para simular o desempenho de
seu site durante um grande evento, como uma Black-Friday, por exemplo.
J√° <strong>testes de usabilidade</strong> s√£o usados para avaliar a
interface do sistema e, normalmente, envolvem a observa√ß√£o de usu√°rios
reais usando o sistema. <strong>Testes de falhas</strong> simulam
eventos anormais em um sistema, por exemplo a queda de alguns servi√ßos
ou mesmo de um data-center inteiro.</p>
<h2 class="unnumbered" id="bibliografia">Bibliografia <a
href="#bibliografia" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Gerard Meszaros. xUnit Test Patterns: Refactoring Test Code.
Addison-Wesley, 2007.</p>
<p>Kent Beck, Erich Gamma. Test-infected: programmers love writing
tests. Java Report, 3(7):37-50, 1998.</p>
<p>Kent Beck. Test-Driven Development: by Example, Addison-Wesley,
2002.</p>
<p>Dave Thomas and Andy Hunt. Mock Objects. IEEE Software, 2002</p>
<p>Maur√≠cio Aniche. Testes automatizados de software: um guia pr√°tico.
Casa do C√≥digo, 2015.</p>
<p>Jeff Langr, Andy Hunt, Dave Thomas. Pragmatic Unit Testing in Java 8
with Junit. O‚ÄôReilly, 2015.</p>
<h2 class="unnumbered" id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o
<a href="#exerc√≠cios-de-fixa√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>1. (ENADE 2011) Uma equipe est√° realizando testes com o c√≥digo-fonte
de um sistema. Os testes envolvem a verifica√ß√£o de diversos componentes
individualmente, bem como das interfaces entre eles. Essa equipe est√°
realizando testes de:</p>
<ol type="a">
<li>unidade</li>
<li>aceita√ß√£o</li>
<li>sistema e aceita√ß√£o</li>
<li>integra√ß√£o e sistema</li>
<li>unidade e integra√ß√£o</li>
</ol>
<p>2. Descreva tr√™s benef√≠cios associados ao uso de testes de
unidade.</p>
<p>3. Suponha uma fun√ß√£o <code>fib(n)</code>, que retorna o n-√©simo
termo da sequ√™ncia de Fibonacci, isto √©, <code>fib(0) = 0</code>,
<code>fib(1) = 1</code>, <code>fib(2) = 1</code>,
<code>fib(3) = 2</code>, <code>fib(4) = 3</code>, etc. Escreva um teste
de unidade para essa fun√ß√£o.</p>
<p>4. Reescreva o seguinte teste, que verifica o levantamento de uma
exce√ß√£o <code>EmptyStackException</code>, para que ele fique mais
simples e f√°cil de entender.</p>
<pre><code>@Test
public void testEmptyStackException() {
  boolean sucesso = false;
  try {
    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
    stack.push(10);
    int r = stack.pop();
    r = stack.pop();
  } catch (EmptyStackException e) {
    sucesso = true;
  }
  assertTrue(sucesso);
}</code></pre>
<p>5. Suponha que um programador escreveu o teste a seguir para a classe
<code>ArrayList</code> de Java. Como voc√™ ir√° perceber, no c√≥digo s√£o
usados diversos <code>System.out.println</code>. Ou seja, no fundo, ele
√© um teste manual, pois o desenvolvedor tem que conferir o seu resultado
manualmente. Reescreva ent√£o cada um dos testes (de 1 a 6) como um teste
de unidade, usando a sintaxe e os comandos do JUnit. Observa√ß√£o: se
quiser executar o c√≥digo, ele est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/11d9dce2bd37fe462003992835ebb1ba">link</a>.</p>
<pre><code>import java.util.List;
import java.util.ArrayList;

public class Main {

  public static void main(String[] args) {

    // teste 1  
    List&lt;Integer&gt; s = new ArrayList&lt;&gt;();
    System.out.println(s.isEmpty());

    // teste 2
    s = new ArrayList&lt;Integer&gt;();
    s.add(1);
    System.out.println(s.isEmpty());

    // teste 3
    s = new ArrayList&lt;Integer&gt;();
    s.add(1);
    s.add(2);
    s.add(3);
    System.out.println(s.size());
    System.out.println(s.get(0));
    System.out.println(s.get(1));
    System.out.println(s.get(2));

    // teste 4
    s = new ArrayList&lt;Integer&gt;();
    s.add(1);
    s.add(2);
    s.add(3);
    int elem = s.remove(2);
    System.out.println(elem);
    System.out.println(s.get(0));
    System.out.println(s.get(1));

    // teste 5
    s = new ArrayList&lt;Integer&gt;();
    s.add(1);
    s.remove(0);
    System.out.println(s.size());
    System.out.println(s.isEmpty());

    // teste 6
    try {
      s = new ArrayList&lt;Integer&gt;();
      s.add(1);
      s.add(2);
      s.remove(2);        
    }

    catch (IndexOutOfBoundsException e) {
      System.out.println(&quot;IndexOutOfBound&quot;);
    }

  }

}</code></pre>
<p>6. Seja a seguinte fun√ß√£o. Observe que ela possui quatro comandos,
sendo dois deles <code>if</code>. Logo, esses dois <code>ifs</code>
geram quatro branches:</p>
<pre><code>void f(int x, int y) {
  if (x &gt; 0) {
     x = 2 * x;
     if (y &gt; 0) {
        y = 2 * y;
     }
  }
}</code></pre>
<p>Supondo o c√≥digo acima, preencha a pr√≥xima tabela, com os valores da
cobertura de comandos e cobertura de branches obtidos com os testes
especificados na primeira coluna (ou seja, a primeira coluna define as
chamadas da fun√ß√£o <code>f</code> que o teste realiza).</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th>Chamada feita pelo teste</th>
<th>Cobertura de comandos</th>
<th>Cobertura de branches</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>f(0,0)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>f(1,1)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>f(0,0)</code> e <code>f(1,1)</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>7. Suponha o seguinte requisito: alunos recebem conceito A em uma
disciplina se tiverem nota maior ou igual a 90. Seja ent√£o a seguinte
fun√ß√£o que implementa esse requisito:</p>
<pre><code>boolean isConceitoA(int nota) {
  if (nota &gt; 90)
    return true;
  else return false;
}</code></pre>
<p>O c√≥digo dessa fun√ß√£o possui tr√™s comandos, sendo um deles um
<code>if</code>; logo, ela possui dois branches.</p>
<p>Responda agora √†s seguintes perguntas.</p>
<ol type="a">
<li><p>A implementa√ß√£o dessa fun√ß√£o possui um bug? Se sim, quando esse
bug resulta em falha?</p></li>
<li><p>Suponha que essa fun√ß√£o ‚Äî exatamente como ela est√° implementada ‚Äî
seja testada com duas notas: 85 e 95. Qual a cobertura de comandos desse
teste? E a cobertura de branches?</p></li>
<li><p>Seja a seguinte afirma√ß√£o: se um programa possui 100% de
cobertura de testes, em n√≠vel de comandos, ele est√° livre de bugs. Ela √©
verdadeira ou falsa? Justifique.</p></li>
</ol>
<p>8. Complete os comandos <code>assert</code> nos trechos
indicados.</p>
<pre><code>public void test1() {
   LinkedList list = mock(LinkedList.class);
   when(list.size()).thenReturn(10);
   assertEquals(___________, ___________);
}

public void test2() {
   LinkedList list = mock(LinkedList.class);
   when(list.get(0)).thenReturn(&quot;Engenharia&quot;);
   when(list.get(1)).thenReturn(&quot;Software&quot;);
   String result = list.get(0) + &quot; &quot; + list.get(1);
   assertEquals(___________, ___________);
}</code></pre>
<p>9. Suponha duas unidades de c√≥digo A e B, sendo que A depende de B.
Para permitir o teste de unidade de A foi criado um mock para B, chamado
B'. O teste de unidade de A est√° passando. Por√©m, ao fazer o teste de
integra√ß√£o com A e B, ele falha. Descreva um cen√°rio mais real, no qual
A, B, e B' sejam classes reais, com m√©todos reais, que realizam fun√ß√µes
reais, etc. O cen√°rio proposto deve incluir um bug associado ao mock B'.
Ou seja, B' esconde um bug, que s√≥ vai aparecer no teste de integra√ß√£o.
Dizendo de outra maneira, B' n√£o simula precisamente o comportamento de
B; quando B' √© removido, no teste de integra√ß√£o, surge ent√£o um bug.</p>
<h2 class="unnumbered">Perguntas Frequentes</h2>
<p>Veja tamb√©m o <a href="./faq/testes-faq.html">FAQ</a> deste cap√≠tulo.</p>
</main>

<footer class="container">
Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/YhKNRZjkHu7ASc7M8">formul√°rio</a>.
</footer>

<script>
  document.getElementById('dark-mode-toggle').addEventListener('click', function(event) {
    event.preventDefault();
    const currentTheme = document.documentElement.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', newTheme);
    this.textContent = newTheme === 'dark' ? 'Light Mode' : 'Dark Mode';
  });
</script>
</body>
</html>
