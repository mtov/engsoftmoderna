<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-8249107-3', 'auto');
     ga('send', 'pageview');
  </script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.1/mini-default.min.css">

  <style>
  body {
    background-color: #FCFCFC;
    foreground-color: black;
  }
  </style>
</head>
<body>
<div class="container">
<div class="row cols-sm-12 cols-md-10">
<div class="col-md-offset-1">
<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 id="cap.-2---processos">Cap. 2 - Processos</h1>
<blockquote>
<p>In software development, ‚Äúperfect‚Äù is a verb, not an adjective. There is no perfect process. There is no perfect design. There are no perfect stories. You can, however, perfect your process, your design, and your stories. ‚Äì Kent Beck</p>
</blockquote>
<p>Este cap√≠tulo inicia com uma apresenta√ß√£o sobre a import√¢ncia de processos de software (Se√ß√£o 2.1). Em seguida, discutimos quest√µes gerais e preliminares sobre processos √°geis de desenvolvimento de software (Se√ß√£o 2.2), incluindo uma apresenta√ß√£o sobre o contexto hist√≥rico que motivou o surgimento desse tipo de processo. As pr√≥ximas se√ß√µes tratam de tr√™s m√©todos √°geis: Extreme Programming (Se√ß√£o 2.3), Scrum (Se√ß√£o 2.4) e Kanban (Se√ß√£o 2.5). Depois, temos uma se√ß√£o dedicada a discutir quando m√©todos √°geis n√£o s√£o recomendados (Se√ß√£o 2.6). Por fim, na Se√ß√£o 2.7, discutimos alguns processos tradicionais, principalmente o Processo Unificado.</p>
<h1 id="import√¢ncia-de-processos">2.1 Import√¢ncia de Processos</h1>
<p>A produ√ß√£o de um carro em uma f√°brica de autom√≥veis segue um processo bem definido. Sem estender muito a explica√ß√£o, primeiro, as chapas de a√ßo s√£o cortadas e prensadas, para ganhar a forma de portas, tetos e cap√¥s. Depois, o carro √© pintado e instalam-se painel, bancos, cintos de seguran√ßa e toda a fia√ß√£o. Por fim, instala-se a parte mec√¢nica, incluindo motor, suspens√£o e freios.</p>
<p>Assim como carros, software tamb√©m √© produzido de acordo com um <strong>processo</strong>, embora certamente menos mec√¢nico e mais dependente de esfor√ßo intelectual. Um processo de desenvolvimento de software define um conjunto de passos, tarefas, eventos e pr√°ticas que devem ser seguidos por desenvolvedores de software, na produ√ß√£o de um sistema.</p>
<p>Alguns cr√≠ticos de processos de software costumam fazer a seguinte pergunta: por que eu preciso seguir um processo? E complementam, perguntando tamb√©m o seguinte: Qual processo Linus Torvalds usou na implementa√ß√£o do sistema operacional Linux? Ou que Donald Knuth usou na implementa√ß√£o do formatador de textos TeX?</p>
<p>Na verdade, a segunda parte da pergunta n√£o faz muito sentido, pois tanto o Linux (no seu in√≠cio) e o TeX s√£o projetos individuais, liderados por um √∫nico desenvolvedor. Nesses casos, a ado√ß√£o de um processo √© menos importante. Ou, dizendo de outra forma, o processo em tais projetos √© pessoal, composto pelos princ√≠pios, pr√°ticas e decis√µes tomadas pelo seu √∫nico desenvolvedor; e que ter√£o impacto apenas sobre ele mesmo.</p>
<p>Por√©m, os sistemas de software atuais s√£o por demais complexos para serem desenvolvidos por uma √∫nica pessoa. Por isso, casos de sistemas desenvolvidos por her√≥is ser√£o cada vez mais raros. Na pr√°tica, os sistemas modernos ‚Äî e que nos interessam neste livro ‚Äî s√£o desenvolvidos em <strong>equipes</strong>.</p>
<p>E essas equipes, para produzir software com qualidade e produtividade, precisam de um ordenamento, mesmo que m√≠nimo. Por isso, empresas d√£o tanto valor a processos de software. Eles s√£o o instrumento de que as empresas disp√µem para coordenar, motivar, organizar e avaliar o trabalho de seus desenvolvedores, de forma a garantir que eles trabalhem com produtividade e produzam sistemas alinhados com os objetivos da organiza√ß√£o. Sem um processo ‚Äî mesmo que simplificado e leve, como os processos √°geis que estudaremos neste cap√≠tulo ‚Äî existe o risco de que os times de desenvolvimento passem a trabalhar de forma descoordenada, gerando produtos sem valor para o neg√≥cio da empresa. Por fim, processos s√£o importantes n√£o apenas para a empresa, mas tamb√©m para os desenvolvedores, pois permitem que eles tomem consci√™ncia das tarefas e resultados que se esperam deles. Sem um processo, os desenvolvedores podem se sentir perdidos, trabalhando de forma err√°tica e sem alinhamento com os demais membros do time de desenvolvimento.</p>
<p>Neste cap√≠tulo, vamos estudar alguns processos de Software. Na verdade, no Cap√≠tulo 1 j√° comentamos sobre Processos Waterfall e √Ågeis. Na pr√≥xima se√ß√£o, vamos retomar essa discuss√£o e, em seguida, descrever alguns m√©todos de desenvolvimento de software.</p>
<h2 id="manifesto-√°gil">2.2 Manifesto √Ågil</h2>
<p>Conforme afirmado no Cap√≠tulo 1, os primeiros processos de desenvolvimento de software ‚Äî do tipo Waterfall, propostos ainda na d√©cada de 70 ‚Äî eram estritamente sequenciais, come√ßando com uma fase de especifica√ß√£o de requisitos at√© chegar √†s fases finais de implementa√ß√£o, testes e manuten√ß√£o do sistema.</p>
<p>Se considerarmos o contexto hist√≥rico, essa primeira vis√£o de processo era natural, visto que projetos de Engenharia tradicional tamb√©m s√£o sequenciais e precedidos de um planejamento detalhado. Todas as fases tamb√©m geram documenta√ß√µes detalhadas do produto que est√° sendo desenvolvido. Por isso, nada mais natural que a nascente Engenharia de Software se espelhasse nos processos de √°reas mais antigas e tradicionais, como a Engenharia Eletr√¥nica, Civil, Mec√¢nica, Aeron√°utica, etc.</p>
<p>No entanto, ap√≥s cerca de uma d√©cada, come√ßou-se a perceber que software √© diferente de outros produtos de Engenharia. Essa percep√ß√£o foi ficando clara devido aos problemas frequentes enfrentados por projetos de software nas d√©cadas de 70 a 90. Por exemplo, os cronogramas e or√ßamentos desses projetos n√£o eram obedecidos. N√£o raro, projetos inteiros eram cancelados, ap√≥s um ou mais anos de trabalho, sem entregar um sistema funcional para os clientes.</p>
<p>Em 1994, um relat√≥rio produzido pela empresa de consultoria Standish Group revelou informa√ß√µes mais detalhadas sobre os projetos de software da √©poca. Por exemplo, o relat√≥rio, que ficou conhecido pelo sugestivo nome de CHAOS Report (<a href="https://www.standishgroup.com/sample_research_files/chaos_report_1994.pdf">link</a>), mostrou que mais de 55% dos projetos estourava os prazos planejados entre 51% e 200%; pelo menos 12% estouraram os prazos acima de 200%, conforme mostra o pr√≥ximo gr√°fico:</p>
<figure>
<img src="figs/cap2/chaos2.png" style="width:50.0%" alt="" /><figcaption>CHAOS Report (1994): percentual de projetos que estourava seus <strong>prazos</strong> (para cada faixa de estouro).</figcaption>
</figure>
<p>Os resultados em termos de custos n√£o eram mais animadores: quase 40% dos projetos ultrapassava o or√ßamento entre 51% e 200%, conforme mostra o seguinte gr√°fico:</p>
<figure>
<img src="figs/cap2/chaos1.png" style="width:50.0%" alt="" /><figcaption>CHAOS Report (1994): percentual de projetos que estourava seus <strong>or√ßamentos</strong> (para cada faixa de estouro).</figcaption>
</figure>
<p>Em 2001, um grupo de profissionais da ind√∫stria se reuniu na cidade de Snowbird, no estado norte-americano de Utah, para discutir e propor uma alternativa aos processos do tipo Waterfall que ent√£o predominavam. Essencialmente, eles passaram a defender que software √© diferente de produtos tradicionais de Engenharia. Por isso, software tamb√©m demanda um processo de desenvolvimento diferente.</p>
<p>Por exemplo, os requisitos de um software mudam com frequ√™ncia, mais do que os requisitos de um computador (hardware), de um avi√£o ou de uma ponte. Al√©m disso, os clientes frequentemente n√£o t√™m uma ideia precisa do que querem. Ou seja, corre-se o risco de projetar por anos um produto que depois de pronto n√£o ser√° mais necess√°rio, ou porque o mundo mudou ou porque os planos e as necessidades dos clientes mudaram. Eles diagnosticaram ainda problemas referentes aos documentos prescritos por processos do tipo Waterfall, incluindo documentos de requisitos, fluxogramas, diagramas, etc. Esses documentos eram detalhados, pesados e extensos; assim, rapidamente se tornavam obsoletos, pois quando os requisitos mudavam os desenvolvedores n√£o propagavam as altera√ß√µes para a documenta√ß√£o, mas apenas para o c√≥digo fonte.</p>
<p>Ent√£o eles decidiram lan√ßar as bases para um novo conceito de processo de software, as quais foram registradas em um documento que chamaram de <strong>Manifesto √Ågil</strong>. Por ser curto, iremos reproduzir o texto do manifesto a seguir:</p>
<p>Por meio desse trabalho, passamos a valorizar:</p>
<blockquote>
<p><strong>Indiv√≠duos e intera√ß√µes</strong>, mais do que processos e ferramentas</p>
<p><strong>Software em funcionamento</strong>, mais do que documenta√ß√£o abrangente</p>
<p><strong>Colabora√ß√£o com o cliente</strong>, mais do que negocia√ß√£o de contratos</p>
<p><strong>Resposta a mudan√ßas</strong>, mais do que seguir um plano.</p>
</blockquote>
<p>A caracter√≠stica principal de processos √°geis √© a ado√ß√£o de <strong>ciclos curtos e iterativos de desenvolvimento</strong>, por meio dos quais um sistema √© implementado de forma gradativa; come√ßando por aquilo que √© mais urgente para o cliente. De in√≠cio, implementa-se uma primeira vers√£o do sistema, com as funcionalidades que segundo o cliente s√£o para "ontem", isto √©, possuem prioridade m√°xima. Em seguida, essa vers√£o √© validada pelo cliente. Se ela for aprovada, um novo ciclo ‚Äî ou <strong>itera√ß√£o</strong> ‚Äî inicia-se, com mais algumas funcionalidades, tamb√©m priorizadas pelos clientes. Normalmente, esses ciclos s√£o curtos, com dura√ß√£o de um m√™s, talvez at√© um pouco menos. Assim, o sistema vai sendo constru√≠do de forma incremental; sendo cada incremento devidamente aprovado pelos clientes. O desenvolvimento termina quando o cliente decide que todos os requisitos est√£o implementados.</p>
<p>As pr√≥ximas figuras comparam um desenvolvimento em Waterfall e um desenvolvimento √Ågil.</p>
<figure>
<img src="figs/cap2/waterfall.jpg" style="width:70.0%" alt="" /><figcaption>Exemplo de desenvolvimento usando um Processo Waterfall. O sistema fica pronto apenas no final.</figcaption>
</figure>
<figure>
<img src="figs/cap2/agile.jpg" style="width:70.0%" alt="" /><figcaption>Exemplo de desenvolvimento usando um Processo √Ågil. A cada itera√ß√£o (representadas pelos ret√¢ngulos) gera-se um incremento no sistema (S++), que j√° pode ser validado e testado pelos usu√°rios finais.</figcaption>
</figure>
<p>No entanto, a figura anterior pode sugerir que, em desenvolvimento √°gil, cada itera√ß√£o √© um mini-waterfall, incluindo todas as fases de um processo Waterfall. Isso n√£o √© verdadeiro; em geral, as itera√ß√µes em m√©todos √°geis n√£o s√£o um pipeline de tarefas, como em Waterfall (mais sobre isso nas pr√≥ximas se√ß√µes). A figura tamb√©m pode sugerir que ao final de cada itera√ß√£o tem-se que colocar um sistema em produ√ß√£o, para uso pelos usu√°rios finais. Isso tamb√©m n√£o √© verdade. De fato, o objetivo √© entregar um sistema funcional, isto √©, que realize tarefas √∫teis. Por√©m, a decis√£o de coloc√°-lo em produ√ß√£o envolve outras vari√°veis, como riscos para o neg√≥cio da empresa, disponibilidade de servidores, campanhas de marketing, elabora√ß√£o de manuais, treinamento de usu√°rios, etc.</p>
<p>Outras caracter√≠sticas de processos √°geis incluem:</p>
<ul>
<li><p><strong>Menor √™nfase em documenta√ß√£o</strong>, ou seja, apenas o essencial deve ser documentado.</p></li>
<li><p><strong>Menor √™nfase em planos detalhados</strong>, pois muitas vezes nem o cliente, nem os Engenheiros de Software t√™m, no in√≠cio de um projeto, uma ideia clara dos requisitos que devem ser implementados. Esse entendimento vai surgir ao longo do caminho, √† medida que incrementos de produto sejam produzidos e validados. Em outras palavras, o importante em desenvolvimento √°gil √© conseguir avan√ßar, mesmo em ambientes com informa√ß√µes imperfeitas, parciais e sujeitas a mudan√ßas.</p></li>
<li><p><strong>Inexist√™ncia de uma fase dedicada a design</strong> (<em>big upfront design</em>). Em vez disso, o design tamb√©m √© incremental. Ele evolui √† medida que o sistema vai nascendo, ao final de cada itera√ß√£o.</p></li>
<li><p><strong>Desenvolvimento em times pequenos</strong>, com cerca de uma dezena de desenvolvedores. Ou, em outras palavras, times que possam ser alimentados com duas pizzas, conforme popularizado pelo CEO da Amazon, Jeff Bezos.</p></li>
<li><p>√änfase em novas pr√°ticas de desenvolvimento (pelo menos, para o in√≠cio dos anos 2000), como <strong>programa√ß√£o em pares</strong>, <strong>testes automatizados</strong> e <strong>integra√ß√£o cont√≠nua</strong>.</p></li>
</ul>
<p>Devido a essas caracter√≠sticas, processos √°geis s√£o considerados <strong>processos leves</strong>, com poucas prescri√ß√µes e documentos.</p>
<p>No entanto, as caracter√≠sticas acima ainda s√£o gen√©ricas e abrangentes; por isso alguns m√©todos foram propostos para ajudar desenvolvedores a adotar os princ√≠pios √°geis, de forma mais concreta. O interessante √© que todos eles foram propostos, pelo menos na primeira vers√£o, antes do encontro de Utah, em 2001, que lan√ßou o Manifesto √Ågil. Neste cap√≠tulo, vamos estudar tr√™s m√©todos √°geis:</p>
<ul>
<li><p><strong>Extreme Programming (XP)</strong>, proposto por Kent Beck, em um livro lan√ßado em 1999 (<a href="https://dl.acm.org/citation.cfm?id=318762">link</a>). Uma segunda edi√ß√£o do livro, incluindo uma grande revis√£o, foi lan√ßada em 2004. Neste cap√≠tulo, vamos nos basear nessa edi√ß√£o mais recente.</p></li>
<li><p><strong>Scrum</strong>, proposto por Jeffrey Sutherland e Ken Schwaber, em um artigo publicado em 1995 (<a href="https://dl.acm.org/citation.cfm?id=260274">link</a>).</p></li>
<li><p><strong>Kanban</strong>, cujas origens remontam a um sistema de controle de produ√ß√£o que come√ßou a ser usado nas f√°bricas da Toyota, ainda na d√©cada de 50 (<a href="https://hbr.org/1986/01/the-new-new-product-development-game">link</a>). Nos √∫ltimos 10 anos, Kanban tem sido gradativamente adaptado para uso no desenvolvimento de software.</p></li>
</ul>
<p>üìö <strong>Aprofundamento</strong>: Neste livro, usamos os termos <strong>processos</strong> e <strong>m√©todos</strong>. Processo √© o conjunto de passos, etapas e tarefas que se usa para construir um software. Toda organiza√ß√£o usa um processo para desenvolver seus sistemas, o qual pode ser √°gil ou waterfall, por exemplo. Ou, talvez, esse processo pode ser ca√≥tico. Por√©m, o ponto que queremos refor√ßar √© que sempre existe um processo. J√° m√©todo, no nosso contexto, define e especifica um determinado processo de desenvolvimento (a palavra m√©todo tem sua origem no grego, onde significa "caminho para se chegar a um objetivo"). Assim, XP, Scrum e Kanban s√£o m√©todos √°geis ou, de modo mais extenso, s√£o m√©todos que definem pr√°ticas, atividades, eventos e t√©cnicas compat√≠veis com princ√≠pios √°geis de desenvolvimento de software. Aproveitando que estamos tratando de defini√ß√µes, frequentemente usa-se tamb√©m o termo <strong>metodologia</strong> quando se fala de processos de software. Por exemplo<strong>,</strong> √© comum ver refer√™ncias a metodologias para desenvolvimento de software, metodologias √°geis, metodologia orientada a objetos, etc. A palavra metodologia, no sentido mais estrito, denota o "ramo da l√≥gica que se ocupa dos m√©todos das diferentes ci√™ncias", segundo o Dicion√°rio Houaiss. No entanto, a palavra tamb√©m pode ser usada como sin√¥nimo de m√©todo, segundo o mesmo dicion√°rio. Apesar disso, nesse livro evitamos usar o termo metodologia e tentamos empregar sempre o termo m√©todo.</p>
<p>‚ö†Ô∏è <strong>Aviso</strong>: Todo m√©todo de desenvolvimento deve ser entendido como um conjunto de recomenda√ß√µes; cabe a uma organiza√ß√£o analisar cada uma e decidir se ela faz sentido no seu contexto. Como resultado, a organiza√ß√£o pode ainda decidir por adaptar essas recomenda√ß√µes para atender √†s suas necessidades.</p>
<p>Logo, provavelmente, n√£o existem duas organiza√ß√µes que seguem exatamente o mesmo processo de desenvolvimento, mesmo que elas digam que est√£o desenvolvendo usando Scrum, por exemplo.</p>
<p>üåé <strong>Mundo Real</strong>: O sucesso e impacto de processos √°geis foi impressionante. Hoje, a grande maioria das empresas que desenvolvem software, independente de seu tamanho ou do foco de seu neg√≥cio, usam princ√≠pios √°geis, em maior ou menor escala. Para citar alguns dados, em 2018, o Stack Overflow survey incluiu uma pergunta sobre o m√©todo de desenvolvimento mais usado pelos respondentes (<a href="https://insights.stackoverflow.com/survey/2018/#career-values">link</a>). Essa pergunta recebeu 57 mil respostas de desenvolvedores profissionais e os resultados s√£o mostrados no gr√°fico a seguir. Como se pode ver, a grande maioria das respostas mencionam m√©todos ou pr√°ticas √°geis, incluindo aquelas que vamos estudar neste cap√≠tulo, como Scrum (63%), Kanban (36%) e Extreme Programming (16%). Por outro lado, apenas 15% dos participantes marcaram Waterfall como resposta.</p>
<figure>
<img src="figs/cap2/so-survey.png" style="width:60.0%" alt="" /><figcaption>Stack Overflow survey 2018: Qual m√©todo de desenvolvimento voc√™ costuma usar? Resultados relativos a 57 mil respostas.</figcaption>
</figure>
<h2 id="extreme-programming-xp">2.3 Extreme Programming (XP)</h2>
<p>Segundo seu autor, XP √© um m√©todo leve recomendado para desenvolver software com requisitos vagos ou sujeitos a mudan√ßas; isto √©, basicamente sistemas comerciais, na classifica√ß√£o que adotamos no Cap√≠tulo 1. Sendo um m√©todo √°gil, XP possui todas as caracter√≠sticas que mencionamos na se√ß√£o anterior, isto √©: adota ciclos curtos e iterativos de desenvolvimento, concede menos √™nfase a documenta√ß√£o e planos detalhados, prop√µe que o design de um sistema tamb√©m seja definido de forma incremental e sugere que as equipes de desenvolvimento sejam pequenas.</p>
<p>Por√©m, XP n√£o √© um m√©todo prescritivo, que define um passo a passo detalhado para constru√ß√£o de software. Em vez disso, XP √© definido por meio de um conjunto de <strong>valores</strong>, <strong>princ√≠pios</strong> e <strong>pr√°ticas de desenvolvimento</strong>. Ou seja, XP √© inicialmente definido de forma abstrata, usando-se de valores e princ√≠pios que devem fazer parte da cultura e dos h√°bitos de times de desenvolvimento de software. Depois, esses valores e princ√≠pios s√£o concretizados em uma lista de pr√°ticas de desenvolvimento. Frequentemente, quando decidem adotar XP, desenvolvedores e organiza√ß√µes concentram-se nas pr√°ticas. Por√©m, os valores e princ√≠pios s√£o componentes chaves do m√©todo, pois s√£o eles que d√£o sentido √†s pr√°ticas propostas em XP. Sendo mais claro, se uma organiza√ß√£o n√£o est√° preparada para trabalhar no modelo mental de XP ‚Äî representado pelos seus valores e princ√≠pios ‚Äî recomenda-se tamb√©m n√£o adotar suas pr√°ticas.</p>
<p>Neste cap√≠tulo, vamos primeiro apresentar os valores e princ√≠pios de XP. Veja uma lista deles na pr√≥xima tabela.</p>
<table class="preset" style="width:65%;">
<colgroup>
<col style="width: 27%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Valores</strong></th>
<th><strong>Princ√≠pios</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Comunica√ß√£o</p>
<p>Simplicidade</p>
<p>Feedback</p>
<p>Coragem</p>
<p>Respeito</p>
<p>Qualidade de Vida</p></td>
<td><p>Humanidade</p>
<p>Economicidade</p>
<p>Benef√≠cios M√∫tuos</p>
<p>Melhorias Cont√≠nuas</p>
<p>Falhas Acontecem</p>
<p>Baby Steps</p>
<p>Responsabilidade Pessoal</p></td>
</tr>
</tbody>
</table>
<p>Em seguida, vamos descrever as pr√°ticas. Para facilitar a explica√ß√£o delas, resolvemos organiz√°-las em tr√™s grupos: pr√°ticas sobre o processo de desenvolvimento, pr√°ticas de programa√ß√£o e pr√°ticas de gerenciamento de projetos. A pr√≥xima tabela lista as pr√°ticas em cada grupo.</p>
<table class="preset" style="width:96%;">
<colgroup>
<col style="width: 31%" />
<col style="width: 31%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Pr√°ticas sobre o Processo de Desenvolvimento</strong></th>
<th><strong>Pr√°ticas de Programa√ß√£o</strong></th>
<th><strong>Pr√°ticas de Gerenciamento de Projetos</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Representante dos Clientes</p>
<p>Hist√≥rias de Usu√°rio</p>
<p>Itera√ß√µes</p>
<p>Releases</p>
<p>Planejamento de Releases</p>
<p>Planejamento de Itera√ß√µes</p>
<p>Planning Poker</p>
<p>Slack</p></td>
<td><p>Design Incremental</p>
<p>Programa√ß√£o Pareada</p>
<p>Testes Automatizados</p>
<p>Desenvolvimento Dirigido por Testes (TDD)</p>
<p>Build Automatizado</p>
<p>Integra√ß√£o Cont√≠nua</p></td>
<td><p>Ambiente de Trabalho</p>
<p>Contratos com Escopo Aberto</p>
<p>M√©tricas</p></td>
</tr>
</tbody>
</table>
<h3 id="valores">Valores</h3>
<p>XP defende que o desenvolvimento de projetos de software seja norteado por tr√™s valores principais: comunica√ß√£o, simplicidade e feedback. Na verdade, argumenta-se que esses valores s√£o universais, para conv√≠vio humano. Ou seja, eles n√£o servem apenas para guiar projetos de desenvolvimento, mas a pr√≥pria vida em sociedade. Uma boa <strong>comunica√ß√£o</strong> √© importante em qualquer projeto, n√£o apenas para evitar, mas tamb√©m para aprender com erros. O segundo valor de XP √© <strong>simplicidade</strong>, pois em todo sistema complexo e desafiador existem sistemas ou subsistemas mais simples, que √†s vezes n√£o s√£o considerados. Por √∫ltimo, existem riscos em todos os projetos de software: os requisitos mudam, a tecnologia muda, a equipe de desenvolvimento muda, o mundo muda, etc. Um valor que ajuda a controlar tais riscos √© estar aberto ao <strong>feedback</strong> dos stakeholders, a fim de que corre√ß√µes de rota sejam implementadas o quanto antes. Em outras palavras, √© dif√≠cil desenvolver o sistema de software "certo" em uma primeira e √∫nica tentativa. Frederick Brooks tem uma frase conhecida sobre esse fen√¥meno:</p>
<blockquote>
<p>Planeje-se para jogar fora algumas partes ou vers√µes de seu sistema, pois voc√™ far√° isso"</p>
</blockquote>
<p>Por isso, feedback √© um valor essencial para garantir que as partes ou vers√µes que ser√£o descartadas sejam identificadas o quanto antes, de forma a diminuir preju√≠zos e retrabalho. Al√©m dos tr√™s valores mencionados, XP tamb√©m defende outros valores, como <strong>coragem</strong>, <strong>respeito</strong> e <strong>qualidade de vida</strong>.</p>
<h3 id="princ√≠pios">Princ√≠pios</h3>
<p>Os valores que mencionamos s√£o abstratos e universais. Por outro lado, as pr√°ticas que vamos mencionar mais adiante s√£o procedimentos concretos e pragm√°ticos. Assim, para unir esses dois extremos, XP defende que projetos de software devem seguir um conjunto de princ√≠pios. A imagem que se apresenta √© de um rio: de um lado est√£o os valores e de outro as pr√°ticas. Os princ√≠pios ‚Äî que descreveremos agora ‚Äî fazem o papel de uma ponte ligando esses dois lados. Alguns dos principais princ√≠pios de XP s√£o os seguintes:</p>
<p><strong>Humanidade</strong> ("humanity", em ingl√™s). Software √© uma atividade intensiva no uso de capital humano. O principal recurso de uma empresa de software n√£o s√£o seus bens f√≠sicos ‚Äî computadores, pr√©dios, m√≥veis ou conex√µes de Internet, por exemplo ‚Äî mas sim seus colaboradores. Um termo que reflete bem esse princ√≠pio √© <em>peopleware,</em> o qual foi cunhado por Tom DeMarco, em um livro com o mesmo t√≠tulo (<a href="https://dl.acm.org/citation.cfm?id=2505459">link</a>). A ideia √© que a gest√£o de pessoas ‚Äî incluindo fatores como expectativas, crescimento, motiva√ß√£o, transpar√™ncia, responsabilidade, etc ‚Äî √© um princ√≠pio chave para o sucesso de projetos de software.</p>
<p><strong>Economicidade</strong> (<em>economics</em>, em ingl√™s). Se por um lado, <em>peopleware</em> √© fundamental, por outro lado software √© uma atividade cara, que demanda a aloca√ß√£o de recursos financeiros consider√°veis. Logo, tem-se que ter consci√™ncia de que o outro lado, isto √©, quem est√° pagando as contas do projeto, espera resultados econ√¥micos e financeiros. Por isso, na grande maioria dos casos, software n√£o pode ser desenvolvido apenas para satisfazer a vaidade intelectual de seus desenvolvedores. Software n√£o √© uma obra de arte, mas algo que tem que gerar resultados econ√¥micos, como defendido por esse princ√≠pio de XP.</p>
<p><strong>Benef√≠cios M√∫tuos</strong>. XP defende que as decis√µes tomadas em um projeto de software t√™m que beneficiar m√∫ltiplos stakeholders. Por exemplo, o contratante do software deve garantir um bom ambiente de trabalho (peopleware); em contrapartida, a equipe deve entregar um sistema que agregue valor ao seu neg√≥cio (economicidade). Mais um exemplo: ao escrever testes um desenvolvedor se beneficia, pois eles ajudam a detectar bugs no seu c√≥digo; mas testes tamb√©m ajudam outros desenvolvedores, que futuramente ter√£o mais seguran√ßa de que o seu c√≥digo n√£o vai introduzir regress√µes ‚Äî isto √©, bugs ‚Äî em c√≥digo que est√° funcionando. Um terceiro e √∫ltimo exemplo: refactoring √© uma atividade que torna o c√≥digo mais limpo e f√°cil de entender, tanto para quem o escreveu, como para quem futuramente ter√° que mant√™-lo. A frase "todo neg√≥cio tem que ser bom para os dois lados" resume bem esse terceiro princ√≠pio de XP.</p>
<p><strong>Melhorias Cont√≠nuas</strong> (no livro de XP, o nome original √© <em>improvements</em>): Como expressa a frase de Kent Beck que abre este cap√≠tulo, nenhum processo de desenvolvimento de software √© perfeito. Por isso, √© mais seguro trabalhar com um sistema que vai sendo continuamente aprimorado, a cada itera√ß√£o, com o feedback dos clientes e de todos os membros do time. Pelo mesmo motivo, XP n√£o recomenda investir um grande montante de tempo em um design inicial e completo. Em vez disso, o design do sistema tamb√©m √© incremental, melhorando a cada itera√ß√£o. Por fim, as pr√≥prias pr√°ticas de desenvolvimento podem ser aprimoradas; para isso, o time deve reservar tempo para refletir sobre elas.</p>
<p><strong>Falhas Acontecem</strong>. Desenvolvimento de software n√£o √© uma atividade livre de riscos. Como discutido no Cap√≠tulo 1, software √© uma das mais complexas constru√ß√µes humanas. Logo, falhas s√£o esperadas em projetos de desenvolvimento de software. No contexto desse princ√≠pio, falhas incluem bugs, funcionalidades que n√£o se mostraram interessantes para os usu√°rios finais e requisitos n√£o-funcionais que n√£o est√£o sendo plenamente atendidos, como desempenho, usabilidade, privacidade, disponibilidade, etc. Evidentemente, XP n√£o advoga que essas falhas devem ser acobertadas. Por√©m, elas n√£o devem ser usadas para punir membros de um time. Pelo contr√°rio, falhas fazem parte do jogo, se um time pretende avan√ßar, inovar e entregar software com rapidez.</p>
<p><strong>Baby Steps</strong>. √â melhor progressos seguros, testados e validados, mesmo que pequenos, do que grandes implementa√ß√µes com riscos de serem descartadas pelos usu√°rios. O mesmo vale para testes (que s√£o √∫teis mesmo quando as unidades testadas s√£o de menor granularidade), integra√ß√£o de c√≥digo (√© melhor integrar diariamente, do que passar pelo stress de fazer uma grande integra√ß√£o ap√≥s semanas de trabalho) e refatora√ß√µes (que devem ocorrer em pequenos passos, quando √© mais f√°cil verificar que o comportamento do sistema est√° sendo preservado). Em resumo, o importante √© garantir melhorias cont√≠nuas, n√£o importando que sejam pequenas, desde que na dire√ß√£o correta. Essas pequenas melhorias s√£o melhores do que grandes revolu√ß√µes, as quais costumam n√£o apresentar resultados positivos, pelo menos quando se trata de desenvolvimento de software.</p>
<p><strong>Responsabilidade Pessoal</strong> (que usamos como tradu√ß√£o para <em>accepted responsibility</em>). De acordo com esse princ√≠pio, desenvolvedores devem ter uma ideia clara de seu papel e responsabilidade na equipe. O motivo √© que responsabilidade n√£o pode ser transferida, sem que a outra parte a aceite. Por isso, XP defende que o engenheiro de software que implementa uma <em>hist√≥ria</em> ‚Äî termo que o m√©todo usa para requisito ‚Äî deve ser tamb√©m aquele que vai test√°-la e mant√™-la. Mais recentemente, times de desenvolvimento est√£o assumindo tamb√©m a responsabilidade de colocar seu c√≥digo em produ√ß√£o. Quando isso ocorre, eles s√£o chamados de times <em>devops</em>, que √© uma jun√ß√£o das palavras desenvolvedor e operador. Nesses casos, a ideia √© evitar dois grupos em uma organiza√ß√£o, desenvolvedores versus operadores, com um grupo empurrando a responsabilidade pelos problemas para o outro.</p>
<p>üåé <strong>Mundo Real</strong>: Um dos primeiros sistemas a adotar XP foi um sistema de folha de pagamentos da fabricante de autom√≥veis Chrysler, chamado Chrysler Comprehensive Compensation (C3) (<a href="https://doi.org/10.1109/2.796139">link</a>). O projeto desse sistema come√ßou no in√≠cio de 1995 e, como n√£o apresentou resultados concretos, ele foi reiniciado no ano seguinte, sob a lideran√ßa de Kent Beck. Outro membro conhecido da comunidade √°gil, Martin Fowler, participou do projeto, como consultor. No desenvolvimento do sistema C3, foram usadas e testadas diversas ideias do m√©todo que poucos anos depois receberia o nome de XP.</p>
<h3 id="pr√°ticas-sobre-o-processo-de-desenvolvimento">Pr√°ticas sobre o Processo de Desenvolvimento</h3>
<p>XP ‚Äî como outros m√©todos √°geis ‚Äî recomenda o envolvimento dos clientes com o projeto. Ou seja, al√©m de desenvolvedores, os times incluem pelo menos um <strong>representante dos clientes</strong>, que deve entender do dom√≠nio do sistema que ser√° constru√≠do. Uma das fun√ß√µes desse representante √© escrever as <strong>hist√≥rias de usu√°rio</strong> (<em>user stories</em>), que √© o nome que XP d√° para os documentos que descrevem os requisitos do sistema a ser implementado. No entanto, hist√≥rias s√£o documentos resumidos, com apenas duas ou tr√™s senten√ßas, com as quais o representante dos clientes define o que ele deseja que o sistema fa√ßa, usando sua pr√≥pria linguagem.</p>
<p>Iremos aprofundar o estudo sobre hist√≥rias de usu√°rios no Cap√≠tulo 3 (Engenharia de Requisitos). Mas, por enquanto, gostar√≠amos de adiantar que as hist√≥rias s√£o escritas em cart√µes de papel, normalmente a m√£o. Ou seja, em vez de documentos de requisitos detalhados, hist√≥rias s√£o documentos simples, que focam nas funcionalidades do sistema, sempre na vis√£o de seus usu√°rios. Como exemplo, mostramos a seguir uma hist√≥ria de um sistema de perguntas e respostas ‚Äî semelhante ao famoso Stack Overflow (<a href="https://stackoverflow.com">link</a>) ‚Äî que usaremos neste cap√≠tulo para explicar XP:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Postar Pergunta</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>Um usu√°rio, quando logado no sistema, deve ser capaz de postar perguntas. Como √© um site sobre programa√ß√£o, as perguntas podem incluir blocos de c√≥digo, os quais devem ser apresentados com um layout diferenciado.</em></td>
</tr>
</tbody>
</table>
<p>Depois de serem escritas pelo representante dos clientes, as hist√≥rias s√£o estimadas pelos desenvolvedores. Ou seja, s√£o os desenvolvedores que definem, mesmo que preliminarmente, quanto tempo ser√° necess√°rio para implementar as hist√≥rias escritas pelo representante dos clientes. Frequentemente, a dura√ß√£o de uma hist√≥ria √© estimada em <strong>story points</strong>, em vez de horas ou homens/hora. Nesses casos, usa-se uma escala inteira para classificar hist√≥rias como possuindo um certo n√∫mero de story points. O objetivo √© definir uma ordem relativa entre as hist√≥rias. As hist√≥rias mais simples s√£o estimadas como tendo tamanho igual a 1 story point; hist√≥rias que s√£o cerca de duas vezes mais complexas do que as primeiras s√£o estimadas como tendo 2 story points e assim por diante. Muitas vezes, usa-se tamb√©m uma sequ√™ncia de Fibonacci para definir a escala de poss√≠veis story points, como em 1, 2, 3, 5, 8, 13 story points. Nesse caso, o objetivo √© criar uma escala que torne as tarefas progressivamente mais dif√≠ceis e, ao mesmo tempo, permita ao time realizar compara√ß√µes similares √† seguinte: ser√° que o esfor√ßo para implementar essa tarefa que planejamos estimar com 8 story points √© equivalente ao esfor√ßo de implementar uma tarefa na escala anterior (5 story points) e mais uma tarefa na pr√≥xima escala inferior (3 pontos)? Se isso for verdade, 8 story points √© uma boa estimativa. Caso contr√°rio, o melhor √© estimar a hist√≥ria com 5 story points.</p>
<p>üìö <strong>Aprofundamento</strong>: Uma t√©cnica usada para estimar o tamanho de hist√≥rias √© conhecida como <strong>Planning Poker</strong>. Ela funciona assim: o representante dos clientes seleciona uma hist√≥ria e a l√™ para os desenvolvedores. Ap√≥s a leitura, os desenvolvedores interagem com o representante dos clientes para tirar poss√≠veis d√∫vidas e conhecer melhor a hist√≥ria. Feito isso, cada desenvolvedor faz sua estimativa para o tamanho da hist√≥ria, de forma independente. Depois disso, eles ao mesmo tempo levantam cart√µes com a estimativa que pensaram, em story points. Esses cart√µes foram distribu√≠dos antes e deles constam os n√∫meros 1, 2, 3, 5, etc. Se houver consenso, o tamanho da hist√≥ria est√° estimado e passa-se para a pr√≥xima hist√≥ria. Sen√£o, o time deve iniciar uma discuss√£o, para esclarecer a raz√£o das diferentes estimativas. Por exemplo, os desenvolvedores respons√°veis pelas estimativas mais discrepantes podem explicar o motivo da sua proposta. Feito isso, realiza-se uma nova vota√ß√£o e o processo se repete, at√© que o consenso seja alcan√ßado.</p>
<p>A implementa√ß√£o das hist√≥rias ocorre em <strong>itera√ß√µes</strong>, as quais t√™m uma dura√ß√£o fixa e bem definida, variando de uma a tr√™s semanas, por exemplo. As itera√ß√µes, por sua vez, formam ciclos mais longos, chamados de <strong>releases</strong>, de dois a tr√™s meses, por exemplo. A <strong>velocidade</strong> de um time √© o n√∫mero de story points que ele consegue implementar em uma itera√ß√£o. Sugere-se que o representante dos clientes escreva hist√≥rias que requeiram pelo menos uma release para serem implementadas. Ou seja, em XP, o horizonte de planejamento √© uma release, isto √©, alguns meses.</p>
<p>‚ö†Ô∏è <strong>Aviso</strong>: Em XP, a palavra release tem um sentido diferente daquele que se usa em ger√™ncia de configura√ß√£o. Em ger√™ncia de configura√ß√£o, uma release √© uma vers√£o de um sistema que ser√° disponibilizada para seus usu√°rios finais. Como j√° mencionamos em um aviso anterior, n√£o necessariamente a vers√£o do sistema ao final de uma release de XP precisa entrar em produ√ß√£o.</p>
<p>Em resumo, para come√ßar a usar XP precisamos de:</p>
<ul>
<li><p>Definir a dura√ß√£o de uma itera√ß√£o.</p></li>
<li><p>Definir o n√∫mero de itera√ß√µes de uma release.</p></li>
<li><p>Um conjunto de hist√≥rias, escritas pelo representante dos clientes.</p></li>
<li><p>Estimativas para cada hist√≥ria, feitas pelos desenvolvedores.</p></li>
<li><p>Definir a velocidade do time, isto √©, o n√∫mero de story points que ele consegue implementar por itera√ß√£o.</p></li>
</ul>
<p>Uma vez definidos os par√¢metros e documentos acima, o representante do cliente deve priorizar as hist√≥rias. Para isso, ele deve definir quais hist√≥rias ser√£o implementadas nas itera√ß√µes da primeira release. Nesta prioriza√ß√£o, deve-se respeitar a velocidade do time de desenvolvimento. Por exemplo, suponha que a velocidade de um time seja de 25 story points por itera√ß√£o. Nesse caso, o representante do cliente n√£o pode alocar hist√≥rias para uma itera√ß√£o cujo somat√≥rio de story points ultrapasse esse limite. A tarefa de alocar hist√≥rias a itera√ß√µes e releases √© chamada de <strong>planejamento de releases</strong> (ou ent√£o <em>planning game</em>, que foi o nome adotado na primeira edi√ß√£o do livro de XP).</p>
<p>Por exemplo, suponha o f√≥rum de perguntas e respostas que mencionamos antes. A pr√≥xima tabela resume o resultado de um poss√≠vel planejamento de releases. Nessa tabela, estamos assumindo que o representante dos clientes escreveu 8 hist√≥rias, que cada release possui duas itera√ß√µes e que a velocidade do time √© de 21 story points por itera√ß√£o (veja que o somat√≥rio dos story points de cada itera√ß√£o √© exatamente igual a 21).</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Hist√≥ria</strong></th>
<th style="text-align: left;"><strong>Story Points</strong></th>
<th style="text-align: left;"><strong>Itera√ß√£o</strong></th>
<th style="text-align: left;"><strong>Release</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Cadastrar usu√°rio</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Postar perguntas</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Postar respostas</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tela de abertura</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Gamificar perguntas e respostas</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pesquisar perguntas e respostas</td>
<td style="text-align: left;">8</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Adicionar tags em perguntas e respostas</td>
<td style="text-align: left;">5</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Comentar perguntas e respostas</td>
<td style="text-align: left;">3</td>
<td style="text-align: left;">2</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<p>A tabela anterior serve para refor√ßar dois pontos j√° mencionados: (1) as hist√≥rias em XP representam funcionalidades do sistema que se pretende construir; isto √©, a implementa√ß√£o do sistema √© dirigida por suas funcionalidades; (2) os desenvolvedores n√£o opinam sobre a ordem de implementa√ß√£o das hist√≥rias; isso √© decidido pelo representante dos clientes, que deve ser algu√©m capacitado e com autoridade para definir o que √© mais urgente e importante para a empresa que est√° contratando o desenvolvimento do sistema.</p>
<p>Uma vez realizado o planejamento de uma release, come√ßam as itera√ß√µes. Antes de mais nada, o time de desenvolvimento deve se reunir para realizar o <strong>planejamento da itera√ß√£o.</strong> O objetivo desse planejamento √© decompor as hist√≥rias de uma itera√ß√£o em tarefas, as quais devem corresponder a atividades de programa√ß√£o que possam ser alocadas para um dos desenvolvedores do time. Por exemplo, a seguinte lista mostra as tarefas para a hist√≥ria "Postar Perguntas", que √© a primeira hist√≥ria que ser√° implementada em nosso sistema de exemplo.</p>
<ul>
<li><p>Projetar e testar a interface Web, incluindo layout, CSS templates, etc.</p></li>
<li><p>Instalar banco de dados, projetar e criar tabelas.</p></li>
<li><p>Implementar a camada de acesso a dados.</p></li>
<li><p>Instalar servidor e testar framework web.</p></li>
<li><p>Implementar camada de controle, com opera√ß√µes para cadastrar, remover e atualizar perguntas.</p></li>
<li><p>Implementar interface Web.</p></li>
</ul>
<p>Como regra geral, as tarefas n√£o devem ser complexas, devendo ser poss√≠vel conclu√≠-las em alguns dias.</p>
<p>Resumindo, um projeto XP √© organizado em:</p>
<ul>
<li><p>releases, que s√£o conjunto de itera√ß√µes, com dura√ß√£o total de alguns meses.</p></li>
<li><p>itera√ß√µes, que s√£o conjuntos de tarefas, com dura√ß√£o total de algumas semanas.</p></li>
<li><p>tarefas, com dura√ß√£o de alguns dias.</p></li>
</ul>
<p>Definidas as tarefas, o time deve decidir qual desenvolvedor ser√° respons√°vel por cada uma. Feito isso, come√ßa de fato a itera√ß√£o, com a implementa√ß√£o das tarefas.</p>
<p>Uma itera√ß√£o termina quando todas a suas hist√≥rias estiverem implementadas e validadas pelo representante dos clientes. Assim, ao fim de uma itera√ß√£o, as hist√≥rias devem ser mostradas para o representante dos clientes, que deve concordar que elas, de fato, atendem ao que ele especificou.</p>
<p>XP defende ainda que os times, durante uma itera√ß√£o, programem algumas <strong>folgas</strong> (<em>slacks</em>), que s√£o tarefas que podem ser adiadas, caso necess√°rio. Como exemplos, podemos citar o estudo de uma nova tecnologia, a realiza√ß√£o de um curso online, preparar uma documenta√ß√£o ou manual ou mesmo desenvolver um projeto paralelo. Algumas empresas, como o Google, por exemplo, s√£o famosas por permitir que seus desenvolvedores usem 20% de seu tempo para desenvolver um projeto pessoal (<a href="https://arxiv.org/abs/1702.01715">link</a>). No caso de XP, folgas t√™m dois objetivos principais: (1) criar um "buffer de seguran√ßa" em uma itera√ß√£o, que possa ser usado caso alguma tarefa demande mais tempo do que o previsto; (2) permitir que os desenvolvedores respirem um pouco, pois o ritmo de trabalho em projetos de desenvolvimento de software costuma ser intenso e desgastante. Logo, os desenvolvedores precisam de um tempo para realizarem algumas tarefas onde n√£o exista uma cobran√ßa de resultados, entregas, etc.</p>
<p>üí°<strong>Perguntas Frequentes</strong>: Vamos agora responder a algumas perguntas sobre as pr√°ticas de XP que acabamos de explicar.</p>
<p><strong>Qual a dura√ß√£o ideal de uma itera√ß√£o</strong>? Dif√≠cil precisar, pois depende das caracter√≠sticas do time, da empresa contratante, da complexidade do sistema a ser desenvolvido, etc. Itera√ß√µes curtas ‚Äî por exemplo, de uma semana ‚Äî propiciam feedback mais r√°pido. Por√©m, requerem um maior comprometimento dos clientes, pois toda semana um novo incremento de produto deve ser validado. Al√©m disso, requerem que as hist√≥rias sejam mais simples. Por outro lado, itera√ß√µes mais longas ‚Äî por exemplo, de um m√™s ‚Äî permitem que o time planeje e conclua as tarefas com mais tranquilidade. Por√©m, demora-se um pouco mais para receber feedback dos clientes. Esse feedback pode ser importante quando os requisitos s√£o pouco claros. Por isso, uma escolha de compromisso seria algo como 2 ou 3 semanas. Outra alternativa recomendada consiste em experimentar, isto √©, testar e avaliar diferentes dura√ß√µes, antes de decidir.</p>
<p><strong>O que o representante dos clientes faz durante as itera√ß√µes?</strong> No in√≠cio de uma release, cabe ao representante dos clientes escrever as hist√≥rias das itera√ß√µes que far√£o parte dessa release. Depois, no final de cada itera√ß√£o, cabe a ele validar e aprovar a implementa√ß√£o das hist√≥rias. Por√©m, durante as itera√ß√µes, ele deve estar fisicamente dispon√≠vel para tirar d√∫vidas do time. Veja que uma hist√≥ria √© um documento muito resumido, logo √© natural que surjam d√∫vidas durante a sua implementa√ß√£o. Por isso, o representante dos clientes deve estar sempre dispon√≠vel para se reunir com os desenvolvedores, para tirar d√∫vidas e explicar detalhes relativos √† implementa√ß√£o de hist√≥rias.</p>
<p><strong>Como escolher o representante dos clientes?</strong> Antes de mais nada, deve ser algu√©m que conhe√ßa o dom√≠nio do sistema e que tenha autoridade para priorizar hist√≥rias. Conforme detalhado a seguir, existem pelo menos tr√™s perfis de representante dos clientes:</p>
<ul>
<li><p>Suponha o desenvolvimento interno de um sistema, isto √©, o departamento de sistemas da empresa X est√° desenvolvendo um sistema para um outro departamento Y, da mesma empresa. Nesse caso, o representante dos clientes deve ser um funcion√°rio do departamento Y.</p></li>
<li><p>Suponha que o time de desenvolvimento foi contratado para desenvolver um sistema para a empresa X. Ou seja, trata-se de um desenvolvimento terceirizado. Nesse caso, o representante do cliente deve ser um funcion√°rio da empresa X, com pleno dom√≠nio da √°rea do sistema e que vai ser um dos seus principais usu√°rios, quando ele ficar pronto.</p></li>
<li><p>Suponha que o time de desenvolvimento de uma empresa X foi designado para fazer um sistema para um p√∫blico externo √† empresa. Por exemplo, um sistema como aquele usado neste cap√≠tulo, similar ao Stack Overflow. Logo, os clientes do sistema n√£o s√£o funcion√°rios de X, mas sim clientes externos. Nesse caso, o representante dos clientes deve ser algu√©m da √°rea de marketing, vendas ou neg√≥cios da empresa X. Em √∫ltima inst√¢ncia, pode ser o dono da empresa. Em qualquer caso, a sugest√£o √© que seja uma pessoa pr√≥xima do problema e o mais distante poss√≠vel da solu√ß√£o. Por isso mesmo, deve-se evitar que ele seja um desenvolvedor ou um gerente de projeto. O tipo de representante dos clientes que mencionamos neste item √©, √†s vezes, chamado de um <strong>user proxy</strong>.</p></li>
</ul>
<p><strong>Como definir a velocidade do time?</strong> N√£o existe bala de prata para essa quest√£o. Essa defini√ß√£o depende da experi√™ncia do time e de seus membros. Se eles j√° participaram de projetos semelhantes √†quele que est√£o iniciando, certamente essa deve ser uma quest√£o menos dif√≠cil. Caso contr√°rio, tem-se que experimentar e ir calibrando a velocidade nas itera√ß√µes seguintes.</p>
<p><strong>Hist√≥rias podem incluir tarefas de instala√ß√£o de infra-estrutura de software?</strong> N√£o, hist√≥rias s√£o especificadas pelo representante dos clientes, que √© um profissional leigo em Engenharia de Software. Portanto, ele n√£o costuma ter conhecimento de infra-estrutura de software. No entanto, uma hist√≥ria pode dar origem a uma tarefa como "instalar e testar o banco de dados". Resumindo, hist√≥rias est√£o associadas a requisitos funcionais; para implement√°-las criam-se tarefas, que podem estar associadas a requisitos funcionais, n√£o-funcionais ou tarefas t√©cnicas, como instala√ß√£o de bancos de dados, servidores, frameworks, etc.</p>
<p><strong>A hist√≥ria X depende da hist√≥ria Y, mas o representante dos clientes priorizou Y antes de X. O que devo fazer?</strong> Por exemplo, suponha que no sistema de exemplo o representante dos clientes tenha alocado a hist√≥ria "Postar Pergunta" para a itera√ß√£o 2 e a hist√≥ria "Postar Resposta" para a itera√ß√£o 1. A pergunta ent√£o √© a seguinte: o time deve respeitar essa aloca√ß√£o? Sim, pois a regra √© clara: o representante dos clientes √© a autoridade final quando trata-se de definir a ordem de implementa√ß√£o das hist√≥rias. Logo, pode-se perguntar em seguida: como que vamos postar respostas, sem ter as perguntas? Para isso, basta implementar algumas perguntas "fixas", que n√£o possam ser modificadas pelos usu√°rios. Na itera√ß√£o 1, quando o cliente abrir o sistema, essas perguntas v√£o aparecer por default, talvez com um layout bem simples, e ent√£o o cliente vai poder usar o sistema apenas para responder essas perguntas fixas.</p>
<p><strong>Quando um projeto XP termina?</strong> Quando o representante dos clientes decide que as hist√≥rias j√° implementadas s√£o suficientes e que n√£o h√° mais nada de relevante que deva ser implementado.</p>
<h3 id="pr√°ticas-de-programa√ß√£o">Pr√°ticas de Programa√ß√£o</h3>
<p>O nome Extreme Programming foi escolhido porque XP prop√µe um conjunto de pr√°ticas de programa√ß√£o inovadoras, principalmente para a √©poca na qual foram propostas, no final da d√©cada de 90. Na verdade, XP √© um m√©todo que d√° grande import√¢ncia √† tarefa de programa√ß√£o e produ√ß√£o de c√≥digo. Essa import√¢ncia tem que ser entendida no contexto da √©poca, onde havia uma diferen√ßa entre analistas e programadores. Analistas eram encarregados de elaborar o projeto em alto n√≠vel de um sistema, definindo seus principais componentes, classes e interfaces. Para isso, recomendava-se o uso de uma linguagem de modelagem gr√°fica, como UML, que veremos em um dos pr√≥ximos cap√≠tulos desse livro. Conclu√≠da a fase de an√°lise e projeto, come√ßava a fase de codifica√ß√£o, que ficava a cargo dos programadores. Assim, na pr√°tica, existia uma hierarquia nesses pap√©is, sendo o papel de analista o de maior prest√≠gio. M√©todos √°geis ‚Äî e, particularmente, XP ‚Äî acabaram com essa hierarquia e passaram a defender a produ√ß√£o de c√≥digo com funcionalidades, logo nas primeiras semanas de um projeto.</p>
<p>Mas XP n√£o apenas acabou com a grande fase de projeto e an√°lise, logo no in√≠cio dos projetos. O m√©todo tamb√©m prop√¥s um novo conjunto de pr√°ticas de programa√ß√£o, incluindo programa√ß√£o em pares, testes automatizados, desenvolvimento dirigido por testes (TDD), builds automatizados, integra√ß√£o cont√≠nua, etc. A maioria dessas pr√°ticas passou a ser largamente adotada pela ind√∫stria de software e hoje s√£o praticamente obrigat√≥rias na maioria dos projetos ‚Äî mesmo naqueles que n√£o usam um m√©todo √°gil. Nessa se√ß√£o, vamos estudar as pr√°ticas de programa√ß√£o de XP.</p>
<p><strong>Design Incremental</strong>. Como afirmado nos par√°grafos anteriores, em XP n√£o h√° uma fase de design e an√°lise detalhados, conhecida como <em>big design upfront</em> (BDUF), a qual √© uma das principais fases de processos do tipo Waterfall. A ideia √© que o time deve reservar tempo para definir o design do sistema que est√° sendo desenvolvido. Por√©m, isso deve ser uma atividade cont√≠nua e incremental, em vez de estar concentrada no in√≠cio do projeto, antes de qualquer codifica√ß√£o. No caso, simplicidade √© o valor de XP que norteia essa op√ß√£o por um design tamb√©m incremental. Argumenta-se que quando o design √© confinado no in√≠cio do projeto, correm-se diversos riscos, pois os requisitos ainda n√£o est√£o totalmente claros para o time, e nem mesmo para o representante dos clientes. Por exemplo, pode-se supervalorizar alguns requisitos, que mais tarde ir√£o se revelar menos importantes; de forma inversa, pode-se subvalorizar outros requisitos, que depois, com o decorrer da implementa√ß√£o, ir√£o assumir um maior protagonismo. Isso sem falar que novos requisitos podem surgir ao longo do projeto, tornando o design inicial desatualizado.</p>
<p>Por isso, XP defende que o momento ideal para pensar em <em>design</em> √© quando ele se revelar importante. Frequentemente, duas frases s√£o usadas para motivar e justificar essa pr√°tica: "<em>do the simplest thing that could possibly work</em>" e "<em>you aren't going to need it</em>", essa √∫ltima conhecida pela sigla YAGNI.</p>
<p>Duas observa√ß√µes s√£o importantes para melhor entender a proposta de design incremental. Primeiro, times experientes costumam ter uma boa aproxima√ß√£o do design logo na primeira itera√ß√£o. Por exemplo, eles j√° sabem que se trata de um sistema com interface Web, com uma camada de l√≥gica n√£o trivial, mas tamb√©m n√£o t√£o complexa, e depois com uma camada de persist√™ncia e um banco de dados, certamente relacional. Ou seja, apenas a senten√ßa anterior j√° define muito do design que deve ser adotado. Como uma segunda observa√ß√£o, nada impede que na primeira itera√ß√£o o time crie uma tarefa t√©cnica para discutir e refinar o design que v√£o come√ßar a adotar no sistema.</p>
<p>Por fim, design incremental somente √© poss√≠vel caso seja adotado em conjunto com as demais pr√°ticas de XP, principalmente <strong>refactoring</strong>. XP defende que refactoring deve ser continuamente aplicado para melhorar a qualidade do design. Por isso, toda oportunidade de refatora√ß√£o, visando facilitar o entendimento e a evolu√ß√£o do c√≥digo, n√£o pode ser deixada para depois.</p>
<p><strong>Programa√ß√£o em Pares</strong>. Junto com design incremental, programa√ß√£o em pares √© uma das pr√°ticas mais pol√™micas de XP. Apesar de pol√™mica, a ideia √© simples: toda tarefa de codifica√ß√£o ‚Äî incluindo implementa√ß√£o de uma nova hist√≥ria, de um teste, ou a corre√ß√£o de um bug ‚Äî deve ser realizada por dois desenvolvedores trabalhando juntos, compartilhando o mesmo teclado e monitor, como mostra a pr√≥xima figura. Um dos desenvolvedores √© o <strong>l√≠der</strong> (ou <em>driver</em>) da sess√£o, ficando com o teclado e o mouse. Ao segundo desenvolvedor cabe a fun√ß√£o de revisor e questionador, no bom sentido, do trabalho do l√≠der. √Äs vezes , esse segundo desenvolvedor √© chamado de <strong>navegador</strong>. A inspira√ß√£o vem dos ralis automobil√≠sticos, onde os pilotos s√£o acompanhados de um navegador.</p>
<p>Com programa√ß√£o em pares espera-se melhorar a qualidade do c√≥digo e do design, pois "duas cabe√ßas pensam melhor do que uma." Al√©m disso, programa√ß√£o em pares contribui para disseminar o conhecimento sobre o c√≥digo, que n√£o fica nas m√£os e na cabe√ßa de apenas um desenvolvedor. Por exemplo, n√£o √© raro encontrar sistemas nos quais um determinado desenvolvedor tem dificuldade para sair de f√©rias, pois apenas ele conhece uma parte cr√≠tica do c√≥digo. Como uma terceira vantagem, programa√ß√£o por pares pode ser usada para treinar desenvolvedores menos experientes em tecnologias de desenvolvimento, algoritmos e estruturas de dados, padr√µes e princ√≠pios de design, escrita de testes, t√©cnicas de depura√ß√£o, etc.</p>
<p>Por outro lado, existem tamb√©m custos econ√¥micos derivados da ado√ß√£o de programa√ß√£o em pares, j√° que dois programadores est√£o sendo alocados para realizar uma tarefa que, a princ√≠pio, poderia ser realizada por apenas um. Al√©m disso, muitos desenvolvedores n√£o se sentem confort√°veis com a pr√°tica. Para eles √© desconfort√°vel ‚Äî do ponto de vista emocional e cognitivo ‚Äî discutir cada linha de c√≥digo e cada decis√£o de implementa√ß√£o com um colega. Para aliviar esse desconforto, XP prop√µe que os pares sejam trocados a cada sess√£o. Elas podem durar, por exemplo, 50 minutos, seguidos de uma pausa de 10 minutos para descanso. Na pr√≥xima sess√£o, os pares e pap√©is (l√≠der vs revisor) s√£o trocados. Assim, se em uma sess√£o voc√™ atuou como revisor do programador X, na sess√£o seguinte voc√™ passar√° a ser o l√≠der, mas tendo outro desenvolvedor Y como revisor.</p>
<figure>
<img src="figs/cap2/pair-programming.png" style="width:40.0%" alt="" /><figcaption>Programa√ß√£o em pares, tal como proposto por XP. Foto da <a href="https://commons.wikimedia.org/wiki/File:Pair_programming_1.jpg">Wikipedia</a>, licen√ßa CC-BY.</figcaption>
</figure>
<p>üåé <strong>Mundo Real</strong>: Em 2008, dois pesquisadores da Microsoft Research, Andrew Begel e Nachiappan Nagappan, realizaram um survey com 106 desenvolvedores da empresa, para capturar a percep√ß√£o deles sobre programa√ß√£o em pares (<a href="https://doi.org/10.1145/1414004.1414026">link</a>). Quase 65% dos desenvolvedores responderam positivamente a uma primeira pergunta sobre se programa√ß√£o em pares estaria funcionando bem para eles ("<em>pair programming is working well for me</em>"). Quando perguntados sobre os benef√≠cios de programa√ß√£o em pares, as respostas foram as seguintes: redu√ß√£o no n√∫mero de bugs (62%), produ√ß√£o de c√≥digo de melhor qualidade (45%), dissemina√ß√£o de conhecimento sobre o c√≥digo (40%) e oportunidade de aprendizado com os pares (40%). Por outro lado, os custos da pr√°tica foram apontados como sendo seu principal problema (75%). Sobre as caracter√≠sticas do par ideal, a resposta mais comum foi complementaridade de habilidades (38%). Ou seja, desenvolvedores preferem parear com uma pessoa que o ajude a superar seus pontos fracos.</p>
<p>Mais recentemente, diversas empresas passaram a adotar a pr√°tica de <strong>revis√£o de c√≥digo</strong>. A ideia √© que todo c√≥digo produzido por um desenvolvedor tem que ser revisado e comentado por um outro desenvolvedor, por√©m de forma offline e ass√≠ncrona. Ou seja, nesses casos, o revisor n√£o trabalha fisicamente ao lado do l√≠der. Iremos comentar mais sobre revis√£o de c√≥digo no cap√≠tulo sobre Qualidade de Software.</p>
<p><strong>Propriedade Coletiva do C√≥digo</strong>. A ideia √© que qualquer desenvolvedor ‚Äî ou par de desenvolvedores trabalhando junto ‚Äî pode modificar qualquer parte do c√≥digo, seja para implementar uma nova feature, para corrigir um bug ou para aplicar um refactoring. Por exemplo, se voc√™ descobriu um bug em algum ponto do c√≥digo, v√° em frente e corrija-o. Para isso, voc√™ n√£o precisa de autoriza√ß√£o de quem implementou esse c√≥digo ou de quem realizou a √∫ltima manuten√ß√£o nele.</p>
<p><strong>Testes Automatizados</strong>. Essa √© uma das pr√°ticas de XP que alcan√ßou maior sucesso. A ideia √© que testes manuais ‚Äî um ser humano executando o programa, fornecendo entradas e checando as sa√≠das produzidas ‚Äî √© um procedimento custoso e que n√£o pode ser reproduzido a todo momento. Logo, XP prop√µe a implementa√ß√£o de programas ‚Äî chamados de testes ‚Äî para executar pequenas unidades de um sistema, como m√©todos, e verificar se as sa√≠das produzidas s√£o aquelas esperadas. Essa pr√°tica prosperou porque, mais ou menos na mesma √©poca de sua proposi√ß√£o, foram desenvolvidos os primeiros frameworks de testes de unidade ‚Äî como o JUnit, cuja primeira vers√£o, implementada por Kent Beck e Erich Gamma, √© de 1997. No momento, n√£o iremos estender a discuss√£o sobre testes automatizados porque vamos ter um cap√≠tulo exclusivo para isso no livro.</p>
<p><strong>Desenvolvimento Dirigido por Testes (TDD).</strong> Essa √© outra pr√°tica de programa√ß√£o inovadora proposta por XP. A ideia √© simples: se em XP todo m√©todo deve possuir testes, por que n√£o escrev√™-los primeiro? Isto √©, implementa-se o teste de um m√©todo e, s√≥ ent√£o, o seu c√≥digo. TDD, que tamb√©m √© conhecido como <em>test-first programming</em>, possui duas motiva√ß√µes principais: (1) evitar que a escrita de testes seja sempre deixada para amanh√£, pois eles s√£o a primeira coisa que se deve implementar; (2) ao escrever um teste, o desenvolvedor se coloca no papel de cliente do m√©todo testado, isto √©, ele primeiro pensa na sua interface, em como os clientes devem us√°-lo, para ent√£o pensar na implementa√ß√£o. Com isso, incentiva-se a cria√ß√£o de m√©todos mais amig√°veis, do ponto de vista da interface provida para os clientes. N√£o iremos alongar a explica√ß√£o sobre TDD, pois dedicaremos uma se√ß√£o inteira para essa pr√°tica no cap√≠tulo de Testes.</p>
<p><strong>Build Automatizado</strong>. Build √© o nome que se d√° para a gera√ß√£o de uma vers√£o de um sistema que seja execut√°vel e que possa ser colocada em produ√ß√£o. Logo, inclui n√£o apenas a compila√ß√£o do c√≥digo, mas a execu√ß√£o de outras ferramentas como linkeditores e empacotadores de c√≥digo em arquivos WAR, JAR, etc. No caso de XP, a execu√ß√£o dos testes √© outra etapa fundamental do processo de build. Para automatizar esse processo, s√£o usadas ferramentas, como o sistema Make, que faz parte das distribui√ß√µes do sistema operacional Unix desde a d√©cada de 1970. Mais recentemente, surgiram outras ferramentas de build, como Ant, Maven, Gradle, Rake, MSBuild, etc. Primeiro, XP defende que o processo de build seja automatizado, sem nenhuma interven√ß√£o dos desenvolvedores. O objetivo √© liber√°-los das tarefas de rodar scripts, informar par√¢metros de linhas de comando, configurar ferramentas, etc. Assim, eles podem focar apenas na implementa√ß√£o de hist√≥rias. Segundo, XP defende que o processo de build seja o mais r√°pido poss√≠vel, para que os desenvolvedores recebam rapidamente feedback sobre poss√≠veis problemas, como um erro de compila√ß√£o. Na segunda vers√£o do livro de XP, recomenda-se um limite de 10 minutos para a conclus√£o de um build. No entanto, dependendo do tamanho do sistema e de sua linguagem de programa√ß√£o, pode ser dif√≠cil atender a esse limite. Por isso, o mais importante √© focar na regra geral: sempre procurar automatizar e tamb√©m reduzir o tempo de build.</p>
<p><strong>Integra√ß√£o Cont√≠nua</strong>. Sistemas de software s√£o desenvolvidos com o apoio de sistemas de controle de vers√µes (VCS, ou <em>Version Control System</em>), que armazenam o c√≥digo fonte do sistema e de arquivos relacionados, como arquivos de configura√ß√£o, documenta√ß√£o, etc. Hoje o sistema de controle de vers√£o mais usado √© o git, por exemplo. Quando se usa um VCS, desenvolvedores tem que primeiro baixar (<em>pull</em>) o c√≥digo fonte para sua m√°quina local, antes de come√ßar a trabalhar em uma tarefa. Feito isso, eles devem subir o c√≥digo modificado (<em>push</em>). Esse √∫ltimo passo √© chamado de <strong>integra√ß√£o</strong> da modifica√ß√£o no c√≥digo principal, armazenado no VCS. Por√©m, entre um <em>pull</em> e um <em>push</em>, outro desenvolvedor pode ter modificado o mesmo trecho de c√≥digo e realizado a sua integra√ß√£o. Nesse caso, quando o primeiro desenvolvedor tentar subir com seu c√≥digo, o sistema de controle de vers√£o ir√° impedir a integra√ß√£o, dizendo que existe um <strong>conflito</strong>.</p>
<p>Conflitos s√£o ruins, porque eles devem ser resolvidos manualmente. Se um desenvolvedor A modificou a inicializa√ß√£o de uma vari√°vel <em>x</em> com o valor 10; e outro desenvolvedor B, trabalhando em paralelo com A, gostaria de inicializar <em>x</em> com 20, isso representa um conflito. Para resolv√™-lo, A e B devem sentar e discutir qual o melhor valor para inicializar <em>x</em>. No entanto, esse √© um cen√°rio simples. Conflitos podem ser mais complexos, envolver grandes trechos de c√≥digo e mais do que dois desenvolvedores. Por isso, a resolu√ß√£o de conflitos de integra√ß√£o costuma demandar um esfor√ßo grande, resultando no que se costuma chamar de <em>integration hell</em>.</p>
<p>Por outro lado, evitar completamente conflitos √© imposs√≠vel. Por exemplo, n√£o √© poss√≠vel conciliar automaticamente os interesses de dois desenvolvedores quando um deles precisa inicializar <em>x</em> com 10 e outro com 20. Por√©m, pode-se pelo menos tentar diminuir o n√∫mero e o tamanho dos conflitos. Para conseguir isso, a ideia de XP √© simples: desenvolvedores devem integrar seu c√≥digo sempre, se poss√≠vel todos os dias. Essa pr√°tica √© chamada de <strong>integra√ß√£o cont√≠nua</strong>. O objetivo √© evitar que desenvolvedores passem muito tempo trabalhando localmente, em suas tarefas, sem integrar o c√≥digo. E, com isso, pelo menos diminuir as chances e o tamanho dos conflitos.</p>
<p>Para garantir a qualidade do c√≥digo que est√° sendo integrado com frequ√™ncia quase di√°ria, costuma-se usar tamb√©m um <strong>servi√ßo de integra√ß√£o cont√≠nua</strong>. Antes de realizar qualquer integra√ß√£o, esse servi√ßo faz o build do c√≥digo e executa os testes. O objetivo √© garantir que o c√≥digo n√£o possui erros de compila√ß√£o e que ele passa em todos os testes. Existem diversos servi√ßos de integra√ß√£o cont√≠nua, como Jenkins, TravisCI, CircleCI, etc. Por exemplo, quando se desenvolve um sistema usando o GitHub, pode-se ativar esses servi√ßos na forma de plugins. Se o reposit√≥rio GitHub for p√∫blico, normalmente o servi√ßo de integra√ß√£o cont√≠nua √© gratuito; se for privado, deve-se pagar uma assinatura.</p>
<p>Iremos estudar mais sobre Integra√ß√£o Cont√≠nua no cap√≠tulo sobre Ger√™ncia de Configura√ß√£o.</p>
<p>üåé <strong>Mundo Real</strong>: Em 2010, Laurie Williams, professora da Universidade da Carolina do Norte, nos EUA, pediu que 326 desenvolvedores respondessem a um question√°rio sobre a experi√™ncia deles com m√©todos √°geis (<a href="https://doi.org/10.1145/2133806.2133823">link</a>). Em uma das quest√µes, pedia-se aos participantes para ranquear a import√¢ncia de pr√°ticas √°geis, usando uma escala de 1 a 5, onde o score 5 deveria ser dado apenas para pr√°ticas essenciais em desenvolvimento √°gil. Tr√™s pr√°ticas ficaram empatadas em primeiro lugar, com score m√©dio 4.5 e desvio padr√£o de 0.8. S√£o elas: integra√ß√£o cont√≠nua, itera√ß√µes curtas (menos de 30 dias) e defini√ß√£o de crit√©rios para tarefas conclu√≠das (<em>done criteria</em>). Por outro lado, dentre as pr√°ticas nas √∫ltimas posi√ß√µes podemos citar planning poker (score m√©dio 3.1) e programa√ß√£o em pares (score m√©dio 3.3).</p>
<h3 id="pr√°ticas-de-gerenciamento-de-projetos">Pr√°ticas de Gerenciamento de Projetos</h3>
<p><strong>Ambiente de Trabalho</strong>. XP defende que o projeto seja desenvolvido com um time pequeno, com menos de 10 desenvolvedores, por exemplo. Todos eles devem estar dedicados ao projeto. Isto √©, deve-se evitar times fracionados, nos quais alguns desenvolvedores trabalham apenas alguns dias da semana no projeto e os outros dias em um outro projeto, por exemplo.</p>
<p>Al√©m disso, XP defende que todos os desenvolvedores trabalhem em uma mesma sala, para facilitar comunica√ß√£o e feedback. Tamb√©m prop√µe que o espa√ßo de trabalho seja informativo, isto √©, que sejam, por exemplo, fixados cartazes nas paredes, com as hist√≥rias da itera√ß√£o, incluindo seu estado: hist√≥rias pendentes, hist√≥rias em andamento e hist√≥rias conclu√≠das. A ideia √© permitir que o time possa visualizar e sentir o trabalho que est√° sendo realizado.</p>
<p>Outra preocupa√ß√£o de XP √© garantir jornadas de trabalho sustent√°veis. Empresas de desenvolvimento de software s√£o conhecidas por exigirem longas jornadas de trabalho, com diversas horas extras e trabalho nos finais de semana. XP defende explicitamente que essa pr√°tica n√£o √© sustent√°vel e que as jornadas de trabalho devem ser sempre pr√≥ximas de 40 horas, mesmo na v√©spera de entregas. O interessante √© que XP √© um m√©todo proposto por desenvolvedores, com grande experi√™ncia em projetos reais de desenvolvimento de software. Logo, eles j√° devem ter sentido na pr√≥pria pele os efeitos nocivos de longas jornadas de trabalho. Dentre outros problemas, elas podem causar danos √† sa√∫de f√≠sica e mental dos desenvolvedores, assim como incentivar a rotatividade do time, cujos membros v√£o estar sempre pensando em um novo emprego.</p>
<p><strong>Contratos com Escopo Aberto</strong>. Quando uma empresa terceiriza o desenvolvimento, existem duas possibilidades de contrato: com escopo fechado ou com escopo aberto. Em contratos com escopo fechado, a empresa contratante define, mesmo que de forma m√≠nima, os requisitos do sistema e a empresa contratada define um pre√ßo e um prazo de entrega. XP advoga que esses contratos s√£o arriscados, pois os requisitos mudam e nem mesmo o cliente sabe antecipadamente o que ele quer que o sistema fa√ßa, de modo preciso. Assim, contratos com escopo fixo podem fazer com que a contratada entregue um sistema com problemas de qualidade e mesmo com alguns requisitos implementados de modo parcial ou com bugs, apenas para n√£o ter que pagar poss√≠veis multas. Por outro lado, quando o escopo √© aberto, o pagamento ocorre por hora trabalhada. Por exemplo, combina-se que a contratada vai alocar um time com um certo n√∫mero de desenvolvedores para trabalhar integralmente no projeto, usando as pr√°ticas de XP. Combina-se tamb√©m um pre√ßo para a hora de cada desenvolvedor. O cliente define as hist√≥rias e faz a valida√ß√£o delas ao final de cada itera√ß√£o. O contrato pode ser rescindido ou renovado ap√≥s um certo n√∫mero de meses, o que d√° ao cliente a liberdade de mudar de empresa caso n√£o esteja satisfeito com a qualidade do servi√ßo prestado. Como usual em XP, o objetivo √© abrir um fluxo de comunica√ß√£o e feedback entre contratada e contratante, em vez de for√ßar a primeira a entregar um produto com problemas conhecidos, apenas para cumprir um contrato. Na verdade, contratos com escopo aberto s√£o mais compat√≠veis com os princ√≠pios do Manifesto √Ågil, que explicitamente valoriza "colabora√ß√£o com o cliente, mais que negocia√ß√£o de contratos".</p>
<p><strong>M√©tricas de Processo</strong>. Para que gerentes e executivos possam acompanhar um projeto XP recomenda-se o uso de duas m√©tricas principais: n√∫mero de bugs em produ√ß√£o (que deve ser idealmente da ordem de poucos bugs por ano) e intervalo de tempo entre o in√≠cio do desenvolvimento e o momento em que o projeto come√ßar a gerar os seus primeiros resultados financeiros (que tamb√©m deve ser pequeno, da ordem de um ano, por exemplo).</p>
<p>üì∫ <strong>V√≠deo Complementar</strong>: XP j√° completou 20 anos. Em uma palestra comemorativa, realizada em um evento sobre m√©todos √°geis na Fran√ßa, Kent Beck discorreu sobre a hist√≥ria de XP e fez uma reflex√£o cr√≠tica sobre o m√©todo proposto por ele, indicando as pr√°ticas que foram bem sucedidas e aquelas que n√£o deram t√£o certo. Assista o v√≠deo da palestra, com cerca de 40 minutos, neste <a href="https://youtu.be/cGuTmOUdFbo">link</a>.</p>
<h2 id="scrum">2.4 Scrum</h2>
<p>Scrum √© um m√©todo √°gil, iterativo e incremental para gerenciamento de projetos. Foi proposto por Jeffrey Sutherland e Ken Schwaber, em um artigo publicado pela primeira vez em 1995 (<a href="https://doi.org/10.1007/978-1-4471-0947-1_11">link</a>). Dentre os m√©todos √°geis, Scrum √© o mais conhecido e usado. Provavelmente, parte do sucesso do m√©todo seja explicada pela exist√™ncia de uma ind√∫stria associada √† sua ado√ß√£o, a qual inclui a produ√ß√£o de livros, diversos cursos, consultorias e certifica√ß√µes.</p>
<p>Uma pergunta que vamos responder logo no in√≠cio desta se√ß√£o diz respeito √†s diferen√ßas entre Scrum e XP. Existem diversas pequenas diferen√ßas, mas a principal delas √© a seguinte:</p>
<ul>
<li><p>XP √© um m√©todo √°gil voltado exclusivamente para projetos de desenvolvimento de software. Para isso, XP inclui um conjunto de pr√°ticas de programa√ß√£o, como testes de unidade, programa√ß√£o em pares, integra√ß√£o cont√≠nua e design incremental, que foram estudadas na se√ß√£o anterior.</p></li>
<li><p>Scrum √© um m√©todo √°gil para gerenciamento de projetos, que n√£o necessariamente precisam ser projetos de desenvolvimento de software. Por exemplo, a escrita deste livro ‚Äî como comentaremos daqui a pouco ‚Äî √© um projeto que est√° sendo realizado usando conceitos de Scrum. Tendo um foco mais amplo que XP, Scrum n√£o prop√µe nenhuma pr√°tica de programa√ß√£o.</p></li>
</ul>
<p>Dentre os m√©todos √°geis, Scrum √© tamb√©m aquele que √© melhor definido. Essa defini√ß√£o inclui um conjunto preciso de <strong>pap√©is</strong>, <strong>artefatos</strong> e <strong>eventos</strong>, que s√£o listados e resumidos na tabela a seguir. No resto desta se√ß√£o, vamos explicar cada um deles.</p>
<table class="preset" style="width:89%;">
<colgroup>
<col style="width: 25%" />
<col style="width: 29%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Pap√©is</strong></th>
<th><strong>Artefatos</strong></th>
<th><strong>Eventos</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Dono do Produto</p>
<p>Scrum Master</p>
<p>Desenvolvedor</p></td>
<td><p>Backlog do Produto</p>
<p>Backlog do Sprint</p>
<p>Quadro Scrum</p>
<p>Gr√°fico Burndown</p></td>
<td><p>Planejamento do Sprint</p>
<p>Sprint</p>
<p>Reuni√µes Di√°rias</p>
<p>Revis√£o do Sprint</p>
<p>Retrospectiva</p></td>
</tr>
</tbody>
</table>
<p><strong>Pap√©is</strong>: Times Scrum s√£o formados por um Dono de Produto (<em>Product Owner</em>), um Scrum Master e de tr√™s a nove desenvolvedores.</p>
<p>O <strong>Dono do Produto</strong> tem exatamente o mesmo papel do Representante dos Clientes em XP, por isso n√£o vamos explicar de novo a sua fun√ß√£o em detalhes. Mas ele, como o pr√≥prio nome indica, deve possuir a vis√£o do produto que ser√° constru√≠do, sendo respons√°vel tamb√©m por maximizar o retorno do investimento feito no projeto. Assim como em XP, cabe ao Dono do Produto escrever as hist√≥rias do usu√°rio e, por isso, ele deve estar sempre dispon√≠vel para tirar d√∫vidas do time.</p>
<p>O <strong>Scrum Master</strong> √© um papel caracter√≠stico e √∫nico de Scrum. Trata-se do especialista em Scrum do time, sendo respons√°vel por garantir que as regras do m√©todo est√£o sendo seguidas. Para isso, ele deve continuamente treinar e explicar os princ√≠pios de Scrum para os demais membros do time. Ele tamb√©m deve desempenhar fun√ß√µes de um facilitador dos trabalhos e removedor de impedimentos. Por exemplo, suponha que um time esteja enfrentando problemas com um dos servidores de bancos de dados, cujos discos est√£o apresentando problemas todos os dias. Cabe ao Scrum Master intervir junto aos n√≠veis adequados da empresa para garantir que esse problema de hardware n√£o atrapalhe o avan√ßo do time. Por outro lado, ele n√£o √© um gerente de projeto tradicional. Por exemplo, ele n√£o √© o l√≠der do time, pois todos em um time Scrum tem o mesmo n√≠vel hier√°rquico.</p>
<p>Costuma-se dizer que times Scrum s√£o <strong>cross-funcionais</strong>, isto √©, eles devem incluir ‚Äî al√©m do Dono do Produto e do Scrum Master ‚Äî todos os especialistas necess√°rios para desenvolver o produto, de forma a n√£o depender de membros externos. No caso de projetos de software, isso inclui desenvolvedores <em>front-end,</em> desenvolvedores <em>back-end,</em> especialistas em bancos de dados, projetistas de interfaces, etc. Cabe a esses especialistas tomar todas as decis√µes t√©cnicas do projeto, incluindo defini√ß√£o da linguagem de programa√ß√£o, arquitetura e frameworks que ser√£o usados no desenvolvimento. Cabe a eles tamb√©m estimar o tamanho das hist√≥rias definidas pelo Dono do Produto, usando uma unidade como story points, de modo semelhante ao que vimos em XP.</p>
<p><strong>Principais Artefatos e Eventos:</strong> Em Scrum, os dois artefatos principais s√£o o Backlog do Produto e o Backlog do Sprint e os principais eventos s√£o sprints e o planejamento de sprints, conforme descreveremos a seguir.</p>
<ul>
<li><p>O <strong>Backlog do Produto</strong> √© uma lista de hist√≥rias, ordenada por prioridades. Assim como em XP, as hist√≥rias s√£o escritas e priorizadas pelo Dono do Produto e constituem uma descri√ß√£o resumida das funcionalidades que devem ser implementadas no projeto. √â importante mencionar ainda que o Backlog do Produto √© um artefato din√¢mico, isto √©, ele deve ser continuamente atualizado, de forma a refletir mudan√ßas nos requisitos e na vis√£o do produto. Por exemplo, √† medida que o desenvolvimento avan√ßa, ideias de novas funcionalidades podem surgir, enquanto outras podem perder import√¢ncia. Todas essas atualiza√ß√µes devem ser realizadas pelo Dono do Produto. Na verdade, √© o fato de ser o dono do Backlog do Produto que faz o Dono do Produto receber esse nome.</p></li>
<li><p><strong>Sprint</strong> √© o nome dado por Scrum para uma itera√ß√£o. Ou seja, como todo m√©todo √°gil, Scrum √© um m√©todo iterativo, no qual o desenvolvimento √© dividido em sprints, de at√© um m√™s. Ao final de um sprint, deve-se entregar um produto com valor tang√≠vel para o cliente. O resultado de um sprint √© frequentemente chamado de um produto potencialmente pronto para entrar em produ√ß√£o (<em>potentially shippable product</em>). Lembre que o adjetivo potencial n√£o torna a entrada em produ√ß√£o obrigat√≥ria, conforme discutido na Se√ß√£o 2.2.</p></li>
<li><p>O <strong>Planejamento do Sprint</strong> √© uma reuni√£o na qual todo o time se re√∫ne para decidir as hist√≥rias que ser√£o implementadas no sprint que vai se iniciar. Portanto, ele √© o evento que marca o in√≠cio de um sprint. Essa reuni√£o √© dividida em duas partes. A primeira √© comandada pelo Dono do Produto. Ele prop√µe hist√≥rias para o sprint e o restante do time decide se tem <strong>velocidade</strong> para implement√°-las. A segunda parte √© comandada pelos desenvolvedores. Nela, eles quebram as hist√≥rias em tarefas e estimam a dura√ß√£o delas. No entanto, o Dono do Produto deve continuar presente nessa parte final, para tirar d√∫vidas sobre as hist√≥rias selecionadas para o sprint. Por exemplo, pode-se decidir cancelar uma hist√≥ria, pois ela se revelou mais complexa ao ser quebrada em tarefas.</p></li>
<li><p>O <strong>Backlog</strong> <strong>do</strong> <strong>Sprint</strong> √© o artefato gerado ao final do Planejamento do Sprint. Ele √© uma lista com as tarefas do sprint, bem como inclui a dura√ß√£o das mesmas. Como o Backlog do Produto, o Backlog do Sprint tamb√©m √© din√¢mico. Por exemplo, tarefas podem se mostrar desnecess√°rias e outras podem surgir, ao longo do sprint. Pode-se tamb√©m alterar a estimativa de horas previstas para uma tarefa. Por√©m, o que n√£o pode ser alterado √© o <strong>objetivo do sprint</strong> (<em>sprint goal</em>), isto √©, a lista de hist√≥rias que o dono do produto selecionou para o sprint e que o time de desenvolvimento se comprometeu a implementar na dura√ß√£o do mesmo. Assim, Scrum √© um m√©todo adaptativo a mudan√ßas, mas desde que elas ocorram entre sprints. Ou seja, no time-box de um sprint, a equipe de desenvolvimento deve ter tranquilidade e seguran√ßa para trabalhar com uma lista fechada de hist√≥rias.</p></li>
</ul>
<p>Terminada a reuni√£o de planejamento, tem in√≠cio o sprint. Ou seja, o time come√ßa a trabalhar na implementa√ß√£o das tarefas do backlog. Al√©m de cross-funcionais, os times Scrum s√£o <strong>auto-organiz√°veis</strong>, isto √©, eles t√™m autonomia para decidir como e por quem as hist√≥rias ser√£o implementadas.</p>
<p>Ao lado do Backlog do Sprint, costuma-se anexar um quadro com tarefas <em>a fazer</em>, <em>em andamento</em> e <em>finalizadas</em>. Esse quadro ‚Äî tamb√©m chamado de <strong>Quadro</strong> <strong>Scrum</strong> (<em>Scrum Board</em>) ‚Äî pode ser fixado nas paredes do ambiente de trabalho, permitindo que o time tenha diariamente uma sensa√ß√£o visual sobre o andamento do sprint. Veja um exemplo na pr√≥xima figura.</p>
<figure>
<img src="figs/cap2/quadro-scrum.png" style="width:40.0%" alt="" /><figcaption>Exemplo de Quadro Scrum, mostrando as hist√≥rias selecionadas para o sprint e as tarefas nas quais elas foram quebradas. Cada tarefa nesse quadro pode estar em um dos seguintes estados: a fazer, em andamento, em teste ou conclu√≠da. Veja que o sprint est√° planejado para terminar no dia 22/12. Foto da <a href="https://commons.wikimedia.org/wiki/File:Scrum_task_board.jpg">Wikipedia</a>, licen√ßa CC-BY.</figcaption>
</figure>
<p>Uma decis√£o importante em projetos Scrum envolve os crit√©rios para considerar uma hist√≥ria ou tarefa como conclu√≠das (<em>done</em>). Esses crit√©rios devem ser combinados com o time e ser do conhecimento de todos os seus membros. Por exemplo, em um projeto de desenvolvimento de software, para que uma hist√≥ria seja marcada como conclu√≠da pode-se exigir a implementa√ß√£o de testes de unidade, que devem estar todos passando, bem como a revis√£o do c√≥digo por um outro membro do time. Al√©m disso, o c√≥digo deve ter sido integrado com sucesso no reposit√≥rio do projeto. O objetivo desses crit√©rios √© evitar que os membros ‚Äî de forma apressada e valendo-se de c√≥digo de baixa qualidade ‚Äî consigam mover suas tarefas para a coluna conclu√≠do.</p>
<p>Um outro artefato comum em Scrum √© o <strong>Gr√°fico de Burndown</strong>. A cada dia do sprint, esse gr√°fico mostra quantas horas s√£o necess√°rias para se implementar as tarefas que ainda n√£o est√£o conclu√≠das. Isto √©, no dia X do sprint ele informa que restam tarefas a implementar que somam Y horas. Logo, a curva de um gr√°fico de burndown deve ser declinante, atingindo o valor zero ao final do sprint, caso ele seja bem sucedido. Mostra-se a seguir um exemplo, assumindo-se um sprint de 15 dias.</p>
<p><img src="figs/cap2/burndown.png" style="width:55.0%" /></p>
<p>Exemplo de Gr√°fico de Burndown, assumindo um sprint com dura√ß√£o de 15 dias. O sprint foi bem sucedido, pois conseguiu-se implementar todas as tarefas previstas.</p>
<p>üåé <strong>Mundo Real</strong>: Este livro est√° sendo escrito usando artefatos e eventos de Scrum. Claro que apenas alguns, pois o livro tem um √∫nico autor que, em certa medida, desempenha todos os pap√©is previstos por Scrum. Logo no in√≠cio do projeto, os cap√≠tulos do livro foram planejados, constituindo assim o Backlog do Produto. A escrita de cada cap√≠tulo √© considerada como sendo um sprint. Na reuni√£o de Planejamento do Sprint, define-se a divis√£o do cap√≠tulo em se√ß√µes, que s√£o equivalentes √†s tarefas. Ent√£o come√ßa-se a escrita de cada cap√≠tulo, isto √©, tem in√≠cio um sprint. Via de regra, os sprints s√£o planejados para ter uma dura√ß√£o de tr√™s meses. Para ficar mais claro, mostra-se a seguir o backlog do sprint atual, bem como o estado de cada tarefa, exatamente no momento em que se est√° escrevendo este par√°grafo.</p>
<table class="preset" style="width:96%;">
<colgroup>
<col style="width: 25%" />
<col style="width: 23%" />
<col style="width: 23%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Hist√≥ria</strong></th>
<th><strong>A fazer</strong></th>
<th><strong>Em andamento</strong></th>
<th><strong>Conclu√≠das</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Cap. 2 - Processos de Desenvolvimento</td>
<td><p>Kanban</p>
<p>Quando n√£o usar M√©todos √Ågeis</p>
<p>Outros Processos</p>
<p>Exerc√≠cios</p></td>
<td>Scrum</td>
<td><p>Introdu√ß√£o</p>
<p>Manifesto √Ågil</p>
<p>XP</p></td>
</tr>
</tbody>
</table>
<p>Decidiu-se adotar um m√©todo √°gil para escrita do livro para minimizar os riscos de desenvolver um produto que n√£o atenda √†s necessidades de nossos clientes, que, nesta primeira vers√£o, s√£o estudantes e professores brasileiros de disciplinas de Engenharia de Software, principalmente em n√≠vel de gradua√ß√£o. Assim, ao final de cada sprint, um cap√≠tulo √© lan√ßado e divulgado publicamente, de forma a receber feedback. Com isso, evita-se uma solu√ß√£o Waterfall, onde o livro seria escrito por cerca de dois anos, sem receber qualquer feedback.</p>
<p>Para finalizar, vamos comentar sobre o crit√©rio para conclus√£o de um cap√≠tulo, ou seja, para definir que um cap√≠tulo est√° finalizado (<em>done</em>). Esse crit√©rio requer a leitura e revis√£o completa do cap√≠tulo, pelo autor do livro. Conclu√≠da essa revis√£o, o cap√≠tulo √© divulgado preliminarmente para os membros do Grupo de Pesquisa em Engenharia de Software Aplicada, do DCC/UFMG.</p>
<p><strong>Outros Eventos de Scrum:</strong> Vamos agora descrever mais tr√™s eventos Scrum, especificamente Reuni√µes Di√°rias, Revis√£o do Sprint e Retrospectiva.</p>
<p>Scrum prop√µe que sejam realizadas <strong>Reuni√µes Di√°rias,</strong> de cerca de 15 minutos, das quais devem participar todos os membros do time. Essas reuni√µes para serem r√°pidas devem ocorrer com os membros em p√©, da√≠ serem tamb√©m conhecidas como <strong>reuni√µes em p√©</strong> (<em>standup meetings,</em> ou ainda <em>daily scrum</em>). Nelas, cada membro do time deve responder a tr√™s perguntas: (1) o que ele fez no dia anterior; (2) o que ele pretende fazer no dia corrente; (3) e se ele est√° enfrentando algum problema mais s√©rio, isto √©, um impedimento, na sua tarefa. Essas reuni√µes t√™m como objetivo melhorar a comunica√ß√£o entre os membros do time, fazendo com que eles compartilhem e socializem o andamento do projeto. Por exemplo, dois desenvolvedores podem tomar ci√™ncia, durante a reuni√£o di√°ria, que eles v√£o come√ßar a modificar o mesmo componente de c√≥digo. Portanto, seria recomend√°vel que eles se reunissem, separadamente do resto do time, para discutir as modifica√ß√µes que pretendem realizar. E, com isso, minimizar as chances de poss√≠veis conflitos de integra√ß√£o.</p>
<p>üì∫ <strong>V√≠deo Complementar</strong>: Este v√≠deo de treinamento da IBM, com 4 minutos de dura√ß√£o, mostra um exemplo de reuni√£o di√°ria (<a href="https://www.youtube.com/watch?v=GzQjGhD5tSU">link</a>).</p>
<p>A <strong>Revis√£o do Sprint</strong> <em>(Sprint Review</em>) √© uma reuni√£o para mostrar os resultados de um sprint. Dela devem participar todos os membros do time e idealmente outros stakeholders, convidados pelo Dono do Produto, que estejam envolvidos com o resultado do sprint. Durante essa reuni√£o o time demonstra, ao vivo, o produto para os clientes. Como resultado, todas as hist√≥rias do sprint podem ser aprovadas pelo Dono do Produto. Por outro lado, caso ele detecte problema em alguma hist√≥ria, ela deve voltar para o Backlog do Produto, para ser retrabalhada em um pr√≥ximo sprint. O mesmo deve ocorrer com as hist√≥rias que o time n√£o conseguiu concluir durante o sprint.</p>
<p>A <strong>Retrospectiva</strong> √© a √∫ltima atividade de um sprint. Trata-se de uma reuni√£o do time Scrum, com o objetivo de refletir sobre o sprint que est√° terminando e, se poss√≠vel, identificar pontos de melhorias no processo, nas pessoas, nos relacionamentos e nas ferramentas usadas. Apenas para dar um exemplo, como resultado de uma retrospectiva, o time pode acordar sobre a import√¢ncia de todos estarem presentes, pontualmente, nas reuni√µes di√°rias, pois nos √∫ltimos sprints alguns membros est√£o se atrasando. Veja, portanto, que uma retrospectiva n√£o √© uma reuni√£o para "lavar a roupa suja" e para membros ficarem discutindo entre si. Se for necess√°rio, isso deve ser feito em particular, em outras reuni√µes ou com a presen√ßa de gerentes da organiza√ß√£o. Depois da retrospectiva, o ciclo se repete, com um novo sprint.</p>
<p>Uma caracter√≠stica marcante de todos os eventos Scrum √© terem uma dura√ß√£o bem definida, que √© chamada de <strong>time-box</strong> da atividade. Por isso, esse termo aparece sempre em documentos Scrum. Por exemplo, veja essa frase do Scrum Guide oficial: "o cora√ß√£o do m√©todo Scrum √© um sprint, que tem um time-box de um m√™s ou menos e durante o qual um produto "done", us√°vel e que potencialmente pode ser colocado em produ√ß√£o √© criado" (<a href="https://www.scrum.org/resources/scrum-guide">link</a>). O objetivo da fixa√ß√£o de <em>time boxes</em> √© criar um fluxo cont√≠nuo de trabalho, bem como fomentar o compromisso da equipe com o sucesso do sprint e evitar a perda de foco. A pr√≥xima tabela mostra o time-box dos eventos Scrum.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Evento</strong></th>
<th style="text-align: left;"><strong>Time-box</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Planejamento do Sprint</td>
<td style="text-align: left;">m√°ximo de 8 horas</td>
</tr>
<tr class="even">
<td style="text-align: left;">Sprint</td>
<td style="text-align: left;">menos de 1 m√™s</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Reuni√£o Di√°ria</td>
<td style="text-align: left;">15 minutos</td>
</tr>
<tr class="even">
<td style="text-align: left;">Revis√£o do Sprint</td>
<td style="text-align: left;">m√°ximo de 4 horas</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Retrospectiva</td>
<td style="text-align: left;">m√°ximo de 3 horas</td>
</tr>
</tbody>
</table>
<p>Time-box dos eventos scrum. No caso de eventos com um time-box m√°ximo, ele se refere a um sprint de um m√™s. Se o sprint for menor, o time-box sugerido deve ser tamb√©m menor.</p>
<p>üí°<strong>Perguntas Frequentes</strong>: Antes de concluir a se√ß√£o, vamos responder algumas perguntas sobre Scrum:</p>
<p><strong>O que significa a palavra Scrum</strong>? O nome n√£o √© uma sigla, mas uma refer√™ncia √† "reuni√£o" de jogadores realizada em uma partida de rugby para decidir quem vai ficar com a bola, ap√≥s uma infra√ß√£o involunt√°ria. Veja uma foto a seguir.</p>
<figure>
<img src="figs/cap2/scrum.png" style="width:30.0%" alt="" /><figcaption>Scrum, licen√ßa CC-BY.</figcaption>
</figure>
<p>(https://www.flickr.com/photos/22434330@N00),</p>
<p><strong>O que √© um squad</strong>? Basicamente, o termo <strong>squad</strong> √© um sin√¥nimo para time √°gil ou time Scrum. O nome foi popularizado pela Spotify. Assim como times Scrum, squads s√£o pequenos, cross-funcionais e auto-organiz√°veis. √â comum ainda se deparar com o nome tribo, para denotar um conjunto de squads.</p>
<p><strong>O Dono do Produto pode ser um comit√™</strong>? Em outras palavras, pode existir mais de um Dono de Produto em um time Scrum? A resposta √© n√£o. Apenas um membro do time exerce essa fun√ß√£o. O objetivo √© evitar decis√µes por comit√™, que tendem a gerar produtos lotados de features, que foram implementadas apenas para atender a determinados membros do comit√™. Por√©m, nada impede que o Dono do Produto fa√ßa a ponte entre o time e outros usu√°rios com amplo dom√≠nio da √°rea do produto que est√° sendo constru√≠do. Na verdade, essa √© uma tarefa esperada de Donos de Produto, pois √†s vezes existem requisitos que s√£o do dom√≠nio de apenas outros colaboradores da organiza√ß√£o. Cabe ent√£o ao Dono do Produto intermediar as conversas entre os desenvolvedores do time Scrum e tais usu√°rios.</p>
<p><strong>O Scrum Master deve exercer seu papel em tempo integral</strong>? Idealmente, sim. Por√©m, em times maduros, que conhecem e praticam Scrum h√° bastante tempo, √†s vezes n√£o √© necess√°rio ter um Scrum Master em tempo integral. Nesses casos, existem duas possibilidades: (1) permitir que o Scrum Master desempenhe esse papel em mais de um time Scrum; (2) alocar a responsabilidade de Scrum Master a um dos membros do time. No entanto, caso a segunda alternativa seja adotada, o Scrum Master n√£o deve ser tamb√©m o Dono do Produto. A raz√£o √© que uma das responsabilidades do Scrum Master √© exatamente acompanhar e auxiliar o Dono do Produto em suas tarefas de escrever e priorizar hist√≥rias do usu√°rio.</p>
<p><strong>O Scrum Master precisa ter um diploma de n√≠vel superior em um curso da √°rea de Computa√ß√£o?</strong> N√£o, pois sua fun√ß√£o envolve remover impedimentos e assegurar que o time esteja seguindo os princ√≠pios de Scrum. Portanto, ele n√£o √© um resolvedor de problemas t√©cnicos, tais como bugs, uso correto de frameworks, implementa√ß√£o de funcionalidades, etc. Por outro lado, isso n√£o impede que um desenvolvedor t√©cnico, com um curso superior na √°rea de Computa√ß√£o, assuma as fun√ß√µes de Scrum Master, como vimos na resposta anterior. Existem tamb√©m certifica√ß√µes para Scrum Master, as quais podem ser requeridas por empresas que decidem adotar Scrum.</p>
<p><strong>Al√©m de hist√≥rias, quais outros itens podem fazer parte do Backlog do Produto</strong>? Tamb√©m podem ser cadastrados no Backlog do Produto itens como bugs ‚Äî principalmente aqueles mais complexos e que demandam dias para serem resolvidos ‚Äî e tamb√©m melhorias em hist√≥rias j√° implementadas.</p>
<p><strong>Existem gerentes quando se usa Scrum</strong>? A resposta √© sim! De fato, times Scrum s√£o aut√¥nomos para implementar as hist√≥rias priorizadas pelo Dono do Produto. Por√©m, um projeto demanda diversas outras decis√µes que devem ser tomadas em um n√≠vel gerencial. Dentre elas, podemos citar as seguintes:</p>
<ul>
<li><p>Contratar e alocar membros para os times Scrum; ou seja, os desenvolvedores n√£o tem autonomia para escolher em quais times eles v√£o trabalhar. Essa √© uma decis√£o de mais alto n√≠vel e, portanto, tomada por gerentes.</p></li>
<li><p>Decidir os objetivos e responsabilidades de cada time, incluindo, o sistema ‚Äî ou parte de um sistema ‚Äî que o time ir√° desenvolver usando Scrum. Por exemplo, um time n√£o decide, por conta pr√≥pria, que a organiza√ß√£o precisa de um novo sistema de contabilidade e ent√£o come√ßa a desenvolv√™-lo. Essa √© uma decis√£o estrat√©gica da organiza√ß√£o, que √© tomada pelos seus gerentes e executivos.</p></li>
<li><p>Gerenciar e administrar quest√µes de recursos humanos, incluindo contrata√ß√µes de novos funcion√°rios, desligamentos de funcion√°rios, promo√ß√µes, transfer√™ncias, treinamentos, etc.</p></li>
<li><p>Avaliar se os resultados produzidos pelos times Scrum est√£o, de fato, gerando benef√≠cios e valor para a organiza√ß√£o.</p></li>
</ul>
<p>üì∫ <strong>V√≠deo Complementar</strong>: Junto com Ken Schwaber, Jeff Sutherland √© um dos criadores do Scrum. Recomendamos duas de suas palestras sobre o m√©todo, ambas realizadas em 2014. A primeira √© uma TED Talk, portanto mais gen√©rica e para um p√∫blico que n√£o √© especialista em desenvolvimento de software, dispon√≠vel neste <a href="https://youtu.be/s4thQcgLCqk">link</a>, com dura√ß√£o de 16 minutos. A segunda √© uma apresenta√ß√£o t√©cnica dispon√≠vel neste <a href="https://youtu.be/2L1oBLTICx4">link</a>, com dura√ß√£o de um hora.</p>
<h2 id="kanban">2.5 Kanban</h2>
<p>A palavra japonesa <em>kanban</em> significa "cart√£o visual" ou "cart√£o de sinaliza√ß√£o". Desde a d√©cada de 50, o nome tamb√©m √© usado para denotar o processo de produ√ß√£o <em>just-in-time</em> usado em f√°bricas japonesas, principalmente naquelas da Toyota, onde ele foi usado pela primeira vez. O processo tamb√©m √© conhecido como Sistema de Produ√ß√£o da Toyota (TPS) ou, mais recentemente, por manufatura <em>lean</em>. Em uma linha de montagem, os cart√µes s√£o usados para controlar o fluxo de produ√ß√£o.</p>
<p>No caso de desenvolvimento de software, Kanban foi usado pela primeira vez na Microsoft, em 2004, como parte de um esfor√ßo liderado por David Anderson, ent√£o um funcion√°rio da empresa (<a href="https://isbnsearch.org/isbn/0984521402">link</a>). Segundo Anderson, "Kanban √© um m√©todo que ajuda times de desenvolvimento a trabalhar em ritmo sustent√°vel, eliminando desperd√≠cio, entregando valor com frequ√™ncia e fomentando uma cultura de melhorias cont√≠nuas".</p>
<p>Para come√ßar a explicar Kanban, vamos usar uma compara√ß√£o com Scrum. Primeiro, Kanban √© mais simples do que Scrum, pois n√£o usa nenhum dos eventos de Scrum, incluindo sprints. Tamb√©m, n√£o existe nenhum dos pap√©is (Dono do Produto, Scrum Master, etc.), pelo menos da forma r√≠gida preconizada por Scrum. Por fim, n√£o existe nenhum dos artefatos Scrum, com uma √∫nica e central exce√ß√£o: o quadro de tarefas, que √© chamado de <strong>Quadro</strong> <strong>Kanban</strong> (<em>Kanban Board</em>), e que inclui tamb√©m o Backlog do Produto.</p>
<p>O Quadro Kanban √© dividido em colunas, da seguinte forma:</p>
<ul>
<li><p>A primeira coluna √© o backlog do produto. Como em Scrum, usu√°rios escrevem as hist√≥rias, que v√£o para o Backlog.</p></li>
<li><p>As demais colunas s√£o os passos que devem ser seguidos para transformar uma hist√≥ria do usu√°rio em uma funcionalidade execut√°vel. Por exemplo, pode-se ter colunas como Especifica√ß√£o, Implementa√ß√£o e Revis√£o de C√≥digo. A ideia, portanto, √© que as hist√≥rias sejam processadas passo a passo, da esquerda para a direita, como em uma linha de montagem. Al√©m disso, cada coluna √© dividida em duas sub-colunas: "em execu√ß√£o" e "conclu√≠das". Por exemplo, a coluna implementa√ß√£o tem duas sub-colunas: tarefas em implementa√ß√£o e tarefas implementadas. As tarefas conclu√≠das em um passo est√£o aguardando serem puxadas, por um membro do time, para o pr√≥ximo passo. Por isso, Kanban √© chamado de um sistema <em>pull</em>.</p></li>
</ul>
<p>Mostra-se abaixo um exemplo de Quadro Kanban. Observe que existe uma hist√≥ria no backlog (H3), al√©m de uma hist√≥ria (H2) que j√° foi puxada por algum membro do time para o passo de especifica√ß√£o. Existem ainda quatro tarefas (T6 a T9) que foram especificadas a partir de uma hist√≥ria anterior. Continuando, existem duas tarefas em implementa√ß√£o (T4 e T5) e existe uma tarefa implementada e aguardando ser puxada para revis√£o de c√≥digo (T3). No √∫ltimo passo, existe uma tarefa em revis√£o (T2) e uma tarefa cujo processamento est√° conclu√≠do (T1). Por enquanto, n√£o se preocupe com a sigla WIP que aparece em todos os passos, exceto no backlog. Vamos explic√°-la em breve. Al√©m disso, representamos as hist√≥rias e tarefas pelas letras H e T, respectivamente. Por√©m, em um quadro real, ambas s√£o cart√µes auto-adesivos com uma pequena descri√ß√£o. O Quadro Kanban pode ser assim montado em uma das paredes do ambiente de trabalho do time.</p>
<p><img src="figs/cap2/kanban1.jpg" style="width:80.0%" /></p>
<p>Agora, mostraremos uma evolu√ß√£o do projeto. Isto √©, alguns dias depois, o Quadro Kanban passou para o seguinte estado (as tarefas que avan√ßaram no quadro est√£o em vermelho).</p>
<p><img src="figs/cap2/kanban2.jpg" style="width:80.0%" /></p>
<p>Veja que a hist√≥ria H2 desapareceu, pois foi quebrada em tr√™s tarefas (T10, T11 e T12). O objetivo da fase de especifica√ß√£o √© exatamente transformar uma hist√≥ria em uma lista de tarefas. Continuando, T6 e T7 ‚Äî que antes estavam esperando ‚Äî entraram em implementa√ß√£o. J√° T3 entrou na fase de revis√£o de c√≥digo. Por fim, a revis√£o de T2 terminou. Veja ainda que, neste momento, n√£o existe nenhuma tarefa implementada e aguardando ser puxada para revis√£o.</p>
<p>Como em outros m√©todos √°geis, times Kanban s√£o auto-organiz√°veis. Isso significa que eles t√™m autonomia para definir qual tarefa vai ser puxada para o pr√≥ximo passo. Eles tamb√©m s√£o cross-funcionais, isto √©, devem incluir membros capazes de realizar todos os passos do Quadro Kanban.</p>
<p>Por fim, resta explicar o conceito de <strong>Limites WIP</strong> (<em>Working in Progress</em>). Via de regra, m√©todos de gerenciamento de projetos t√™m como objetivo garantir um ritmo sustent√°vel de trabalho. Para isso, deve-se evitar duas situa√ß√µes extremas: (1) o time ficar ocioso boa parte do tempo, sem tarefa para realizar; ou (2) o time ficar sobrecarregado de trabalho e, por isso, n√£o conseguir produzir software de qualidade. Para evitar a segunda situa√ß√£o ‚Äî sobrecarga de trabalho ‚Äî Kanban prop√µe um limite m√°ximo de tarefas que podem estar em cada um dos passos de um Quadro Kanban. Esse limite √© conhecido pelo nome Limite WIP, isto √©, trata-se do limite m√°ximo de cart√µes presentes em cada passo, contando aqueles na primeira coluna (em andamento) e aqueles na segunda coluna (conclu√≠dos) do passo. A exce√ß√£o √© o √∫ltimo passo, onde o WIP aplica-se apenas √† primeira sub-coluna, j√° que n√£o faz sentido aplicar um limite ao n√∫mero de tarefas conclu√≠das pelo time.</p>
<p>Abaixo, reproduzimos o √∫ltimo Quadro Kanban, mas com os limites WIP. Eles s√£o os n√∫meros que aparecem abaixo do nome de cada passo, na primeira linha do quadro. Ou seja, nesse Quadro Kanban, admite-se um m√°ximo de 2 hist√≥rias em especifica√ß√£o; 5 tarefas em implementa√ß√£o; e 3 tarefas em revis√£o. Vamos deixar para explicar o limite WIP do passo Especifica√ß√£o por √∫ltimo. Mas podemos ver que existem 4 tarefas em implementa√ß√£o (T4, T5, T6 e T7). Portanto, abaixo do WIP desse passo, que √© igual a 5 tarefas. Em Revis√£o de C√≥digo, o limite √© de 3 tarefas e tamb√©m est√° sendo respeitado, pois existe apenas uma tarefa em revis√£o (T3). Veja que para fins de verificar o limite WIP contam-se as tarefas em andamento (1a sub-coluna de cada passo) e conclu√≠das (2a sub-coluna de cada passo), com exce√ß√£o do √∫ltimo passo, no qual consideram-se apenas as tarefas da primeira sub-coluna (T3, no exemplo).</p>
<p><img src="figs/cap2/kanban3.jpg" style="width:80.0%" /></p>
<p>Agora vamos explicar o WIP do passo Especifica√ß√£o. Para verificar o WIP desse passo, deve-se somar as hist√≥rias em especifica√ß√£o (zero no quadro anterior) e as hist√≥rias que j√° foram especificadas. No caso, temos duas hist√≥rias especificadas. Ou seja, T8 e T9 s√£o tarefas que resultaram da especifica√ß√£o de uma mesma hist√≥ria. E as tarefas T10, T11 e T12 s√£o resultado da especifica√ß√£o de uma segunda hist√≥ria. Portanto, para fins do c√°lculo de WIP, temos duas hist√≥rias no passo, o que est√° dentro do seu limite, que tamb√©m √© 2. Para facilitar a visualiza√ß√£o, costuma-se representar as tarefas resultantes da especifica√ß√£o de uma mesma hist√≥ria em uma √∫nica linha. Seguindo esse padr√£o, para calcular o WIP do passo Especifica√ß√£o, deve-se somar as hist√≥rias da primeira subcoluna (zero, no nosso exemplo) com o n√∫mero de linhas na segunda coluna (duas).</p>
<p>Ainda no quadro anterior, e considerando os limites WIP, tem-se que:</p>
<ul>
<li><p>A hist√≥ria H3, que est√° no backlog, n√£o pode ser puxada para o passo Especifica√ß√£o, pois o WIP desse passo est√° no limite.</p></li>
<li><p>Uma das tarefas j√° especificadas (T8 a T12) pode ser puxada para implementa√ß√£o, pois o WIP desse passo est√° em 4, enquanto o limite √© 5.</p></li>
<li><p>Uma ou mais tarefas em implementa√ß√£o (T4 a T7) podem ser finalizadas, o que n√£o altera o WIP do passo.</p></li>
<li><p>A revis√£o de T3 pode ser finalizada.</p></li>
</ul>
<p>Apenas refor√ßando, o objetivo dos limites WIP √© evitar que os times Kanban fiquem sobrecarregados de trabalho. Quando um desenvolvedor tem muitas tarefas para realizar ‚Äî porque os limites WIP n√£o est√£o sendo respeitados ‚Äî a tend√™ncia √© que ele n√£o consiga concluir nenhuma dessas tarefas com qualidade. Como usual em qualquer atividade humana, quando assumimos muitos compromissos, a qualidade de nossas entregas cai muito. Kanban reconhece esse problema e, para que ele n√£o ocorra, cria uma "trava" autom√°tica para impedir que os times aceitem trabalhos al√©m da sua capacidade de entrega. Essas "travas", que s√£o os limites WIP, servem para uso interno do time e, mais importante ainda, para uso externo. Ou seja, elas s√£o o instrumento de que um time disp√µe para recusar trabalho extra que est√° sendo "empurrado" de cima para baixo por gerentes da organiza√ß√£o, por exemplo.</p>
<h3 id="calculando-os-limites-wip">Calculando os Limites WIP</h3>
<p>Resta-nos agora explicar como os limites WIP s√£o definidos. Existe mais de uma alternativa, mas vamos adotar uma adapta√ß√£o de um algoritmo proposto por Eric Brechner ‚Äî um Engenheiro de Software da Microsoft ‚Äî em seu livro sobre o uso de Kanban no desenvolvimento de software (<a href="https://dl.acm.org/citation.cfm?id=2774938">link</a>). O algoritmo √© o seguinte:</p>
<ul>
<li>Primeiro, temos que estimar quanto tempo em m√©dia uma tarefa vai ficar em cada passo do Quadro Kanban. Esse tempo √© chamado de <strong>lead time (LT)</strong>. No nosso exemplo, vamos supor os seguintes valores:</li>
</ul>
<p>LT(especifica√ß√£o) = 5 dias</p>
<p>LT(implementa√ß√£o) = 12 dias</p>
<p>LT(revis√£o) = 6 dias</p>
<p>Veja que essa estimativa considera uma tarefa m√©dia, pois sabemos que v√£o existir tarefas mais complexas e mais simples. Veja ainda que o lead time inclui o tempo em fila, isto √©, o tempo que a tarefa vai ficar na 2a sub-coluna dos passos do Quadro Kanban aguardando ser puxada para o passo seguinte.</p>
<ul>
<li><p>Em seguida, deve-se estimar o <strong>throughput (TP)</strong> do passo com maior lead time do Quadro Kanban, isto √©, o n√∫mero de tarefas produzidas por dia nesse passo. No nosso exemplo, e na maioria dos projetos de desenvolvimento de software, esse passo √© o de Implementa√ß√£o. Assim, suponha que o nosso time seja capaz de sustentar a implementa√ß√£o de 8 tarefas por m√™s. O <strong>throughput</strong> desse passo √© ent√£o: 8 / 21 = 0.38 tarefas/dia. Veja que consideramos que um m√™s tem 21 dias √∫teis.</p></li>
<li><p>Por fim, o WIP de cada passo √© assim definido:</p></li>
</ul>
<p><strong>WIP(passo) = TP * LT(passo)</strong>.</p>
<p>onde throughput refere-se ao throughput do passo mais lento, conforme calculado no item anterior.</p>
<ul>
<li>Logo, teremos os seguintes resultados:</li>
</ul>
<p>WIP(especifica√ß√£o) = 0.38 * 5 = 1.9</p>
<p>WIP(implementa√ß√£o) = 0.38 * 12 = 4.57</p>
<p>WIP(revis√£o) = 0.38 * 6 = 2.29</p>
<ul>
<li>Arredondando para cima, os resultados ficam assim:</li>
</ul>
<p>WIP(especifica√ß√£o) = 2</p>
<p>WIP(implementa√ß√£o) = 5</p>
<p>WIP(revis√£o) = 3</p>
<p>No algoritmo proposto por Eric Brechner, sugere-se ainda adicionar uma margem de erro de 50% nos WIPs calculados, para acomodar varia√ß√µes no tamanho das tarefas, tarefas bloqueadas devido a fatores externos, etc. No entanto, como nosso exemplo √© ilustrativo, n√£o vamos ajustar os WIPs que foram calculados acima.</p>
<p>Conforme afirmado, limites WIPs s√£o o recurso oferecido por Kanban para garantir um ritmo de trabalho sustent√°vel e a entrega de sistemas de software com qualidade. O papel desses limites √© contribuir para que os desenvolvedores n√£o fiquem sobrecarregados de tarefas e, consequentemente, propensos a baixar a qualidade de seu trabalho. Na verdade, todo m√©todo de desenvolvimento de software tende a oferecer esse tipo de recurso. Por exemplo, em Scrum existe o conceito de sprints com time-boxes definidos, cujo objetivo √© evitar que times aceitem trabalhar em hist√≥rias que ultrapassam a sua velocidade de entrega. Adicionalmente, uma vez iniciado, o objetivo de um sprint n√£o pode ser alterado, de forma a blindar o time de mudan√ßas di√°rias de prioridade. No caso de m√©todos Waterfall, o recurso para garantir um fluxo de trabalho sustent√°vel e de qualidade √© a exist√™ncia de uma fase detalhada de especifica√ß√£o de requisitos. Com essa fase, a inten√ß√£o era oferecer aos desenvolvedores uma ideia clara do sistema que eles deveriam implementar.</p>
<p>üìö <strong>Aprofundamento</strong>: O procedimento para c√°lculo de WIPs explicado anteriormente √© uma aplica√ß√£o direta da <strong>Lei de Little</strong>, que √© um dos resultados mais importantes da Teoria de Filas (<a href="https://isbnsearch.org/isbn/0471503363">link</a>). A Lei de Little diz que o n√∫mero de itens em um sistema de filas √© igual √† taxa de chegada desses itens multiplicado pelo tempo que cada item fica no sistema. Traduzindo para o nosso contexto, o sistema √© um passo de um processo Kanban e os itens s√£o tarefas. Assim, temos tamb√©m que:</p>
<ul>
<li><p>WIP: n√∫mero de tarefas em um dado passo de um processo Kanban</p></li>
<li><p>Throughput (TP): taxa de chegada dessas tarefas nesse passo</p></li>
<li><p>Lead Time (LT): tempo que cada tarefa fica nesse passo</p></li>
</ul>
<p>Ou seja, de acordo com a Lei de Little: <strong>WIP = TP * LT</strong>. Visualmente, podemos representar a Lei de Little da seguinte forma:</p>
<figure>
<img src="figs/cap2/lei-little.png" style="width:40.0%" alt="" /><figcaption>Lei de Little: WIP = TP * LT</figcaption>
</figure>
<p>üí°<strong>Perguntas Frequentes</strong>: Antes de concluir, vamos responder algumas perguntas sobre Kanban:</p>
<p><strong>Quais s√£o os pap√©is que existem em Kanban</strong>? Ao contr√°rio de Scrum, Kanban n√£o define uma lista fixa de pap√©is. Cabe ao time e √† organiza√ß√£o definir os pap√©is que existir√£o no processo de desenvolvimento, tais como Dono do Produto, Testadores, etc.</p>
<p><strong>Como as hist√≥rias dos usu√°rios s√£o priorizadas</strong>? Kanban √© um m√©todo de desenvolvimento mais leve que Scrum e mesmo que XP. Um dos motivos √© que ele n√£o define crit√©rios de prioriza√ß√£o de hist√≥rias. Como respondido na pergunta anterior, n√£o se define, por exemplo, que o time tem que possuir um Dono do Produto, respons√°vel por essa prioriza√ß√£o. Veja que essa √© uma possibilidade, isto √©, pode existir um Dono do Produto em times Kanban. Mas outras solu√ß√µes tamb√©m s√£o poss√≠veis, como prioriza√ß√£o externa, por um gerente de produto.</p>
<p><strong>Times Kanban podem realizar eventos t√≠picos de Scrum, como reuni√µes di√°rias, revis√µes e retrospectivas</strong>? Sim, apesar de Kanban n√£o prescrever a realiza√ß√£o desses eventos. Por√©m, tamb√©m n√£o h√° um veto expl√≠cito aos mesmos. Cabe ao time decidir quais eventos s√£o importantes, quando eles devem ser realizados, com que dura√ß√£o, etc.</p>
<p><strong>Em vez de um Quadro Kanban f√≠sico, com adesivos em uma parede ou em um quadro branco, pode-se usar um software para gerenciamento de projetos?</strong> Kanban n√£o pro√≠be o uso de software de gerenciamento de projetos. Por√©m, recomenda-se o uso de um quadro f√≠sico, pois um dos princ√≠pios mais importantes de Kanban √© a visualiza√ß√£o do trabalho pelo time, de forma que seus membros possam a qualquer momento tomar conhecimento do trabalho em andamento e de poss√≠veis problemas e gargalos que estejam ocorrendo. Em alguns casos, chega-se a recomendar a ado√ß√£o de ambas solu√ß√µes: um quadro f√≠sico, mas com um backup em um software de gerenciamento de projetos, que possa ser acessado pelos gerentes e executivos da organiza√ß√£o.</p>
<p>üì∫ <strong>V√≠deo Complementar</strong>: Para conhecer mais sobre Kanban, recomendamos uma apresenta√ß√£o sobre o m√©todo realizada por Eric Brechner em 2016 e dispon√≠vel neste <a href="https://youtu.be/CD0y-aU1sXo">link</a>, com dura√ß√£o de pouco mais de uma hora. O interessante √© que a palestra √© organizada como um projeto Kanban. Por exemplo, um quadro √© usado para coletar as perguntas da plateia, que v√£o ent√£o sendo respondidas pelo palestrante.</p>
<h2 id="quando-n√£o-usar-m√©todos-√°geis">2.6 Quando n√£o Usar M√©todos √Ågeis?</h2>
<p>Apesar de m√©todos √°geis ‚Äî como aqueles estudados nas se√ß√µes anteriores ‚Äî terem alcan√ßado um sucesso inquestion√°vel, √© bom lembrar que n√£o existe bala-de-prata em Engenharia de Software, conforme comentamos no Cap√≠tulo 1. Assim, neste cap√≠tulo vamos discutir cen√°rios e dom√≠nios nos quais pr√°ticas √°geis podem n√£o ser adequadas.</p>
<p>No entanto, a pergunta que abre essa se√ß√£o n√£o admite uma resposta simples, como, por exemplo, sistemas das √°reas X, Y e Z n√£o devem usar m√©todos √°geis; e os demais devem usar. Em outras palavras, sistemas de qualquer √°rea podem se beneficiar de pelo menos algumas das pr√°ticas propostas por m√©todos √°geis. Por outro lado, existem pr√°ticas que n√£o s√£o recomendadas para determinados tipos de sistemas, organiza√ß√µes e contextos. Assim, vamos responder a pergunta proposta em uma granularidade mais fina. Isto √©, vamos comentar sobre quando n√£o usar determinadas pr√°ticas de desenvolvimento √°gil. Para isso, usaremos a seguinte tabela:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Pr√°tica</strong></th>
<th style="text-align: left;"><strong>Quando n√£o usar?</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Design Incremental</td>
<td style="text-align: left;">Design incremental faz sentido quando o time tem uma primeira vis√£o do design do sistema. Se o time n√£o tem essa vis√£o, ou o dom√≠nio do sistema √© novo e complexo, ou o custo de mudan√ßas futuras √© muito alto, recomenda-se adotar uma fase de design e an√°lise inicial, antes de partir para itera√ß√µes que requeiram implementa√ß√µes de funcionalidades.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Hist√≥rias do Usu√°rio</td>
<td style="text-align: left;">Hist√≥rias s√£o um m√©todo leve para especifica√ß√£o de requisitos, que depois s√£o clarificados com o envolvimento cotidiano de um representante dos clientes no projeto. Por√©m, em certos casos, pode ser importante ter uma especifica√ß√£o detalhada de requisitos no in√≠cio do projeto, principalmente se ele for um projeto de uma √°rea totalmente nova para o time de desenvolvedores.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Envolvimento do Cliente</td>
<td style="text-align: left;">Se os requisitos do sistema s√£o est√°veis e de pleno conhecimento do time de desenvolvedores, n√£o faz sentido ter um Representante dos Clientes ou Dono do Produto integrado ao time. Por exemplo, esse papel n√£o √© importante no desenvolvimento de um compilador para uma linguagem conhecida, com uma gram√°tica e sem√¢ntica consolidadas.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Documenta√ß√£o Leve e Simplificada</td>
<td style="text-align: left;">Em certos dom√≠nios, documenta√ß√µes detalhadas de requisitos e de projeto s√£o mandat√≥rias. Por exemplo, sistemas cujas falhas podem causar a morte de seres humanos, como aqueles das √°reas m√©dicas e de transporte, costumam demandar certifica√ß√£o por uma entidade externa, que pode exigir uma documenta√ß√£o detalhada, al√©m do c√≥digo fonte.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Times Auto-organiz√°veis</td>
<td style="text-align: left;">Times √°geis s√£o aut√¥nomos e empoderados para trabalhar sem interfer√™ncias durante o time-box de uma itera√ß√£o. Consequentemente, eles n√£o precisam prestar contas di√°rias para os gerentes e executivos da organiza√ß√£o. No entanto, essa caracter√≠stica pode ser incompat√≠vel com os valores e cultura de certas organiza√ß√µes, principalmente aquelas com uma tradi√ß√£o de n√≠veis hier√°rquicos e de controle r√≠gidos.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Contratos com Escopo Aberto</td>
<td style="text-align: left;">Em contratos com escopo aberto, a remunera√ß√£o √© por hora trabalhada. Assim, a empresa que assina o contrato n√£o tem ‚Äî no momento da assinatura ‚Äî uma ideia precisa de quais funcionalidades ser√£o implementadas e nem do prazo e custo do sistema. Algumas organiza√ß√µes podem n√£o se sentir seguras para assinar esse tipo de contrato, principalmente quando elas n√£o t√™m uma experi√™ncia pr√©via com desenvolvimento √°gil ou refer√™ncias confi√°veis sobre a empresa contratada.</td>
</tr>
</tbody>
</table>
<p>Para concluir, √© importante mencionar que duas pr√°ticas √°geis s√£o atualmente adotadas na grande maioria de projetos de software:</p>
<ul>
<li><p>Times pequenos, pois o esfor√ßo de sincroniza√ß√£o cresce muito quando os times s√£o compostos por dezenas de membros.</p></li>
<li><p>Itera√ß√µes (ou sprints), mesmo que com dura√ß√£o maior do que aquela t√≠pica de m√©todos √°geis. Por exemplo, itera√ß√µes com dura√ß√£o de dois ou tr√™s meses, em vez de itera√ß√µes com menos de 30 dias. Na verdade, entre o surgimento de Waterfall e de m√©todos √°geis, alguns m√©todos iterativos foram propostos, isto √©, m√©todos com pontos de valida√ß√£o ao longo do desenvolvimento. Na pr√≥xima se√ß√£o, iremos estudar dois destes m√©todos.</p></li>
</ul>
<h2 id="outros-m√©todos-iterativos">2.7 Outros M√©todos Iterativos</h2>
<p>A transi√ß√£o entre Waterfall ‚Äî dominante nas d√©cadas de 70 e 80 ‚Äî e m√©todos √°geis ‚Äî que come√ßaram a surgir na d√©cada de 90, mas que s√≥ ganharam popularidade no final dos anos 2000 ‚Äî foi gradativa. Como em m√©todos √°geis, esses m√©todos surgidos nesse per√≠odo de transi√ß√£o possuem o conceito de itera√ß√µes. Ou seja, eles n√£o s√£o estritamente sequenciais, como em Waterfall. Por√©m, as itera√ß√µes tem dura√ß√£o maior do que aquela usual em desenvolvimento √°gil. Em vez de poucas semanas, elas duram alguns meses. Por outro lado, eles preservam caracter√≠sticas relevantes de Waterfall, como √™nfase em documenta√ß√£o e em uma fase inicial de levantamento de requisitos e depois de design.</p>
<p>Um exemplo de proposta de processo surgida nesta √©poca √© o <strong>Modelo em Espiral</strong>, proposto por Barry Boehm, em 1986 (<a href="https://doi.org/10.1145/12944.12948">link</a>). Nesse modelo, um sistema √© desenvolvido na forma de uma espiral de itera√ß√µes. Cada itera√ß√£o, ou "volta completa" na espiral, inclui quatro etapas (veja tamb√©m a pr√≥xima figura):</p>
<ul>
<li><p>Defini√ß√£o de objetivos e restri√ß√µes, tais como custos, cronogramas, etc.</p></li>
<li><p>Avalia√ß√£o de alternativas e an√°lise de riscos. Por exemplo, pode-se chegar √† conclus√£o de que √© mais interessante comprar um sistema pronto, do que desenvolver o sistema internamente.</p></li>
<li><p>Desenvolvimento e testes, por exemplo, usando Waterfall. Ao final dessa etapa, deve-se gerar um prot√≥tipo que possa ser demonstrado aos usu√°rios do sistema.</p></li>
<li><p>Planejamento da pr√≥xima itera√ß√£o ou ent√£o tomar a decis√£o de parar, pois o que j√° foi constru√≠do √© suficiente para atender √†s necessidades da organiza√ß√£o.</p></li>
</ul>
<p>Assim, o Modelo em Espiral produz, a cada itera√ß√£o, vers√µes mais completas de um sistema, come√ßando da vers√£o gerada no centro da espiral. Por√©m, cada itera√ß√£o, somando-se as quatro fases, pode levar de 6 a 24 meses. Portanto, mais do que em XP e Scrum. Uma outra caracter√≠stica importante √© a exist√™ncia de uma fase expl√≠cita de an√°lise de riscos, da qual devem resultar medidas concretas para mitigar os riscos identificados no projeto.</p>
<figure>
<img src="figs/cap2/espiral.jpg" style="width:50.0%" alt="" /><figcaption>Modelo Espiral. Cada itera√ß√£o √© dividida em quatro etapas.</figcaption>
</figure>
<p>O <strong>Processo Unificado (UP)</strong>, proposto no final da d√©cada de 90, √© outro exemplo de m√©todo iterativo de desenvolvimento. UP foi proposto por profissionais ligados a uma empresa de consultoria e de ferramentas de apoio ao desenvolvimento de software chamada Rational, que em 2003 seria comprada pela IBM. Por isso, o m√©todo √© tamb√©m chamado de <strong>Rational Unified Process (RUP)</strong>.</p>
<p>Devido a suas origens, UP √© vinculado a duas tecnologias espec√≠ficas:</p>
<ul>
<li><p>UP √© baseado na linguagem de modelagem UML. Todos os seus resultados s√£o documentados e representados usando-se diagramas gr√°ficos de UML. No Cap√≠tulo 4, iremos estudar UML com mais calma. Por enquanto, vamos ressaltar que a proposta era ter uma linguagem de modelagem "unificada" (UML) e tamb√©m um processo "unificado" (UP), ambos propostos pelo mesmo grupo de profissionais.</p></li>
<li><p>UP √© associado a ferramentas de apoio ao projeto e an√°lise de software, conhecidas como <strong>ferramentas CASE</strong> (<em>Computer-Aided Software Engineering</em>). O nome √© uma analogia com ferramentas CAD (<em>Computer Aided-Design</em>), usadas em projetos de Engenharia Civil, Engenharia Mec√¢nica, Arquitetura, etc. A ideia era que o projeto e an√°lise de um sistema deveriam ser integralmente baseados em diagramas UML. Mas esses diagramas n√£o seriam desenhados em papel e sim usando-se ferramentas computacionais (veja um exemplo de tela de uma ferramenta CASE na pr√≥xima figura). A Rational, al√©m de propor o m√©todo UP, tamb√©m desenvolvia e vendia licen√ßas de uso de ferramentas CASE.</p></li>
</ul>
<figure>
<img src="figs/cap2/case.png" style="width:55.0%" alt="" /><figcaption>Exemplo de diagrama UML desenhado usando uma ferramenta CASE. Imagem extra√≠da de <a href="https://umbrello.kde.org/screenshots.php">link</a>.</figcaption>
</figure>
<p>UP prop√µe que o desenvolvimento de um sistema seja decomposto nas seguintes fases:</p>
<ul>
<li><p><strong>Inception</strong> (√†s vezes, traduzida como inicia√ß√£o ou concep√ß√£o): que inclui an√°lise de viabilidade, defini√ß√£o de or√ßamentos, an√°lise de riscos e defini√ß√£o de escopo do sistema. Ao final dessa fase, o caso de neg√≥cio (<em>business case</em>) do sistema deve estar bem claro. Pode-se inclusive decidir que n√£o vale a pena desenvolver o sistema, mas sim comprar um sistema pronto.</p></li>
<li><p><strong>Elabora√ß√£o</strong>: que incluiu especifica√ß√£o de requisitos (via casos de uso de UML), defini√ß√£o da arquitetura do sistema, bem como de um plano para o seu desenvolvimento. Ao final dessa fase, todos os riscos identificados na fase anterior devem estar devidamente controlados e mitigados.</p></li>
<li><p><strong>Constru√ß√£o</strong>: na qual se realiza o projeto de mais baixo n√≠vel, implementa√ß√£o e testes do sistema. Ao final dessa fase, deve ser disponibilizado um sistema funcional, incluindo documenta√ß√£o e manuais, que possam ser validados pelos usu√°rios.</p></li>
<li><p><strong>Transi√ß√£o</strong>: na qual ocorre a disponibiliza√ß√£o do sistema para produ√ß√£o, incluindo a defini√ß√£o de todas as rotinas de implanta√ß√£o, como pol√≠ticas de backup, migra√ß√£o de dados de sistemas legados, treinamento da equipe de opera√ß√£o, etc.</p></li>
</ul>
<p>Assim como no Modelo Espiral, pode-se repetir v√°rias vezes o processo; ou seja, o desenvolvimento √© incremental, com novas funcionalidades sendo entregues a cada itera√ß√£o. Adicionalmente, pode-se repetir cada um das fases. Por exemplo, constru√ß√£o ‚Äî em uma dada itera√ß√£o ‚Äî pode ser dividida em duas sub-fases, cada uma construindo uma parte do produto. A pr√≥xima figura ilustra o modelo de itera√ß√µes de UP.</p>
<figure>
<img src="figs/cap2/rup1.jpg" style="width:60.0%" alt="" /><figcaption>Fases e itera√ß√µes do Processo Unificado (UP). Repeti√ß√µes s√£o poss√≠veis em cada fase (auto-la√ßos). E tamb√©m pode-se repetir todo o fluxo (la√ßo externo), para gerar mais um incremento de produto.</figcaption>
</figure>
<p>UP define tamb√©m um conjunto de disciplinas de engenharia que incluem por exemplo: modelagem de neg√≥cios, defini√ß√£o de requisitos, an√°lise e design, implementa√ß√£o, testes e implanta√ß√£o. Essas disciplinas ‚Äî ou fluxos de trabalho ‚Äî podem ocorrer em qualquer fase. Por√©m, espera-se que algumas disciplinas sejam mais intensas em determinadas fases, como mostra a pr√≥xima figura. No projeto ilustrado, tarefas de modelagem de neg√≥cio est√£o concentradas nas fases iniciais do projeto (inception e elabora√ß√£o) e quase n√£o ocorrem nas fases seguintes. Por outro lado, implementa√ß√£o est√° concentrada na fase de Constru√ß√£o.</p>
<figure>
<img src="figs/cap2/rup2.png" style="width:60.0%" alt="" /><figcaption>Fases (na horizontal) e disciplinas (na vertical) de um projeto desenvolvido usando UP. A √°rea da curva mostra a intensidade da disciplina durante cada fase (imagem da <a href="https://en.wikipedia.org/wiki/Rational_Unified_Process#/figs/cap2/File:Development-iterative.png">Wikipedia</a>, licen√ßa: dom√≠nio p√∫blico).</figcaption>
</figure>
<h2 id="bibliografia">Bibliografia</h2>
<ul>
<li><p>Kent Beck, Cynthia Andres. Extreme Programming Explained: Embrace Change. Addison-Wesley, 2nd edition, 2004.</p></li>
<li><p>Kent Beck. Embracing Change with Extreme Programming. IEEE Computer, vol.¬†32, issue 10, p.¬†70-77, 1999.</p></li>
<li><p>Kent Beck, Martin Fowler. Planning Extreme Programming. Addison-Wesley, 2000.</p></li>
<li><p>Ken Schwaber, Jeff Sutherland. The Scrum Guide, 2017.</p></li>
<li><p>Kenneth Rubin. Essential Scrum: A Practical Guide to the Most Popular Agile Process. Addison-Wesley, 2012</p></li>
<li><p>Eric Brechner. Agile Project Management with Kanban. Microsoft Press, 2015.</p></li>
<li><p>David Anderson. Kanban. Blue Hole Press, 2013.</p></li>
<li><p>Ian Sommerville. Engenharia de Software. Pearson, 10a edi√ß√£o, 2019.</p></li>
<li><p>Hans van Vliet. Software Engineering: Principles and Practice. 3rd Edition. Wiley, 2008.</p></li>
<li><p>Armando Fox e David Patterson. Construindo Software como Servi√ßo: Uma Abordagem √Ågil Usando Computa√ß√£o em Nuvem. Strawberry Canyon LLC. 1a Edi√ß√£o, vers√£o 1.1.2, 2014.</p></li>
</ul>
<h2 id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o</h2>
<ol type="1">
<li><p>Como XP preconiza que devem ser os contratos de desenvolvimento de software.</p></li>
<li><p>Quais as diferen√ßas entre XP e Scrum?</p></li>
<li><p>Times Scrum s√£o ditos cross-funcionais e auto-organiz√°veis. Por que? Defina esses termos.</p></li>
<li><p>Qual a diferen√ßa entre as hist√≥rias do "topo" e do "fundo" do Backlog do Produto, em Scrum?</p></li>
<li><p>O que s√£o e para que servem story points?</p></li>
<li><p>Em Scrum, qual a diferen√ßa entre uma sprint review e uma retrospectiva?</p></li>
<li><p>Um sprint pode ser cancelado? Se sim, por quem e por qual motivo? Para responder a essa quest√£o, consulte antes o Scrum Guide (<a href="https://www.scrum.org/resources/scrum-guide">link</a>), que √© o guia que documenta a vers√£o oficial de Scrum.</p></li>
<li><p>Procure pensar em um sistema de uma √°rea da qual tenha algum conhecimento. (a) Escreva ent√£o uma hist√≥ria para esse sistema (veja que hist√≥rias s√£o especifica√ß√µes resumidas de funcionalidades, com 2-3 senten√ßas). (b) Em seguida, quebre a hist√≥ria que definiu em algumas tarefas (de forma semelhante ao que fizemos no sistema similar ao Stack Overflow, usado como exemplo na se√ß√£o sobre XP). (c) Existem depend√™ncias entre essas tarefas? Ou elas podem ser implementadas em qualquer ordem?</p></li>
<li><p>Suponha dois times, A e B, atuando em projetos diferentes, contratados por empresas distintas, sem conex√µes entre eles. Por√©m, ambos os times adotam sprints de 15 dias e ambos possuem 5 desenvolvedores. Nos seus projetos, o time A considera que sua velocidade √© de 24 pontos. J√° o time B assume uma velocidade de 16 pontos. Pode-se afirmar que A √© 50% mais produtivo que B? Justifique sua resposta.</p></li>
<li><p>Quais s√£o as principais diferen√ßas entre Scrum e Kanban?</p></li>
<li><p>Quais s√£o as diferen√ßas entre um Quadro Scrum e um Quadro Kanban?</p></li>
<li><p>Qual o erro existe no seguinte Quadro Kanban?</p></li>
</ol>
<p><img src="figs/cap2/kanban4.jpg" style="width:80.0%" /></p>
<ol start="13" type="1">
<li>Suponha o seguinte quadro Kanban. Neste momento, o time n√£o consegue trabalhar na especifica√ß√£o de novas hist√≥rias, pois o WIP do passo Especifica√ß√£o est√° sendo totalmente preenchido por itens esperando movimenta√ß√£o para o passo seguinte (Implementa√ß√£o). O que seria mais recomendado neste momento: (a) desrespeitar o WIP e j√° puxar uma nova hist√≥ria do Backlog para Especifica√ß√£o; ou (b) ajudar o time nas tr√™s tarefas em Valida√ß√£o, de forma a desbloquear o fluxo do processo.</li>
</ol>
<p><img src="figs/cap2/kanban5.jpg" style="width:80.0%" /></p>
<ol start="14" type="1">
<li>Seja um processo Kanban, dividido em quatro passos. A tabela abaixo informa o lead time de cada um deles e o throughout do passo C, que √© o passo mais lento. Com base nesses valores, calcule o WIP de cada passo (√∫ltima coluna da tabela).</li>
</ol>
<table class="preset" style="width:85%;">
<colgroup>
<col style="width: 16%" />
<col style="width: 26%" />
<col style="width: 27%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th><strong>Passo</strong></th>
<th><p><strong>Lead time</strong></p>
<strong>m√©dio (dias)</strong></th>
<th><p><strong>Throughput</strong></p>
<strong>(tarefas/dia)</strong></th>
<th><strong>WIP</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A</td>
<td>4</td>
<td>-</td>
<td></td>
</tr>
<tr class="even">
<td>B</td>
<td>3</td>
<td>-</td>
<td></td>
</tr>
<tr class="odd">
<td>C</td>
<td>10</td>
<td>0.5</td>
<td></td>
</tr>
<tr class="even">
<td>D</td>
<td>5</td>
<td>-</td>
<td></td>
</tr>
</tbody>
</table>
<ol start="15" type="1">
<li><p>Por que se recomenda que os limites WIP calculados usando a Lei de Little sejam incrementados, por exemplo em 50%, de forma a admitir uma margem de erro? Em outros palavras, quais eventos podem originar esses erros na estimativa dos WIPs?</p></li>
<li><p>Descreva os principais recursos oferecidos por Waterfall, Scrum e Kanban para controlar riscos e garantir um fluxo de trabalho sustent√°vel e que propicie o desenvolvimento de software com qualidade.</p></li>
<li><p>Seja o seguinte gr√°fico, que mostra ‚Äî para um determinado sistema ‚Äî como os custos de mudan√ßas variam conforme a fase do desenvolvimento em que elas s√£o realizadas. (a) Qual m√©todo de desenvolvimento voc√™ recomendaria para esse sistema? Justifique sua resposta. (b) Sistemas de quais dom√≠nios podem ter uma curva de custos de mudan√ßas semelhante a essa?</p></li>
</ol>
<p><img src="figs/cap2/custo-mudancas.png" style="width:45.0%" /></p>
<ol start="18" type="1">
<li><p>Por que m√©todos como o Processo Unificado (UP) e Espiral n√£o s√£o considerados √°geis? E qual a diferen√ßa deles para o Modelo Waterfall?</p></li>
<li><p>O artigo "<em>Development and Deployment at Facebook</em>" (<a href="https://research.fb.com/publications/development-and-deployment-at-facebook/">link</a>) apresenta os m√©todos e pr√°ticas de desenvolvimento de software usados no Facebook. Na sua primeira se√ß√£o (p√°ginas 2-3; figura 2), os autores fazem uma distin√ß√£o entre alguns m√©todos de desenvolvimento, baseando-se na frequ√™ncia com que vers√µes de um sistema s√£o liberadas para uso quando se adota cada um deles. Complete a seguinte tabela informando a frequ√™ncia de releases mencionada no artigo para alguns m√©todos e pol√≠ticas de libera√ß√£o de software.</p></li>
</ol>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>M√©todo (ou pol√≠tica de libera√ß√£o de releases)</strong></th>
<th style="text-align: left;"><strong>Frequ√™ncia com que novas releases s√£o liberadas</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Waterfall</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">Evolucion√°rio (exemplo: Espiral)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">√Ågil</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">M√©todo usado no Facebook</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Deployment Cont√≠nuo</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<footer>
ASERG/DCC/UFMG. Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formul√°rio</a>.
</footer>
</body>
</html>
