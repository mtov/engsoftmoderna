<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 9: Refactoring ‚Äì Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: 1;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">
<img src="https://engsoftmoderna.info/figs/capa/capa-3d.jpg"></a>
</p>

<p>
<a href="https://engsoftmoderna.info">P√°gina principal do livro</a>
</p>

<p>Compre na

<a href="https://www.amazon.com.br/gp/product/6500019504">Amazon</a> ou
<!--
<a href="https://www.submarino.com.br/produto/1768283036/engenharia-de-software-moderna">
      Submarino</a> ou 
<a href="https://loja.umlivro.com.br/engenharia-de-software-moderna-4778188/p">
      UmLivro</a>
-->
<a href="https://www.casasbahia.com.br/livros/InformaticaCertificacao/livrosdeinformatica/engenharia-de-software-moderna-1513074930.html">Casas Bahia</a>
</p>

<p>
Veja tamb√©m os cursos de extens√£o a dist√¢ncia 
<a href="https://www.engsoftmoderna.dcc.ufmg.br">Engenharia de Software Moderna</a> (48 horas) e
<a href="https://www.testesoft.dcc.ufmg.br">Teste de Software</a> (20 horas), oferecidos pelo DCC/UFMG.</p>


<!---
<p>
Veja tamb√©m nosso <a href="https://engsoftmoderna.info/curso">curso de extens√£o</a> a dist√¢ncia, com certificados emitidos pelo DCC/UFMG. 
</p>
--->
<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="9" id="refactoring"><span
class="header-section-number">9</span> Refactoring <a
href="#refactoring" class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>I'm not a great programmer; I'm just a good programmer with great
habits.</em> ‚Äì Kent Beck</p>
</blockquote>
<p>Este cap√≠tulo inicia com uma introdu√ß√£o a refactorings, os quais s√£o
modifica√ß√µes realizadas em um programa para facilitar o seu entendimento
e futura evolu√ß√£o. Na Se√ß√£o 9.2, apresentamos uma s√©rie de opera√ß√µes de
refactoring, incluindo exemplos de c√≥digo, alguns deles de refactorings
reais, realizados em sistemas de c√≥digo aberto. Em seguida, na Se√ß√£o
9.3, discutimos alguns aspectos sobre a pr√°tica de refactoring,
incluindo a import√¢ncia de uma boa su√≠te de testes de unidade. A Se√ß√£o
9.4 apresenta os recursos oferecidos por IDEs para realiza√ß√£o
automatizada de refactorings. Para finalizar, a Se√ß√£o 9.5 descreve uma
lista de code smells, isto √©, indicadores de que uma determinada
estrutura de c√≥digo n√£o est√° <q>cheirando bem</q> e que, portanto,
poderia ser objeto de uma refatora√ß√£o.</p>
<h2 data-number="9.1" id="introdu√ß√£o"><span
class="header-section-number">9.1</span> Introdu√ß√£o <a
href="#introdu√ß√£o" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p></p>
<p>No cap√≠tulo anterior, vimos que software precisa ser testado, como
qualquer produto de engenharia. A mesma recomenda√ß√£o vale para
atividades de manuten√ß√£o. Isto √©, software tamb√©m precisa de manuten√ß√£o.
Na verdade, na Introdu√ß√£o deste livro, j√° comentamos que existem
diversos tipos de manuten√ß√£o que podem ser realizadas em sistemas de
software. Quando um bug √© detectado, temos que realizar uma
<strong>manuten√ß√£o corretiva</strong>. Quando os usu√°rios ou o dono do
produto solicitam uma nova funcionalidade, temos que realizar uma
<strong>manuten√ß√£o evolutiva</strong>. Quando uma regra de neg√≥cio ou
alguma tecnologia usada pelo sistema muda, temos que reservar tempo para
uma <strong>manuten√ß√£o</strong> <strong>adaptativa</strong>.</p>
<p> Al√©m disso, sistemas de software tamb√©m envelhecem, como ocorre com
os seres vivos. Ainda no in√≠cio da d√©cada de 1970, Meir Lehman ‚Äî ent√£o
trabalhando na IBM ‚Äî come√ßou a observar e analisar esse fen√¥meno e, como
resultado, enunciou um conjunto de leis emp√≠ricas sobre envelhecimento,
qualidade interna e evolu√ß√£o de sistemas de software, que ficaram
conhecidas <strong>Leis da Evolu√ß√£o de Software</strong> ou simplesmente
<strong>Leis de Lehman</strong>. As duas primeiras leis enunciadas por
Lehman foram as seguintes:</p>
<ul>
<li><p>Um sistema de software deve ser continuamente mantido para se
adaptar ao seu ambiente. Esse processo deve continuar at√© o ponto em que
se torna mais vantajoso substitu√≠-lo por um sistema completamente
novo.</p></li>
<li><p>√Ä medida que um sistema sofre manuten√ß√µes, sua complexidade
interna aumenta e a qualidade de sua estrutura deteriora-se, a n√£o ser
que um trabalho seja realizado para estabilizar ou evitar tal
fen√¥meno.</p></li>
</ul>
<p>A primeira lei justifica a necessidade de manuten√ß√µes adaptativas e
tamb√©m evolutivas em sistemas de software. Ela tamb√©m menciona que
sistemas podem <q>morrer</q>, isto √©, pode chegar a um ponto em que vale
mais a pena descontinuar o desenvolvimento de um sistema e substitu√≠-lo
por um novo. J√° a segunda Lei de Lehman afirma que manuten√ß√µes tornam o
c√≥digo e a estrutura interna de um sistema mais complexos e dif√≠ceis de
manter no futuro. Em outras palavras, existe uma deteriora√ß√£o natural da
qualidade interna de um sistema, √† medida que ele passa por manuten√ß√µes
e evolu√ß√µes. No entanto, a segunda lei faz uma ressalva: um certo
trabalho pode ser realizado para estabilizar ou mesmo evitar esse
decl√≠nio natural da qualidade interna de sistemas de software.
Modernamente, esse trabalho √© chamado de
<strong>refactoring</strong>.</p>
<p> Refactorings s√£o transforma√ß√µes de c√≥digo que melhoram a
manutenibilidade de um sistema, mas sem afetar o seu funcionamento. Para
explicar essa defini√ß√£o, vamos dividi-la em tr√™s partes. Primeiro,
quando a defini√ß√£o menciona <q>transforma√ß√µes de c√≥digo</q>, ela est√° se
referindo a modifica√ß√µes no c√≥digo, como dividir uma fun√ß√£o em duas,
renomear uma vari√°vel, mover uma fun√ß√£o para outra classe, extrair uma
interface de uma classe, etc. Em seguida, a defini√ß√£o menciona o
objetivo de tais transforma√ß√µes: <q>melhorar a manutenibilidade</q> do
sistema, isto √©, melhorar sua modularidade, melhorar seu projeto ou
arquitetura, melhorar sua testabilidade, tornar o c√≥digo mais leg√≠vel,
mais f√°cil de entender e modificar, etc. Por fim, coloca-se uma
restri√ß√£o: n√£o adianta melhorar a manutenibilidade do sistema e
prejudicar o seu funcionamento. Ou seja, refactoring deve entregar o
sistema funcionando exatamente como antes das transforma√ß√µes. Uma outra
maneira de dizer isso √© afirmando que refactorings devem preservar o
comportamento ou a sem√¢ntica do sistema.</p>
<p> No entanto, nas d√©cadas de 70 e 80, quando as Leis de Lehman foram
formuladas, o termo refactoring ainda n√£o era usado. Um dos primeiros
usos do termo em Engenharia de Software ocorreu em 1992, em uma tese de
doutorado defendida por William Opdyke, na Universidade de Illinois, EUA
(<a href="https://dl.acm.org/citation.cfm?id=169783">link</a>). Em
seguida, em 1999, refactoring ‚Äî j√° com esse nome ‚Äî foi inclu√≠do entre as
pr√°ticas de programa√ß√£o preconizadas por Extreme Programming. Na
primeira edi√ß√£o do livro de XP, recomenda-se que desenvolvedores devem
realizar refactorings com o objetivo de <q>reestruturar seus sistemas,
sem mudar o comportamento deles e sim para remover duplica√ß√£o de c√≥digo,
melhorar a comunica√ß√£o com outros desenvolvedores, simplificar o c√≥digo
ou torn√°-lo mais flex√≠vel</q>.</p>
<p> Em 2000, Martin Fowler lan√ßou a primeira edi√ß√£o de um livro dedicado
exclusivamente a refactoring, que alcan√ßou grande sucesso e contribuiu
para popularizar essa pr√°tica de programa√ß√£o. Um dos motivos desse
sucesso foi o fato de o livro incluir um cat√°logo com dezenas de
refactorings. De uma forma que lembra um cat√°logo de padr√µes de projeto
(tal como estudamos no Cap√≠tulo 6), a apresenta√ß√£o dos refactorings
come√ßa dando um nome para eles, o que contribuiu para criar um
vocabul√°rio sobre refactoring. No livro, Fowler tamb√©m apresenta a
mec√¢nica de funcionamento de cada refactoring, inclui exemplos de c√≥digo
e discute os benef√≠cios e desvantagens dos refactorings.</p>
<p> Em seu livro, Fowler cita tamb√©m a frase de Kent Beck que abre esse
cap√≠tulo e que ressalta a import√¢ncia de seguir <q>bons h√°bitos de
programa√ß√£o</q>, os quais s√£o fundamentais para preservar a sa√∫de de um
sistema, garantindo que ele continuar√° evoluindo por anos. Portanto,
desenvolvedores n√£o devem realizar apenas manuten√ß√µes corretivas,
adaptativas e evolutivas. √â importante cuidar tamb√©m da manutenibilidade
do sistema, por meio da realiza√ß√£o frequente de refactorings.</p>
<p><strong>Tradu√ß√£o</strong>: Decidimos n√£o traduzir refactoring quando
usado como substantivo. O motivo √© que achamos que o substantivo em
ingl√™s j√° faz parte do vocabul√°rio dos desenvolvedores de software
brasileiros. Por√©m, quando usada como verbo (<em>to refactor</em>),
traduzimos para refatorar.</p>
<p><strong>Aviso:</strong> O termo refactoring tornou-se comum em
desenvolvimento de software. Por isso, √†s vezes ele √© usado para indicar
a melhoria de outros requisitos n√£o-funcionais, que n√£o est√£o
relacionados com manutenibilidade. Por exemplo, frequentemente, ouvimos
desenvolvedores mencionar que v√£o refatorar o c√≥digo para melhorar seu
desempenho, para introduzir concorr√™ncia, para melhorar a usabilidade de
sua interface, etc. No entanto, neste livro, vamos usar o termo restrito
√† sua defini√ß√£o original, isto √©, apenas para denotar modifica√ß√µes de
c√≥digo que melhoram a sua manutenibilidade.</p>
<h2 data-number="9.2" id="cat√°logo-de-refactorings"><span
class="header-section-number">9.2</span> Cat√°logo de Refactorings <a
href="#cat√°logo-de-refactorings" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>Nesta se√ß√£o, vamos apresentar os principais refactorings do cat√°logo
de Fowler. Assim como adotado nesse cat√°logo, vamos comentar sobre os
seguintes t√≥picos na apresenta√ß√£o de cada refactoring: nome, motiva√ß√£o,
mec√¢nica de aplica√ß√£o e exemplos de uso. Al√©m disso, vamos usar alguns
exemplos de refactorings reais, realizados por desenvolvedores de
sistemas de c√≥digo aberto dispon√≠veis no GitHub.</p>
<h3 data-number="9.2.1" id="extra√ß√£o-de-m√©todo"><span
class="header-section-number">9.2.1</span> Extra√ß√£o de M√©todo <a
href="#extra√ß√£o-de-m√©todo" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Extra√ß√£o de M√©todo √© um dos principais refactorings, tendo como
objetivo extrair um trecho de c√≥digo de um m√©todo <code>f</code> e
lev√°-lo para um novo m√©todo <code>g</code>. Ent√£o, o m√©todo
<code>f</code> passa a incluir uma chamada de <code>g</code>. O pr√≥ximo
c√≥digo ilustra o funcionamento desse refactoring. Primeiro, o c√≥digo
antes do refactoring:</p>
<pre><code>void f () {
  ... // A
  ... // B 
  ... // C
}</code></pre>
<p>E agora o c√≥digo ap√≥s a extra√ß√£o do m√©todo <code>g</code>:</p>
<pre><code>void g() {  // m√©todo extra√≠do
  ... // B
}

void f () {
  ...  // A
  g(); // chama m√©todo extra√≠do
  ...  // C
}
</code></pre>
<p> Existem tamb√©m varia√ß√µes na mec√¢nica de funcionamento de uma
extra√ß√£o de m√©todo. Por exemplo, pode-se extrair de uma vez v√°rios
m√©todos <code>g1</code>, <code>g2</code>, ‚Ä¶, <code>gn</code> de um
m√©todo <code>f</code>. Pode-se tamb√©m extrair o mesmo c√≥digo
<code>g</code> de v√°rios m√©todos <code>f1</code>, <code>f2</code>, ‚Ä¶,
<code>fn</code>. Nesse caso, a extra√ß√£o √© usada para eliminar
<strong>duplica√ß√£o de c√≥digo</strong>, pois o c√≥digo de <code>g</code>
estava aparecendo no corpo de diversos m√©todos.</p>
<p>Para realizar uma Extra√ß√£o de M√©todo pode ser necess√°rio passar
par√¢metros para o m√©todo extra√≠do. Isso ocorre, por exemplo, se o m√©todo
precisar acessar vari√°veis locais do m√©todo original. O m√©todo extra√≠do
pode ter ainda que retornar algumas dessas vari√°veis, caso elas sejam
usados depois pelo m√©todo original. Por fim, se existirem vari√°veis
locais que somente s√£o usadas no m√©todo extra√≠do, deve-se extrair tamb√©m
a declara√ß√£o delas do m√©todo original. Ou seja, elas n√£o ser√£o mais
necess√°rias no m√©todo original.</p>
<p>Extra√ß√£o de M√©todo √© conhecido como o <q>canivete su√≠√ßo</q> dos
refactorings, pois ele √© um dos refactorings com mais aplica√ß√µes. Por
exemplo, Extra√ß√£o de M√©todo pode ser usado para quebrar um m√©todo grande
em m√©todos menores. Cada um desses m√©todos tem uma fun√ß√£o espec√≠fica,
que deve ficar clara em seu nome. Assim, fica mais f√°cil entender o
m√©todo original, pois ele passar√° a conter apenas uma sequ√™ncia de
chamadas dos m√©todos extra√≠dos. Vamos mostrar um exemplo a seguir.
Outras aplica√ß√µes de Extra√ß√£o de M√©todo s√£o discutidas em uma se√ß√£o
<q>Mundo Real</q>, ap√≥s o exemplo.</p>
<p><strong>Exemplo:</strong> A seguir, mostramos um exemplo real de
Extra√ß√£o de M√©todo, realizada em um sistema Android. Esse sistema possui
um m√©todo <code>onCreate</code>, que usa comandos SQL para criar as
tabelas do banco de dados que ele manipula. O c√≥digo dessa primeira
vers√£o de <code>onCreate</code> ‚Äî ap√≥s algumas edi√ß√µes, simplifica√ß√µes e
remo√ß√µes de coment√°rios ‚Äî √© mostrado a seguir. O c√≥digo fonte original
possui mais de 200 linhas.</p>
<pre><code>void onCreate(SQLiteDatabase database) {// antes da extra√ß√£o
  // cria tabela 1
  database.execSQL(&quot;CREATE TABLE &quot; +
            CELL_SIGNAL_TABLE + &quot; (&quot; + COLUMN_ID +
            &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + ...
  database.execSQL(&quot;CREATE INDEX cellID_index ON &quot; + ...);
  database.execSQL(&quot;CREATE INDEX cellID_timestamp ON &quot; +...);

  // cria tabela 2
  String SMS_DATABASE_CREATE = &quot;CREATE TABLE &quot; + 
            SILENT_SMS_TABLE + &quot; (&quot; + COLUMN_ID +
            &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + ...
  database.execSQL(SMS_DATABASE_CREATE);
  String ZeroSMS = &quot;INSERT INTO &quot; + SILENT_SMS_TABLE + 
            &quot; (Address,Display,Class,ServiceCtr,Message) &quot; +
            &quot;VALUES (&#39;&quot;+ ...
  database.execSQL(ZeroSMS);

  // cria tabela 3
  String LOC_DATABASE_CREATE = &quot;CREATE TABLE &quot; +      
            LOCATION_TABLE + &quot; (&quot; + COLUMN_ID +
            &quot; INTEGER PRIMARY KEY AUTOINCREMENT, &quot; + ...
  database.execSQL(LOC_DATABASE_CREATE);
  // mais 200 linhas, criando outras tabelas
}
</code></pre>
<p>Para simplificar o entendimento desse m√©todo, um dos desenvolvedores
do IntelliJ resolveu realizar sete Extra√ß√µes de M√©todo. Cada m√©todo
extra√≠do ficou respons√°vel pela cria√ß√£o de uma das tabelas. Apenas
olhando para o nome de tais m√©todos, pode-se ter uma ideia das tabelas
que eles criam. Ap√≥s as extra√ß√µes, o m√©todo <code>onCreate</code> chama
os m√©todos extra√≠dos, como mostrado a seguir. O tamanho do m√©todo caiu
de mais de 200 linhas de c√≥digo para apenas sete linhas. Observe tamb√©m
que os m√©todos extra√≠dos t√™m como um par√¢metro que representa o banco de
dados no qual as tabelas ser√£o criadas.</p>
<pre><code>public void onCreate(SQLiteDatabase database) { 
  createCellSignalTable(database);
  createSilentSmsTable(database);
  createLocationTable(database);
  createCellTable(database);
  createOpenCellIDTable(database);
  createDefaultMCCTable(database);
  createEventLogTable(database);
 }</code></pre>
<h3 data-number="9.2.2" id="motiva√ß√µes-para-extra√ß√£o-de-m√©todos"><span
class="header-section-number">9.2.2</span> Motiva√ß√µes para Extra√ß√£o de
M√©todos <a href="#motiva√ß√µes-para-extra√ß√£o-de-m√©todos"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p>Em 2016, junto com Danilo Silva e com o Prof.¬†Nikolaos Tsantalis (da
Universidade Concordia, em Montreal, no Canad√°), realizamos um estudo
com desenvolvedores de sistemas GitHub para descobrir suas reais
motiva√ß√µes para realiza√ß√£o de refactorings (<a
href="https://arxiv.org/abs/1607.02459">link</a>). No estudo, revelamos
11 motiva√ß√µes distintas para Extra√ß√µes de M√©todos, conforme mostrado na
tabela a seguir.</p>
<table>
<colgroup>
<col style="width: 74%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Motiva√ß√µes para Extra√ß√£o de
M√©todos</strong></th>
<th style="text-align: center;"><strong>Ocorr√™ncias</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Extra√ß√£o de um m√©todo para ser reusado em
outras partes do c√≥digo</td>
<td style="text-align: center;">43</td>
</tr>
<tr class="even">
<td style="text-align: left;">Introduzir uma assinatura alternativa para
um m√©todo existente</td>
<td style="text-align: center;">25</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Dividir um m√©todo em partes menores para
melhorar o seu entendimento</td>
<td style="text-align: center;">21</td>
</tr>
<tr class="even">
<td style="text-align: left;">Remover duplica√ß√£o de c√≥digo</td>
<td style="text-align: center;">15</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Extra√ß√£o de um m√©todo para facilitar a
implementa√ß√£o de uma nova funcionalidade ou a corre√ß√£o de um bug</td>
<td style="text-align: center;">14</td>
</tr>
<tr class="even">
<td style="text-align: left;">Extra√ß√£o de um m√©todo que ter√° um nome
melhor ou menos par√¢metros. O m√©todo original √© depreciado e delega as
suas chamadas para o m√©todo extra√≠do</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Permitir o teste do m√©todo extra√≠do, isto
√©, melhorar testabilidade</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: left;">Permitir que subclasses sobrescrevam o
m√©todo que foi extra√≠do</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Permitir a implementa√ß√£o de um m√©todo
recursivo</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: left;">Introduzir um m√©todo f√°brica, isto √©, as
chamadas de new s√£o movidas para o novo m√©todo</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Implementar opera√ß√µes ass√≠ncronas, isto √©,
o m√©todo √© extra√≠do para ser executado em uma thread independente</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>Analisando essa tabela, podemos ver que a principal motiva√ß√£o √©
extrair um c√≥digo para permitir o seu re√∫so. Ou seja, o desenvolvedor
precisa de um determinado c√≥digo e descobre que ele j√° est√°
implementado, mas dentro de um m√©todo <code>f</code>. Ent√£o, ele extrai
esse c√≥digo para um m√©todo <code>g</code>. Com isso, ele pode agora
reusar <code>g</code> ‚Äî isto √©, chamar <code>g</code> ‚Äî no c√≥digo no
qual est√° trabalhando. Veja como um dos desenvolvedores relatou sua
motiva√ß√£o para extrair um m√©todo:</p>
<blockquote>
<p><q>Esses refactorings foram realizados para garantir reusabilidade.
Eu precisava usar o mesmo c√≥digo em um novo m√©todo. E eu sempre tento
reusar c√≥digo, porque quando come√ßa a ter muita redund√¢ncia no c√≥digo
ele se torna mais dif√≠cil de ser mantido no futuro, visto que quando
alguma coisa muda em c√≥digo duplicado, essa mudan√ßa tem que ser
replicada em todas as c√≥pias.</q></p>
</blockquote>
<p>Como pode ser conferido na tabela anterior, a segunda motiva√ß√£o mais
frequente consiste em introduzir uma assinatura alternativa para um
m√©todo. Um exemplo hipot√©tico √© mostrado a seguir, envolvendo um m√©todo
que faz o logging de uma string em um arquivo.</p>
<p>Primeiro vamos mostrar o c√≥digo original:</p>
<pre><code>void log(String msg) {
  // salva msg em arquivo
}</code></pre>
<p>O desenvolvedor decidiu ent√£o prover uma vers√£o alternativa desse
m√©todo com um par√¢metro booleano, que indica se a string tamb√©m deve ser
mostrada no console. Veja o c√≥digo ap√≥s a extra√ß√£o desse segundo m√©todo
<code>log</code>:</p>
<pre><code>void log(String msg, boolean console) {
  if (console)
     System.out.println(msg);
  // salva msg em um arquivo
}

void log(String msg) {
  log(msg, false);
}</code></pre>
<p>O leitor deve observar que, tecnicamente, a transforma√ß√£o mostrada no
exemplo anterior √© uma Extra√ß√£o de M√©todo. Primeiro, todo o c√≥digo de
<code>log(String)</code> foi extra√≠do para
<code>log(String,boolean)</code>, que √© um novo m√©todo. Em seguida,
pequenos ajustes foram realizados no c√≥digo extra√≠do. Especificamente,
foi adicionado um comando <code>if</code>. Tais ajustes s√£o comuns e n√£o
descaracterizam a transforma√ß√£o como uma Extra√ß√£o de M√©todo.</p>
<h3 data-number="9.2.3" id="inline-de-m√©todo"><span
class="header-section-number">9.2.3</span> Inline de M√©todo <a
href="#inline-de-m√©todo" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Esse refactoring funciona no sentido contr√°rio a uma extra√ß√£o de
m√©todo. Suponha um m√©todo pequeno, com uma ou duas linhas de c√≥digo, e
que seja chamado poucas vezes. O benef√≠cio proporcionado por esse m√©todo
‚Äî em termos de re√∫so e incremento de legibilidade do c√≥digo ‚Äî √© pequeno.
Portanto, ele pode ser removido do sistema e seu corpo incorporado nos
pontos de chamada. No entanto, √© importante ressaltar que Inline de
M√©todos √© uma opera√ß√£o mais rara e menos importante do que Extra√ß√£o.</p>
<p><strong>Exemplo:</strong> A seguir, mostramos um exemplo de Inline de
M√©todo, realizado no sistema IntelliJ, uma IDE para Java. Primeiro,
segue o c√≥digo antes do inline. Podemos ver que o m√©todo
<code>writeContentToFile</code> tem uma √∫nica linha de c√≥digo e √©
chamado apenas uma vez, pelo m√©todo <code>write</code>.</p>
<pre><code>private void writeContentToFile(final byte[] revision) {
  getVirtualFile().setBinaryContent(revision);
}
 
private void write(byte[] revision) {
  VirtualFile virtualFile = getVirtualFile();
  ...
  if (document == null) {
       writeContentToFile(revision); // √∫nica chamada
  }
   ...
 }
</code></pre>
<p>Os desenvolvedores do IntelliJ decidiram ent√£o remover
<code>writeContentToFile</code> e expandir o seu corpo no √∫nico ponto de
chamada. O c√≥digo ap√≥s o refactoring √© mostrado a seguir.</p>
<pre><code>private void write(byte[] revision) {
  VirtualFile virtualFile = getVirtualFile();
  ...
  if (document == null) {
     virtualFile.setBinaryContent(revision);  // ap√≥s inline
  }
  ...
}
</code></pre>
<h3 data-number="9.2.4" id="movimenta√ß√£o-de-m√©todo"><span
class="header-section-number">9.2.4</span> Movimenta√ß√£o de M√©todo <a
href="#movimenta√ß√£o-de-m√©todo" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>N√£o √© raro encontrar um m√©todo implementado na classe errada. Ou
seja, apesar de implementado em uma classe A, um m√©todo <code>f</code>
pode usar mais servi√ßos de uma classe B. Por exemplo, ele pode ter mais
depend√™ncias para elementos de B do que de sua classe A. Nesses casos,
deve-se avaliar a possibilidade de mover f para a classe B. Esse
refactoring pode melhorar a coes√£o da classe A, diminuir o acoplamento
entre A e B e, em √∫ltima inst√¢ncia, tornar ambas as classes mais f√°ceis
de serem entendidas e modificadas.</p>
<p>Pelas suas caracter√≠sticas, Movimenta√ß√£o de M√©todos √© um dos
refactorings com maior potencial para melhorar a modulariza√ß√£o de um
sistema. Como sua atua√ß√£o n√£o est√° restrita a uma √∫nica classe,
Movimenta√ß√£o de M√©todos pode ter um impacto positivo na arquitetura do
sistema, garantindo que os m√©todos estejam nas classes apropriadas,
tanto do ponto de vista funcional como arquitetural.</p>
<p><strong>Exemplo:</strong> O sistema IntelliJ possui um pacote para
execu√ß√£o de testes de unidade, via IDE. Esse pacote, por sua vez, possui
uma classe com m√©todos de uso geral, chamada
<code>PlatformTestUtil</code>. Conforme mostra o c√≥digo a seguir, essa
classe tinha um m√©todo chamado <code>averageAmongMedians</code>, que
calcula a m√©dia das medianas de uma parte de um vetor de inteiros. No
entanto, esse m√©todo n√£o possui rela√ß√£o com a execu√ß√£o de testes de
unidade. Por exemplo, ele n√£o usa m√©todos e atributos de
<code>PlatformTestUtil</code>. Ou seja, ele √© independente do resto da
classe.</p>
<pre><code>class PlatformTestUtil {
  ...
  public static long averageAmongMedians(long[] time, 
                                         int part) {
    int n = time.length;
    Arrays.sort(time);
    long total = 0;
    for (int i= n/2-n/part/2; i&lt; n/2+n/part/2; i++) {
      total += time[i];
    }
    int middlePartLength = n/part;
    return middlePartLength == 0 ? 0:total/middlePartLength;
  }
  ...
}</code></pre>
<p>Pelos motivos expostos no par√°grafo anterior, um dos desenvolvedores
do IntelliJ decidiu mover <code>averageAmongMedians</code> para uma
classe chamada <code>ArrayUtil</code>, que tem como objetivo
disponibilizar fun√ß√µes utilit√°rias para manipula√ß√£o de vetores. Logo,
trata-se de uma classe mais relacionada com a funcionalidade provida por
<code>averageAmongMedians</code>.</p>
<p>Ap√≥s a movimenta√ß√£o para a nova classe, as chamadas de
<code>averageAmongMedians</code> tiveram que ser atualizadas, como
mostrado na figura a seguir.</p>
<figure>
<img src="figs/cap9/diff-intellij.png" style="width:100.0%"
alt="Atualizando chamadas de m√©todo est√°tico ap√≥s movimenta√ß√£o. averageAmongMedians foi movido de PlatformTestUtil para ArrayUtil." />
<figcaption aria-hidden="true">Atualizando chamadas de m√©todo est√°tico
ap√≥s movimenta√ß√£o. <code>averageAmongMedians</code> foi movido de
<code>PlatformTestUtil</code> para <code>ArrayUtil</code>.</figcaption>
</figure>
<p>No entanto, como o leitor pode observar nesse diff, isso n√£o foi
dif√≠cil, pois <code>averageAmongMedians</code> √© um m√©todo est√°tico.
Logo, apenas o nome de sua classe teve que ser atualizado em cada ponto
de chamada.</p>
<p>Em outros casos, no entanto, pode n√£o ser t√£o simples atualizar as
chamadas de um m√©todo ap√≥s ele ser movido para uma nova classe. Isso
acontece quando nos pontos de chamada n√£o existem refer√™ncias para
objetos da nova classe do m√©todo. Uma solu√ß√£o consiste ent√£o em deixar
uma implementa√ß√£o simples do m√©todo na classe de origem. Essa
implementa√ß√£o apenas delega as chamadas para a nova classe do m√©todo.
Por isso, nenhum cliente precisar√° ser alterado. Um exemplo √© mostrado a
seguir. Primeiro, o c√≥digo original:</p>
<pre><code>class A {
  B b = new B();
  void f { ... }
}

class B { ... }

class Cliente {
  A a = new A();
  void g() {
    a.f(); 
    ...
  }
}</code></pre>
<p>E agora o c√≥digo ap√≥s a refatora√ß√£o:</p>
<pre><code>class A {
  B b = new B();
  void f {
    b.f(); // apenas delega chamada para B
  }
}

class B {    // f foi movido de A para B
   void f { ... }
}

class Cliente {
  A a = new A();
  void g() { 
    a.f();    // n√£o precisa mudar
    ...
  }
}</code></pre>
<p>Observe que o m√©todo <code>f</code> foi movido da classe
<code>A</code> para a classe <code>B</code>. Por√©m, em <code>A</code>
ficou uma vers√£o do m√©todo que apenas repassa (ou delega) a chamada para
<code>B</code>. Por isso, o c√≥digo da classe <code>Cliente</code> n√£o
precisou ser alterado.</p>
<p></p>
<p>Quando ocorre em uma mesma hierarquia de classes, Movimenta√ß√£o de
M√©todos ganha nomes especiais. Por exemplo, quando o refactoring move um
m√©todo de subclasses para uma superclasse, ele √© chamado de <strong>Pull
Up Method</strong>. Para ilustrar, suponha um mesmo m√©todo
<code>f</code> implementado em duas subclasses <code>B1</code> e
<code>B2</code>. Para evitar <strong>duplica√ß√£o de c√≥digo</strong>,
pode-se ent√£o <q>subir</q> com ambas implementa√ß√µes para a superclasse
<code>A</code>, como mostra o diagrama de classes da pr√≥xima p√°gina.</p>
<figure>
<img src="figs/cap9/pull-up.svg" style="width:82.0%"
alt="Pull Up Method" />
<figcaption aria-hidden="true">Pull Up Method</figcaption>
</figure>
<p></p>
<p>Por outro lado, quando um m√©todo √© movido para baixo na hierarquia de
classes, isto √©, de uma superclasse para uma subclasse, dizemos que foi
realizado um <strong>Push Down Method</strong>. Por exemplo, apesar de
implementado na superclasse <code>A</code>, um m√©todo <code>f</code>
pode ser do interesse de uma √∫nica subclasse, digamos que
<code>B1</code>. Logo, podemos <q>descer</q> com sua implementa√ß√£o para
<code>B1</code>, como mostrado no diagrama de classes da pr√≥xima
p√°gina.</p>
<figure>
<img src="figs/cap9/push-down.svg" style="width:82.0%"
alt="Push Down Method" />
<figcaption aria-hidden="true">Push Down Method</figcaption>
</figure>
<p>Para concluir, opera√ß√µes de refactoring podem ser feitas em
sequ√™ncia. Por exemplo, suponha a seguinte classe <code>A</code> com um
m√©todo <code>f</code>:</p>
<pre><code>class A {
  B b = new B();

  void f(){
    S1;
    S2;
  }

}

class B { ... }</code></pre>
<p>Primeiro, vamos extrair um m√©todo <code>g</code> com o comando
<code>S2</code> de <code>f</code>:</p>
<pre><code>class A {
  B b = new B();

  void g() { // novo m√©todo extra√≠do de f()
    S2;
  }

  void f(){
    S1;
    g();
  }
}

class B { ... }</code></pre>
<p>Na sequ√™ncia, vamos mover <code>g</code> para uma classe
<code>B</code>, como ilustrado a seguir:</p>
<pre><code>class A {
  B b = new B();

  void f(){
    S1;
    b.g();
  }
}

class B {

  void g() { // movido de A para B
    S2;
  }

}</code></pre>
<h3 data-number="9.2.5" id="extra√ß√£o-de-classes"><span
class="header-section-number">9.2.5</span> Extra√ß√£o de Classes <a
href="#extra√ß√£o-de-classes" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Esse refactoring √© recomendado quando um sistema possui uma classe A
com muitas responsabilidades e atributos. Alguns desses atributos s√£o
relacionados e poderiam ter vida pr√≥pria. Logo, eles podem ser extra√≠dos
para uma nova classe B. Em seguida, declaramos em A um atributo do tipo
B.</p>
<p><strong>Exemplo:</strong> Seja a classe <code>Pessoa</code> mostrada
a seguir. Al√©m de outros atributos, que foram omitidos do exemplo, ela
armazena dados do telefone fixo e celular da pessoa em quest√£o,
incluindo c√≥digo de √°rea e n√∫mero.</p>
<pre><code>class Pessoa {
  String codigoArea;
  String fone;
  String codigoAreaCelular;
  String celular;
  ...
}</code></pre>
<p>Assim, podemos extrair de <code>Pessoa</code> uma nova classe,
chamada <code>Fone</code>, dedicada a armazenar informa√ß√µes sobre
telefones, conforme mostrado a seguir. Ap√≥s o refactoring,
<code>Pessoa</code> passou a ter dois atributos do novo tipo, destinados
a armazenar o telefone fixo e o telefone celular de uma pessoa.</p>
<pre><code>class Fone { // classe extra√≠da
  String codigoArea;
  String numero; 
}

class Pessoa {
  Fone foneFixo;
  Fone foneCelular
  ...
}</code></pre>
<p>Um refactoring similar a <strong>Extra√ß√£o de Classes</strong> √©
chamado de <strong>Extra√ß√£o de Interfaces</strong>. Por exemplo, suponha
que uma biblioteca de estruturas de dados implemente as classes
<code>LinkedList</code> e <code>ArrayList</code>. Dessas duas classes
podemos extrair uma interface <code>List</code>, com os m√©todos comuns a
elas. Assim, os clientes de tais classes podem come√ßar a praticar o
princ√≠pio de projeto <q>Prefira Interfaces a Classes Concretas</q>, que
estudamos no Cap√≠tulo 5.</p>
<h3 data-number="9.2.6" id="renomea√ß√£o"><span
class="header-section-number">9.2.6</span> Renomea√ß√£o <a
href="#renomea√ß√£o" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>Existe uma frase provocativa, atribu√≠da a Phil Karlton, que afirma
que <q>existem apenas duas coisas dif√≠ceis em Ci√™ncia da Computa√ß√£o:
invalida√ß√£o de cache e dar nomes √†s coisas.</q> Como dar nomes √©
dif√≠cil, frequentemente temos que renomear um elemento de c√≥digo, seja
ele uma vari√°vel, fun√ß√£o, m√©todo, par√¢metro, atributo, classe, etc. Isso
pode ocorrer porque o nome dado ao elemento n√£o foi uma boa escolha. Um
outro motivo √© que a responsabilidade desse elemento pode ter mudado com
o tempo e assim seu nome ficou desatualizado. Em ambos os casos,
recomenda-se realizar um dos refactorings mais populares que existe:
<strong>renomea√ß√£o</strong>. Isto √©, dar um nome mais adequado e
significativo para o elemento de c√≥digo.</p>
<p>Quando esse refactoring √© aplicado, a parte mais complexa n√£o √©
renomear o elemento, mas atualizar os pontos do c√≥digo em que ele √©
referenciado. Por exemplo, se um m√©todo <code>f</code> √© renomeado para
<code>g</code>, todas as chamadas de <code>f</code> devem ser
atualizadas. Na verdade, se <code>f</code> for muito usado, pode ser
interessante extra√≠-lo para um novo m√©todo, com o novo nome, e manter o
nome antigo, mas depreciado.</p>
<p>Para mostrar um exemplo, suponha o seguinte m√©todo
<code>f</code>:</p>
<pre><code>void f () {
  // A
}</code></pre>
<p>Segue agora o c√≥digo ap√≥s o refactoring. Veja que extra√≠mos um m√©todo
<code>g</code>, com o c√≥digo antigo de <code>f</code>, que foi ent√£o
depreciado.</p>
<pre><code>void g() {    // novo nome do m√©todo
  // A
}

@deprecated
void f() {    // mant√™m nome antigo
  g();        // mas delega chamada para novo nome
}</code></pre>
<p>Deprecia√ß√£o √© um mecanismo oferecido por linguagens de programa√ß√£o
para indicar que um elemento de c√≥digo est√° desatualizado e, portanto,
desencorajar seu uso. Quando o compilador descobre que um trecho de
c√≥digo est√° usando um elemento depreciado, ele emite um
<em>warning</em>. No exemplo anterior, o m√©todo <code>f</code> n√£o foi
simplesmente renomeado para <code>g</code>. Em vez disso, primeiro
criou-se um m√©todo <code>g</code> com o c√≥digo original de
<code>f</code>. Em seguida, <code>f</code> foi depreciado e seu c√≥digo
modificado para apenas chamar <code>g</code>.</p>
<p>A estrat√©gia baseada em deprecia√ß√£o torna a renomea√ß√£o mais segura,
pois ela n√£o obriga a atualiza√ß√£o de uma s√≥ vez de todas as chamadas de
<code>f</code>, que podem ser muitas e espalhadas em diversos programas.
Ou seja, ela d√° tempo para que os clientes se adaptem √† mudan√ßa e passem
a usar o novo nome. Na verdade, refactorings ‚Äî mesmo os mais simples,
como uma renomea√ß√£o ‚Äî devem ser realizado em pequenos passos, ou em
<strong>baby steps</strong>, para ter certeza que eles n√£o v√£o
prejudicar o correto funcionamento de um sistema.</p>
<h3 data-number="9.2.7" id="outros-refactorings"><span
class="header-section-number">9.2.7</span> Outros Refactorings <a
href="#outros-refactorings" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Os refactorings apresentados anteriormente t√™m maior potencial para
melhorar o projeto de um sistema, pois eles envolvem opera√ß√µes com um
escopo global, como Movimenta√ß√£o de M√©todos ou Extra√ß√£o de Classes.
Por√©m, existem refactorings com escopo local, que melhoram, por exemplo,
a implementa√ß√£o interna de um √∫nico m√©todo. Vamos a seguir descrever
resumidamente alguns desses refactorings.</p>
<p> <strong>Extra√ß√£o de Vari√°veis</strong> √© usado para simplificar
express√µes e torn√°-las mais f√°ceis de ler e entender. Seja o seguinte
c√≥digo de exemplo:</p>
<pre><code>x1 = (-b + sqrt(b*b-4*a*c)) / (2*a);</code></pre>
<p>Esse c√≥digo pode ser refatorado para:</p>
<pre><code>delta = b*b-4*a*c; // vari√°vel extra√≠da
x1 = (-b + sqrt(delta)) / (2*a);
</code></pre>
<p>Veja que uma vari√°vel <code>delta</code> foi criada e inicializada
com uma parte de uma express√£o maior. Com isso, o c√≥digo da express√£o,
ap√≥s a refatora√ß√£o, ficou menor e mais f√°cil de entender.</p>
<p> <strong>Remo√ß√£o de Flags</strong> √© um refactoring que sugere usar
comandos como <code>break</code> ou <code>return</code>, em vez de
vari√°veis de controle, tamb√©m chamadas de flags. Seja o seguinte c√≥digo
de exemplo:</p>
<pre><code>boolean search(int x, int[]a) {
   boolean achou = false;
   i = 0;
   while (i &lt; a.length) &amp;&amp; (!achou) {
     if (a[i] == x);
        achou = true;
     i++;
   }
   return achou;
}</code></pre>
<p>Esse c√≥digo pode ser refatorado da seguinte forma:</p>
<pre><code>boolean search(int x, int[]a) {
  for (i = 0; i &lt; a.length; i++)
    if (a[i] == x)
       return true;
  return false;
}</code></pre>
<p>Observe que a fun√ß√£o ap√≥s a refatora√ß√£o ficou menor e com uma l√≥gica
mais clara, gra√ßas ao uso de um comando <code>return</code> para
retornar imediatamente assim que um determinado valor tenha sido
encontrado em um vetor.</p>
<p> Existe tamb√©m refactorings que tratam da simplifica√ß√£o de comandos
condicionais. Um deles √© chamado de <strong>Substitui√ß√£o de Condicional
por Polimorfismo</strong>. Para entend√™-lo, suponha um comando
<code>switch</code> que retorna o valor da bolsa de pesquisa de um
aluno, dependendo do seu tipo:</p>
<pre><code>switch (aluno.type) {
   case &quot;graduacao&quot;: 
      bolsa = 500;
      break;
   case &quot;mestrado&quot;: 
      bolsa = 1500;
      break;
   case &quot;doutorado&quot;: 
      bolsa = 2500;
      break;
}</code></pre>
<p>Em uma linguagem orientada a objetos, esse comando pode ser
refatorado para apenas uma linha de c√≥digo:</p>
<p><code>bolsa = aluno.getBolsa();</code></p>
<p>Na vers√£o refatorada, o atributo <code>type</code> de Aluno n√£o √©
mais necess√°rio e, portanto, pode ser removido. Al√©m disso, temos que
implementar nas subclasses de <code>Aluno</code> ‚Äî por exemplo,
<code>AlunoGraduacao</code>, <code>AlunoMestrado</code> e
<code>AlunoDoutorado</code> ‚Äî um m√©todo <code>getBolsa()</code>. Por
fim, na superclasse <code>Aluno</code> esse m√©todo deve ser abstrato,
isto √©, ter apenas uma assinatura, sem corpo.</p>
<p> <strong>Remo√ß√£o de C√≥digo Morto</strong> recomenda deletar m√©todos,
classes, vari√°veis ou atributos que n√£o est√£o sendo mais usados. Por
exemplo, no caso de um m√©todo, pode n√£o existir mais chamadas para ele.
No caso de uma classe, ela pode n√£o ser mais instanciada ou herdada por
outras classes. No caso de um atributo, ele pode n√£o ser usado no corpo
da classe, nem em subclasses ou em outras classes. Pode parecer que
Remo√ß√£o de C√≥digo Morto √© um refactoring raro, mas em grandes sistemas,
desenvolvidos ao longo de anos por programadores diferentes, costuma
existir uma quantidade consider√°vel de c√≥digo que n√£o √© mais
chamado.</p>
<h2 data-number="9.3" id="pr√°tica-de-refactoring"><span
class="header-section-number">9.3</span> Pr√°tica de Refactoring <a
href="#pr√°tica-de-refactoring" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>Tendo apresentado diversos refactorings na se√ß√£o anterior, vamos
agora discutir como a pr√°tica de refactoring pode ser adotada em
projetos reais de desenvolvimento de software.</p>
<p>Primeiro, a realiza√ß√£o bem sucedida de refactorings depende da
exist√™ncia de bons testes, principalmente testes de unidade. Ou seja,
sem testes fica arriscado realizar mudan√ßas em um sistema, ainda mais
quando elas n√£o agregam novas funcionalidades ou corrigem bugs, como √© o
caso de refactorings. John Ousterhout tem o seguinte coment√°rio sobre a
import√¢ncia de testes durante atividades de refactoring (<a
href="https://dl.acm.org/citation.cfm?id=3288797">link</a>):</p>
<p></p>
<blockquote>
<p><q>Testes, particularmente testes de unidade, desempenham um papel
importante no projeto de software porque eles facilitam a realiza√ß√£o de
refactorings. Sem uma su√≠te de testes, torna-se arriscado realizar
mudan√ßas estruturais em um sistema. Como n√£o h√° uma maneira f√°cil de
encontrar bugs, √© mais prov√°vel que eles fiquem escondidos at√© que o
c√≥digo entre em produ√ß√£o, quando √© mais caro detect√°-los e corrigi-los.
Como resultado, desenvolvedores tendem a evitar refatora√ß√µes em sistemas
sem boas su√≠tes de teste. Em vez disso, eles reduzem as modifica√ß√µes no
c√≥digo √†quelas necess√°rias para implementar novas funcionalidades ou
corrigir bugs. Consequentemente, a complexidade vai se acumulando e
erros de projeto n√£o s√£o corrigidos.</q></p>
</blockquote>
<p>Uma segunda quest√£o importante diz respeito ao momento em que o
c√≥digo deve ser refatorado. Existem dois modos principais de realizar
refactorings: de forma oportunista ou de forma estrat√©gica.</p>
<p> <strong>Refactorings oportunistas</strong> s√£o realizados no meio de
uma tarefa de programa√ß√£o, quando se descobre que um trecho de c√≥digo
n√£o est√° bem implementado e que, portanto, pode ser melhorado. Isso pode
acontecer quando se est√° corrigindo um bug ou implementando uma nova
funcionalidade. Por exemplo, no meio dessas tarefas, pode-se perceber
que o nome de um m√©todo n√£o est√° claro, que um m√©todo est√° muito grande
e dif√≠cil de entender, que um comando condicional est√° muito complexo,
que um determinado c√≥digo n√£o √© mais usado, etc. Assim, se o
desenvolvedor descobrir problemas na implementa√ß√£o de um trecho de
c√≥digo, ele deve refator√°-lo imediatamente. Tentando explicar de um modo
mais claro, suponha que um desenvolvedor trabalhe por uma hora na
implementa√ß√£o de uma nova funcionalidade. √â compreens√≠vel e desej√°vel
que parte desse tempo ‚Äî talvez 20% ou mais ‚Äî seja investido em
refactorings. Kent Beck tem uma frase interessante sobre refactorings
oportunistas:</p>
<p></p>
<blockquote>
<p><q>Para cada mudan√ßa que voc√™ tiver que realizar em um sistema,
primeiro torne essa mudan√ßa f√°cil (aviso: isso pode ser dif√≠cil), ent√£o
realize a mudan√ßa facilmente.</q></p>
</blockquote>
<p>A ideia de fundo dessa recomenda√ß√£o √© que um desenvolvedor pode estar
enfrentando dificuldades para implementar uma mudan√ßa exatamente porque
o c√≥digo n√£o est√° preparado para acomod√°-la. Assim, primeiro ele deve
dar um <q>passo atr√°s</q>, isto √©, refatorar o c√≥digo de forma
oportunista, para tornar a mudan√ßa em quest√£o <q>f√°cil</q>. Feito isso,
ele ter√° aberto caminho para dar dois passos a frente e implementar a
mudan√ßa que ficou sob sua responsabilidade.</p>
<p> Na maior parte das vezes, os refactorings s√£o oportunistas. No
entanto, √© poss√≠vel ter tamb√©m <strong>refactorings planejados</strong>.
Normalmente, eles s√£o mudan√ßas mais profundas, demoradas e complexas,
que n√£o valem a pena encaixar no meio de uma outra tarefa de
desenvolvimento. Em vez disso, eles devem ser realizados em sess√µes
planejadas e dedicadas. Por exemplo, esses refactorings podem envolver a
quebra de um pacote em dois ou mais subpacotes, o que pode exigir
atualiza√ß√µes em diversas partes de um sistema. Como um segundo exemplo,
pode ser que o time de desenvolvimento negligenciou a pr√°tica de
refactorings por muito tempo. Ent√£o, como existem muitos refactorings
pendentes, √© melhor planej√°-los para um per√≠odo de tempo espec√≠fico. No
entanto, como afirma Fowler <q>tais epis√≥dios de refactorings planejados
devem ser raros. A maior parte do esfor√ßo de refactoring deve ser do
tipo normal e oportunista.</q></p>
<h2 data-number="9.4" id="refactorings-automatizados"><span
class="header-section-number">9.4</span> Refactorings Automatizados <a
href="#refactorings-automatizados" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p>Diversas IDEs oferecem suporte para automatizar a realiza√ß√£o de
refactorings, da seguinte forma: o usu√°rio seleciona o trecho de c√≥digo
que pretende refatorar e a opera√ß√£o de refactoring que deseja realizar.
Ent√£o, a IDE realiza essa opera√ß√£o automaticamente. Para deixar o
conceito mais claro, as pr√≥ximas figuras ilustram um renomea√ß√£o
autom√°tica de m√©todo via uma IDE. Primeiro, o usu√°rio marca o nome do
m√©todo <code>m1</code>, como mostra a figura:</p>
<p><img src="figs/cap9/automatizado1.png" style="width:37.0%" /></p>
<p>Em seguida, ele escolhe as op√ß√µes de <code>Refactor</code> e
<code>Rename</code> da sua IDE:</p>
<p><img src="figs/cap9/automatizado2.png" style="width:50.0%" /></p>
<p>Ent√£o a IDE pergunta o novo nome que ele pretende dar ao m√©todo
(acompanhe na figura a seguir). Nessa mesma caixa de di√°logo, o
desenvolvedor informa que deseja atualizar as refer√™ncias para esse
m√©todo, para que elas usem o novo nome.</p>
<p><img src="figs/cap9/automatizado3.png" style="width:50.0%" /></p>
<p>Feito isso, a IDE realiza o refactoring automaticamente:</p>
<p><img src="figs/cap9/automatizado4.png" style="width:37.0%" /></p>
<p>Primeiro, o nome do m√©todo na classe <code>A</code> foi renomeado
para <code>m11</code>. Al√©m disso, as chamadas feitas em <code>m3</code>
e <code>m4</code> foram atualizadas para usar o novo nome.</p>
<p>Apesar de chamado de refactoring automatizado, o exemplo que
mostramos deixa claro que cabe ao usu√°rio indicar o trecho de c√≥digo que
deseja refatorar e o refactoring que deseja realizar. Ele tamb√©m deve
dar informa√ß√µes sobre esse refactoring. Por exemplo, o novo nome do
identificador, no caso de uma renomea√ß√£o. A partir da√≠ √© que o
refactoring torna-se automatizado.</p>
<p> Antes de aplicar o refactoring, a IDE verifica se as suas
<strong>pr√©-condi√ß√µes</strong> s√£o verdadeiras, isto √©, se a execu√ß√£o do
refactoring ‚Äî conforme requisitado pelo usu√°rio ‚Äî n√£o vai causar um erro
de compila√ß√£o ou ent√£o mudar o comportamento do programa. No exemplo
anterior, se o usu√°rio pedir para renomear <code>m1</code> para
<code>m2</code>, a IDE vai informar que esse refactoring n√£o pode ser
realizado, pois a classe j√° tem um m√©todo chamado <code>m2</code>.</p>
<h3 data-number="9.4.1"
id="verifica√ß√£o-de-pr√©-condi√ß√µes-de-refactorings"><span
class="header-section-number">9.4.1</span> Verifica√ß√£o de Pr√©-condi√ß√µes
de Refactorings <a href="#verifica√ß√£o-de-pr√©-condi√ß√µes-de-refactorings"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p>A verifica√ß√£o das pr√©-condi√ß√µes de refactorings n√£o √© uma tarefa
trivial. Para ilustrar a complexidade dessa tarefa, vamos reusar um
pequeno programa em Java, proposto por Friedrich Steimann e Andreas
Thies (<a href="https://doi.org/10.1007/978-3-642-03013-0_19">link</a>).
Conforme mostrado a seguir, esse programa inclui duas classes,
<code>A</code> e <code>B</code>, implementadas em arquivos distintos,
mas pertencentes a um mesmo pacote <code>P1</code>. Assim, a chamada de
<code>m("abc")</code> no primeiro arquivo ir√° resultar na execu√ß√£o do
m√©todo <code>m(String)</code> da classe <code>B</code>.</p>
<pre><code>// arquivo A.java
package P1;

public class A {
  void n() { 
    new B().m(&quot;abc&quot;); // executa m(String) de B
  }
}
</code></pre>
<pre><code>// arquivo B.java
package P1;

public class B {
  public void m(Object o) {...}
  void m(String s) {...}
}
</code></pre>
<p>No entanto, suponha que a classe <code>B</code> seja movida para um
novo pacote; por exemplo, para um pacote <code>P2</code>:</p>
<pre><code>// arquivo B.java
package P2;   // novo pacote de B

public class B {
  public void m(Object o) {...}
  void m(String s) {...}
} </code></pre>
<p>Apesar de parecer inofensiva, essa Movimenta√ß√£o de Classe muda o
comportamento do programa. Na nova vers√£o, a chamada de
<code>m("abc")</code> resulta na execu√ß√£o de <code>m(Object)</code> e
n√£o mais de <code>m(String)</code>. O motivo √© que a classe
<code>B</code> n√£o est√° mais no mesmo pacote da classe <code>A</code>.
Por isso, <code>m(String)</code> deixou de ser vis√≠vel para
<code>A</code>, pois ele n√£o √© um m√©todo p√∫blico. Para leitores que n√£o
conhecem Java, um m√©todo p√∫blico de uma classe p√∫blica, como
<code>m(Object)</code>, pode ser chamado em qualquer parte do c√≥digo.
Mas m√©todos sem modificador de visibilidade, como
<code>m(String)</code>, somente podem ser chamados por c√≥digo do mesmo
pacote.</p>
<p>Em resumo, o exemplo de Movimenta√ß√£o de Classes que apresentamos n√£o
√© um refactoring, pois ele n√£o preserva o comportamento do programa. Se
realizado com o apoio de uma IDE, caberia a ela detectar tal fato e
avisar ao usu√°rio que o refactoring n√£o poder√° ser realizado, pois ele
muda o comportamento do programa.</p>
<h2 data-number="9.5" id="code-smells"><span
class="header-section-number">9.5</span> Code Smells <a
href="#code-smells" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Code Smells ‚Äî tamb√©m conhecidos como <strong>bad smells</strong> ‚Äî
s√£o indicadores de c√≥digo de baixa qualidade, isto √©, c√≥digo dif√≠cil de
manter, entender, modificar ou testar. Em resumo, c√≥digo que n√£o est√°
<q>cheirando bem</q> e que portanto talvez possa ser refatorado. No
entanto, nessa defini√ß√£o, o termo <q>indicadores</q> significa que n√£o
devemos considerar que todo code smell deve ser imediatamente
refatorado. Essa decis√£o depende de outros fatores, como a import√¢ncia
do trecho de c√≥digo e a frequ√™ncia com que ele precisar√° ser mantido.
Feita essa ressalva, vamos apresentar, no restante desta se√ß√£o, alguns
dos principais code smells.</p>
<h3 data-number="9.5.1" id="c√≥digo-duplicado"><span
class="header-section-number">9.5.1</span> C√≥digo Duplicado <a
href="#c√≥digo-duplicado" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Duplica√ß√£o de c√≥digo √© o principal code smell e aquele com o maior
potencial para prejudicar a evolu√ß√£o de um sistema. C√≥digo duplicado
aumenta o esfor√ßo de manuten√ß√£o, pois altera√ß√µes t√™m que ser replicadas
em mais de uma parte do c√≥digo. Consequentemente, corre-se o risco de
alterar uma parte e esquecer de uma outra. C√≥digo duplicado tamb√©m torna
a base de c√≥digo mais complexa, pois dados e comandos que poderiam estar
modularizados em m√©todos ou classes ficam espalhados pelo sistema.</p>
<p>Para eliminar duplica√ß√£o de c√≥digo, pode-se usar os seguintes
refactorings: Extra√ß√£o de M√©todo (recomendado quando o c√≥digo duplicado
est√° dentro de dois ou mais m√©todos), Extra√ß√£o de Classe (recomendado
quando o c√≥digo duplicado refere-se a atributos e m√©todos que aparecem
em mais de uma classe) e Pull Up Method (recomendado quando o c√≥digo
duplicado √© um m√©todo presente em duas ou mais subclasses).</p>
<p> Trechos de c√≥digo que possuem c√≥digo id√™ntico s√£o chamados de
<strong>clones</strong>. No entanto, diferentes crit√©rios podem ser
usados para definir quando dois trechos de c√≥digo A e B s√£o, de fato,
id√™nticos. Esses crit√©rios d√£o origem a quatro tipos de clones, conforme
descrito a seguir:</p>
<ul>
<li><p>Clone do Tipo 1: quando A e B t√™m o mesmo c√≥digo, com diferen√ßas
apenas em coment√°rios e espa√ßos.</p></li>
<li><p>Clone do Tipo 2: quando A e B s√£o clones do Tipo 1, por√©m as
vari√°veis usadas em A e B podem ter nomes diferentes.</p></li>
<li><p>Clone do Tipo 3: quando A e B s√£o clones do Tipo 2, por√©m com
pequenas mudan√ßas em comandos.</p></li>
<li><p>Clone do Tipo 4: quando A e B s√£o semanticamente equivalentes,
mas suas implementa√ß√µes s√£o baseadas em algoritmos diferentes.</p></li>
</ul>
<p><strong>Exemplo</strong>: Para ilustrar esses tipos de clones, vamos
usar a seguinte fun√ß√£o:</p>
<pre><code>int fatorial(int n) {
  fat = 1;
  for (i = 1; i &lt;= n; i++)
    fat = fat * i;
  return fat;
}</code></pre>
<p>A seguir, mostramos quatro clones dessa fun√ß√£o.</p>
<ul>
<li>Clone Tipo 1: insere um coment√°rio e remove espa√ßos entre os
operadores.</li>
</ul>
<pre><code>int fatorial(int n) {
  fat=1;
  for (i=1; i&lt;=n; i++) 
    fat=fat*i;
  return fat; // retorna fatorial
}
</code></pre>
<ul>
<li>Clone Tipo 2: renomeia algumas vari√°veis.</li>
</ul>
<pre><code>int fatorial(int n) {
  f = 1;
  for (j = 1; j &lt;= n; j++) 
    f = f * j;
  return f; 
}</code></pre>
<ul>
<li>Clone Tipo 3: insere um comando simples, para imprimir o valor do
fatorial.</li>
</ul>
<pre><code>int fatorial(int n) {
  fat = 1;
  for (j = 1; j &lt;= n; j++)
    fat = fat * j;
  System.out.println(fat); // novo comando
  return fat;
}</code></pre>
<ul>
<li>Clone Tipo 4: implementa uma vers√£o recursiva da fun√ß√£o.</li>
</ul>
<pre><code>int fatorial(int n) {
  if (n == 0)
     return 1;
  else return n*fatorial(n-1);
}</code></pre>
<p>Em todos esses casos, n√£o precisar√≠amos ter duas ou mais fun√ß√µes
<code>fatorial</code> no sistema. Apenas uma delas poderia ficar no
c√≥digo e a outra seria removida.</p>
<p><strong>Mundo Real</strong>: Em 2013, Auki Yamashita e Leon Moonen,
dois pesquisadores de um laborat√≥rio de pesquisa na Noruega, publicaram
os resultados de um estudo explorat√≥rio sobre code smells envolvendo 85
desenvolvedores de software (<a
href="https://doi.org/10.1109/WCRE.2013.6671299">link</a>). Quando esses
desenvolvedores foram questionados sobre os code smells com os quais
eles tinham mais preocupa√ß√£o, a resposta mais comum foi C√≥digo
Duplicado, com quase 20 pontos na escala usada pelos pesquisadores para
ordenar as respostas. Em segundo lugar, com metade dos pontos, ficou
M√©todos Longos, que √© o code smell que estudaremos a seguir.</p>
<h3 data-number="9.5.2" id="m√©todos-longos"><span
class="header-section-number">9.5.2</span> M√©todos Longos <a
href="#m√©todos-longos" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Em qualquer sistema, m√©todos devem ser pequenos, com nomes
auto-explicativos e poucas linhas de c√≥digo. <strong>M√©todos
Longos</strong> s√£o considerados um code smell, pois eles tornam o
c√≥digo mais dif√≠cil de entender e manter. Quando nos deparamos com um
m√©todo longo, devemos considerar a possibilidade de usar uma Extra√ß√£o de
M√©todo para quebr√°-lo em m√©todos menores. No entanto, n√£o existe um
limite m√°ximo de linhas de c√≥digo que possa ser usado arbitrariamente
para classificar m√©todos longos, pois isso depende da linguagem de
programa√ß√£o, da relev√¢ncia do m√©todo, do dom√≠nio do sistema, etc. Por√©m,
modernamente, existe uma tend√™ncia em escrever m√©todos pequenos, com
menos de 20 linhas de c√≥digo, por exemplo.</p>
<h3 data-number="9.5.3" id="classes-grandes"><span
class="header-section-number">9.5.3</span> Classes Grandes <a
href="#classes-grandes" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Assim como m√©todos, classes n√£o devem assumir muitas
responsabilidades e prover servi√ßos que n√£o s√£o coesos. Por isso,
<strong>Classes Grandes</strong> (<em>Large Class</em>) √© considerado um
code smell, pois, assim como m√©todos longos, elas tornam o c√≥digo mais
dif√≠cil de entender e manter. Normalmente, √© mais dif√≠cil tamb√©m reusar
essas classes em outro pacote ou sistema. Classes grandes s√£o
caracterizadas por um grande n√∫mero de atributos, com baixa coes√£o entre
eles. A solu√ß√£o para esse smell consiste em usar Extra√ß√£o de Classe para
extrair uma classe menor A' a partir de uma classe grande A. Em seguida,
a classe A passa a ter um atributo do tipo para A'.</p>
<p> </p>
<p><strong>Aprofundamento</strong>: Quando uma classe cresce tanto que
ela passa a monopolizar grande parte da <q>intelig√™ncia</q> de um
sistema, ela √© chamada de <strong>God Class</strong> ‚Äî ou ent√£o de
<strong>Blob</strong>. Classes com nomes muito gen√©ricos, como
<code>Manager</code>, <code>System</code> ou <code>Subsystem</code>
podem representar inst√¢ncias desse smell.</p>
<h3 data-number="9.5.4" id="feature-envy"><span
class="header-section-number">9.5.4</span> Feature Envy <a
href="#feature-envy" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Esse smell designa um m√©todo que parece <q>invejar</q> os dados e
m√©todos de uma outra classe. Dizendo de outro modo, ele acessa mais
atributos e m√©todos de uma classe B do que de sua atual classe A.
Portanto, deve-se analisar a possibilidade de usar Movimenta√ß√£o de
M√©todo para migr√°-lo para a classe <q>invejada</q>.</p>
<p>O m√©todo <code>fireAreaInvalidated2</code>, mostrado no c√≥digo a
seguir, √© um exemplo de Feature Envy. Podemos observar que ele realiza
tr√™s chamadas de m√©todos, mas todas t√™m como alvo um mesmo objeto
<code>abt</code> do tipo <code>AbstractTool</code>. Por outro lado, ele
n√£o acessa nenhum atributo ou chama qualquer m√©todo da sua classe atual.
Logo, deve-se analisar a conveni√™ncia de mover esse m√©todo para
<code>AbstractTool</code>.</p>
<pre><code>public class DrawingEditorProxy 
             extends AbstractBean implements DrawingEditor {
  ...
  void fireAreaInvalidated2 (AbstractTool abt , Double r ){
    Point p1 = abt.getView().drawingToView (...);
    Point p2 = abt.getView().drawingToView (...);
    Rectangle r=new Rectangle(p1.x,p1.y,p2.x-p1.x p2.y-p1.y);
    abt.fireAreaInvalidated (r);
  }
  ...
}</code></pre>
<h3 data-number="9.5.5" id="m√©todos-com-muitos-par√¢metros"><span
class="header-section-number">9.5.5</span> M√©todos com Muitos Par√¢metros
<a href="#m√©todos-com-muitos-par√¢metros" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Al√©m de pequenos, m√©todos, na medida do poss√≠vel, devem ter poucos
par√¢metros. Isto √©, <strong>M√©todos com Muitos Par√¢metros</strong> √© um
smell, que pode ser eliminado de duas formas principais. Primeiro,
deve-se verificar se um dos par√¢metros pode ser obtido diretamente pelo
m√©todo chamado, como mostrado a seguir:</p>
<pre><code>p2 = p1.f();
g(p1, p2);</code></pre>
<p>Nesse caso, <code>p2</code> √© desnecess√°rio, pois ele pode ser obtido
logo no in√≠cio de <code>g</code>, da seguinte forma:</p>
<pre><code>void g(p1) {
  p2 = p1.f(); ...
}
</code></pre>
<p>Uma outra possibilidade √© criar um tipo que agrupe alguns dos
par√¢metros de um m√©todo. Por exemplo, suponha o seguinte m√©todo:</p>
<pre><code>void f(Date inicio, Date fim) {
  ...
}</code></pre>
<p>Pode-se criar uma classe <code>DateRange</code> para representar uma
faixa de datas. O c√≥digo refatorado ficaria assim:</p>
<pre><code>class DateRange {
   Date inicio;
   Date fim;
}

void f(DateRange range} {
  ...
}</code></pre>
<h3 data-number="9.5.6" id="vari√°veis-globais"><span
class="header-section-number">9.5.6</span> Vari√°veis Globais <a
href="#vari√°veis-globais" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Conforme estudamos no cap√≠tulo sobre princ√≠pios de projeto, vari√°veis
globais devem ser evitadas, pois elas d√£o origem a um tipo de
<strong>acoplamento ruim</strong>. Por isso, elas tamb√©m constituem um
code smell. O principal motivo √© que vari√°veis globais dificultam o
entendimento de um m√≥dulo de forma independente dos demais m√≥dulos de um
sistema. Para entender melhor, suponha a seguinte fun√ß√£o:</p>
<pre><code>void f(...) {
  // computa um determinado valor x
  return x + g; // onde g √© uma vari√°vel global
}</code></pre>
<p>Apenas analisando e estudando esse c√≥digo, voc√™ consegue dizer o
valor que <code>f</code> retorna? A resposta √© negativa, pois n√£o basta
entender o c√≥digo que precede o comando <code>return</code> da fun√ß√£o.
Precisamos conhecer tamb√©m o valor de <code>g</code>. Por√©m, como
<code>g</code> √© uma vari√°vel global, seu valor pode ser alterado em
qualquer parte do programa. Tal situa√ß√£o pode facilmente introduzir bugs
nessa fun√ß√£o, pois agora uma √∫nica linha de c√≥digo distante e n√£o
relacionada com <code>f</code> pode influir no seu resultado. Para isso,
basta que essa linha altere o valor de <code>g</code>. Antes de
concluir, em linguagens como Java, atributos est√°ticos de classes
funcionam exatamente como vari√°veis globais. Logo, eles tamb√©m
representam um code smell.</p>
<h3 data-number="9.5.7" id="obsess√£o-por-tipos-primitivos"><span
class="header-section-number">9.5.7</span> Obsess√£o por Tipos Primitivos
<a href="#obsess√£o-por-tipos-primitivos" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Este code smell ocorre quando tipos primitivos (isto √©,
<code>int</code>, <code>float</code>, <code>String</code>, etc.) s√£o
usados no lugar de classes. Por exemplo, suponha que precisamos declarar
uma vari√°vel para armazenar o CEP de um endere√ßo. Na pressa para usar
rapidamente a vari√°vel, podemos declar√°-la como sendo do tipo
<code>String</code>, em vez de criar uma classe dedicada ‚Äî por exemplo,
CEP ‚Äî para esse fim. A principal vantagem √© que uma classe pode oferecer
m√©todos para manipular os valores que a vari√°vel vai armazenar. Por
exemplo, a construtora da classe pode verificar se o CEP informado √©
v√°lido antes de inicializar o objeto. Dessa forma, a classe assume essa
responsabilidade e, consequentemente, evita que ela seja uma preocupa√ß√£o
de seus clientes. Em resumo, n√£o devemos ficar <q>obcecados</q> com
tipos primitivos. Em vez disso, devemos analisar a possibilidade de
criar classes que encapsulem valores primitivos e que ofere√ßam opera√ß√µes
para manipul√°-los. No pr√≥ximo code smell, iremos complementar essa
recomenda√ß√£o e sugerir que tais objetos, sempre que poss√≠vel, devem ser
tamb√©m imut√°veis.</p>
<h3 data-number="9.5.8" id="objetos-mut√°veis"><span
class="header-section-number">9.5.8</span> Objetos Mut√°veis <a
href="#objetos-mut√°veis" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Na segunda vers√£o de seu livro, Fowler considera que <strong>Objetos
Mut√°veis</strong> s√£o um code smell. Um objeto mut√°vel √© aquele cujo
estado pode ser modificado. Por outro lado, um objeto imut√°vel, uma vez
criado, n√£o pode mais ser alterado. Para viabilizar a cria√ß√£o de objetos
imut√°veis, classes devem declarar todos os seus atributos como privados
e final (um atributo final somente pode ser usado para leitura). A
classe tamb√©m deve ser declarada final, para proibir a cria√ß√£o de
subclasses. Se precisarmos alterar um objeto imut√°vel, a √∫nica
alternativa consiste em criar uma nova inst√¢ncia do objeto com o estado
desejado.</p>
<p>Por exemplo, objetos do tipo <code>String</code> em Java s√£o
imut√°veis, como ilustra o seguinte programa.</p>
<pre><code>class Main {
  public static void main(String[] args) {
    String s1 = &quot;Hello World&quot;;
    String s2 = s1.toUpperCase();
    System.out.println(s1);
    System.out.println(s2);
  }
}</code></pre>
<p>Esse programa vai imprimir <q>Hello World</q> e depois <q>HELLO
WORLD</q>. O motivo √© que o m√©todo <code>toUpperCase</code> n√£o altera a
string <code>s1</code>, mas apenas retorna uma c√≥pia dela com as letras
em mai√∫sculo.</p>
<p>Sempre que poss√≠vel devemos criar objetos imut√°veis, pois eles podem
ser compartilhados de forma livre e segura com outras fun√ß√µes. Por
exemplo, em Java, voc√™ pode passar uma string como par√¢metro de uma
fun√ß√£o e ter certeza de que essa fun√ß√£o n√£o vai mudar o seu conte√∫do.
Isso n√£o ocorreria se strings fossem mut√°veis, pois sempre haveria o
risco de a fun√ß√£o chamada alterar a string recebida como par√¢metro. Como
uma segunda vantagem, objetos imut√°veis s√£o por constru√ß√£o thread-safe,
isto √©, n√£o √© necess√°rio sincronizar o acesso de threads aos seus
m√©todos. O motivo √© tamb√©m simples: os problemas cl√°ssicos de sistemas
concorrentes, como condi√ß√µes de corrida, ocorrem apenas quando m√∫ltiplas
threads alteram o estado de um objeto. Se esse estado for imut√°vel, tais
problemas ficam automaticamente eliminados.</p>
<p>No entanto, precisamos entender esse code smell no contexto da
linguagem de programa√ß√£o usada em um sistema. Por exemplo, em linguagens
funcionais, objetos s√£o imut√°veis por defini√ß√£o, ou seja, esse code
smell nunca vai ocorrer. Por outro lado, em linguagens imperativas, √©
normal ter um certo n√∫mero de objetos mut√°veis. Ou seja, nessas
linguagens, o que temos que fazer √© minimizar o n√∫mero de tais objetos,
sem, no entanto, imaginar que vamos elimin√°-los por completo. Por
exemplo, devemos considerar a possibilidade de tornar imut√°veis objetos
simples e pequenos, como aqueles das classes <code>CEP</code>,
<code>Moeda</code>, <code>Endereco</code>, <code>Data</code>,
<code>Hora</code>, <code>Fone</code>, <code>Cor</code>,
<code>Email</code>, etc. Para ilustrar, mostramos a seguir a
implementa√ß√£o de uma classe <code>Data</code> imut√°vel:</p>
<pre><code>final public class Data { // final: n√£o pode ter subclasses
  final private int dia; // final: inicializado uma √∫nica vez
  final private int mes;
  final private int ano;
   
  private void check(int dia, int mes, int ano) 
               throws InvalidDateException {
     // verifica se data v√°lida
     // se n√£o for, lan√ßa InvalidDateException
  } 
   
  public Data(int dia, int mes, int ano) 
         throws InvalidDateException {
    check(dia, mes, ano);
    this.dia = dia;
    this.mes = mes;
    this.ano = ano;
  }
   
  // outros m√©todos
}
</code></pre>
<h3 data-number="9.5.9" id="classes-de-dados"><span
class="header-section-number">9.5.9</span> Classes de Dados <a
href="#classes-de-dados" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Tais classes possuem apenas atributos e nenhum m√©todo. No m√°ximo,
elas possuem getters e setters. Por√©m, como recorrente com code smells,
n√£o devemos considerar que <strong>Classes de Dados</strong> s√£o sempre
um erro de projeto. Em vez disso, o importante √© analisar o c√≥digo e
verificar a possibilidade de mover comportamento para essas classes.
Isto √©, criar m√©todos nessas classes, para realizar opera√ß√µes que j√°
est√£o sendo realizadas, mas de forma espalhada em outras classes.</p>
<h3 data-number="9.5.10" id="coment√°rios"><span
class="header-section-number">9.5.10</span> Coment√°rios <a
href="#coment√°rios" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Pode soar estranho ver coment√°rios inclu√≠dos em uma lista de code
smells. Por exemplo, em cursos de Introdu√ß√£o a Programa√ß√£o, os alunos
s√£o incentivados a comentar todo o c√≥digo produzido, com o objetivo de
ensinar a import√¢ncia de documenta√ß√£o de c√≥digo. No livro <em>Elements
of Programming Style</em>, Brian Kerninghan ‚Äî um dos criadores das
primeiras vers√µes do sistema operacional Unix e da linguagem de
programa√ß√£o C ‚Äî e P. J. Plauger d√£o uma recomenda√ß√£o que ajuda, de forma
certeira, a esclarecer essa d√∫vida. Eles recomendam o seguinte:</p>
<blockquote>
<p><q>N√£o comente c√≥digo ruim, reescreva-o</q>.</p>
</blockquote>
<p>A ideia √© que coment√°rios n√£o devem ser usados para explicar c√≥digo
ruim. Em vez disso, deve-se refatorar o c√≥digo e, com isso, melhorar sua
qualidade e legibilidade. Feito isso, existe uma boa chance de que o
coment√°rio n√£o seja mais necess√°rio. Um exemplo s√£o m√©todos longos como
aquele do programa a seguir.</p>
<pre><code>void f() {
  // task1
  ... 
  // task2
  ... 
  // taskn
  ...
}</code></pre>
<p>Se usarmos Extra√ß√£o de M√©todo para extrair o c√≥digo comentado,
teremos o c√≥digo a seguir de melhor qualidade:</p>
<pre><code>void task1 { ... }
void task2 { ... }
void taskn { ... }

void f { 
  task1();
  task2();
  ...
  taskn();
}</code></pre>
<p>Observe que, no m√©todo <code>f</code>, ap√≥s a refatora√ß√£o,
coment√°rios n√£o s√£o mais necess√°rios, pois os nomes dos m√©todos chamados
j√° revelam muito do que eles fazem.</p>
<p></p>
<p><strong>Aprofundamento</strong>: <strong>D√©bito t√©cnico</strong> √© um
termo cunhado por Ward Cunningham, em 1992, para designar os problemas
t√©cnicos que podem dificultar a manuten√ß√£o e evolu√ß√£o de um sistema.
Dentre outros, esses problemas incluem falta de testes, problemas
arquiteturais (por exemplo, sistemas mais parecidos com uma <em>big ball
of mud</em>), sistemas com um n√∫mero grande de code smells ou sem
qualquer documenta√ß√£o. A inten√ß√£o de Cunningham foi criar um termo que
pudesse ser compreendido por gerentes e pessoas sem conhecimento de
princ√≠pios e pr√°ticas de Engenharia de Software. Assim, ele optou pelo
termo d√©bito para refor√ßar que esses problemas, caso n√£o sejam
resolvidos, em algum momento v√£o requerer o pagamento de juros. Tais
juros v√£o se manifestar na forma de sistemas inflex√≠veis e dif√≠ceis de
manter, nos quais a corre√ß√£o de bugs e a implementa√ß√£o de novas
funcionalidades leva cada vez mais tempo e mostra-se mais arriscada.</p>
<p>Para ilustrar melhor o conceito, suponha que exista um d√©bito t√©cnico
em um determinado m√≥dulo M de um sistema. Suponha ainda que a adi√ß√£o de
uma nova funcionalidade F1 em M requer um esfor√ßo de 3 dias. Por√©m, se
n√£o houvesse o d√©bito t√©cnico, F1 poderia ser implementada em apenas 2
dias. Essa diferen√ßa de um dia constitui os juros cobrados pela
exist√™ncia do d√©bito t√©cnico em M. Uma alternativa seria ent√£o pagar o
principal do d√©bito, isto √©, remover completamente o d√©bito t√©cnico de
M. Mas isso pode levar, por exemplo, 4 dias. Ou seja, se considerarmos
que vamos estender o m√≥dulo com apenas F1, ainda n√£o h√° vantagem. Por√©m,
suponha que nos pr√≥ximos meses vamos ter que implementar mais
funcionalidades em M, tais como F2, F3, F4, etc. Nesse caso, a
elimina√ß√£o do principal do d√©bito t√©cnico pode compensar.</p>
<h2 class="unnumbered" id="bibliografia">Bibliografia <a
href="#bibliografia" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Martin Fowler. Refactoring: Improving the Design of Existing Code,
Addison-Wesley, 1st edition, 2000.</p>
<p>Martin Fowler. Refactoring: Improving the Design of Existing Code,
Addison-Wesley, 2nd edition, 2018.</p>
<p>Danilo Silva, Nikolaos Tsantalis, Marco Tulio Valente. Why We
Refactor? Confessions of GitHub Contributors. Foundations of Soft.
Engineering, 2016.</p>
<h2 class="unnumbered" id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o
<a href="#exerc√≠cios-de-fixa√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>1. Marque a alternativa FALSA:</p>
<p>(a) refactorings melhoram o projeto de um sistema de software.</p>
<p>(b) refactorings tornam o c√≥digo de um sistema mais f√°cil de ser
entendido.</p>
<p>(c) refactorings facilitam a localiza√ß√£o e a corre√ß√£o de bugs
futuros.</p>
<p>(d) refactorings aceleram a implementa√ß√£o de novas
funcionalidades.</p>
<p>(e) refactorings melhoram o desempenho de um sistema, em termos de
tempo de execu√ß√£o.</p>
<p>2. O gr√°fico a seguir mostra o total acumulado de novas
funcionalidades implementadas em dois sistemas (A e B), de dom√≠nios
semelhantes, desenvolvidos por times semelhantes, usando as mesmas
tecnologias. Em qual dos dois sistemas voc√™ acha que refactorings foram
realizados de forma sistem√°tica? Justifique a sua resposta.</p>
<p><img src="figs/cap9/refactoring-exercicio.png"
style="width:70.0%" /></p>
<p>3. Descreva as diferen√ßas entre refactorings oportunistas e
refactorings planejados. Qual dessas formas de refactoring deve ser mais
comum?</p>
<p>4. Escreva o nome de refactorings A e B que se executados em
sequ√™ncia n√£o produzem impacto no c√≥digo de um sistema. Ou seja, o
refactoring B reverte as transforma√ß√µes realizadas pelo refactoring
A.</p>
<p>5. Nos exemplos a seguir, extraia o c√≥digo comentado com a palavra
<q>extrair</q> para um m√©todo <code>g</code>.</p>
<ol type="a">
<li></li>
</ol>
<pre><code>class A {
  void f() {
    int x = 10
    x++;      
    print x;   // extrair
  }
}</code></pre>
<ol start="2" type="a">
<li></li>
</ol>
<pre><code>class A {
  void f() {
    int x = 10
    x++;     // extrair
    print x; // extrair
  }
}</code></pre>
<ol start="3" type="a">
<li></li>
</ol>
<pre><code>class A {
  void f() {
    int x = 10
    x++;     // extrair
    print x; // extrair
    int y = x+1;
    ...
  }
}</code></pre>
<ol start="4" type="a">
<li></li>
</ol>
<pre><code>class A {
  void f() {
    int x = 10
    int y;     // extrair
    y = h()*2; // extrair
    print y;   // extrair
    int z = y+1;
    ...
  }
}</code></pre>
<p>6. A seguinte fun√ß√£o calcula o n-√©simo termo da sequ√™ncia de
Fibonacci. O primeiro termo dessa sequ√™ncia √© 0; o segundo termo √© 1; e
a partir da√≠ o n-√©simo termo √© a soma dos dois termos anteriores.</p>
<pre><code>int fib(int n) {
   if (n == 1)
      return 0;
   if (n == 2)
      return 1;
   return fib(n-1) + fib(n-2);
}</code></pre>
<p>Descreva clones dos Tipos 1, 2, 3 e 4 para essa fun√ß√£o. N√£o precisa
implementar o c√≥digo do clone, mas seja bem preciso na sua resposta ao
indicar as diferen√ßas entre cada clone e o c√≥digo acima.</p>
<p>7. Seja o seguinte trecho de c√≥digo de uma classe <code>Moeda</code>,
que vai armazenar um determinado valor em reais.</p>
<pre><code>class Moeda {
  ...
  private double valor = 0.0;
  void add(Moeda m) {
    this.valor = this.valor + m.getValor();
  } 
  ...
}</code></pre>
<p>(a) Descreva porque objetos da classe <code>Moeda</code> s√£o
mut√°veis.</p>
<p>(b) Reimplemente esse trecho da classe <code>Moeda</code> de forma a
assegurar que os seus objetos sejam imut√°veis (como vimos no cap√≠tulo,
objetos mut√°veis tendem a ser um code smell, principalmente no caso de
objetos pequenos e simples, como provavelmente √© o caso de objetos da
classe em quest√£o).</p>
<p>8. Como discutido no final da Se√ß√£o 9.5, coment√°rios que s√£o usados
para explicar <q>c√≥digo ruim</q> s√£o considerados um code smell. Nessas
situa√ß√µes, o ideal √© tornar o c√≥digo mais claro e, ent√£o, remover os
coment√°rios. A seguir, mostramos mais um caso de coment√°rio que pode ser
deletado. Explique por que esses coment√°rios s√£o desnecess√°rios.</p>
<pre><code>// classe Aluno
class Aluno {
   
   // matr√≠cula do aluno
   int matricula;
   
   // data de nascimento do aluno
   Date dataNascimento;
   
   // endere√ßo do aluno
   Endereco endereco;
   
   // construtor default da classe Aluno
   Aluno() {
     ...
   } 
   ...  
}</code></pre>
<p>9. Use uma IDE, como o Eclipse ou IntelliJ para Java, para realizar
um refactoring simples, em um de seus programas. Por exemplo, realize
uma renomea√ß√£o de m√©todo. Quais as vantagens de se realizar refactorings
com o suporte de IDEs?</p>
<p>10. Use uma IDE para testar o exemplo de Movimenta√ß√£o de Classe
discutido na Se√ß√£o 9.4.1, isto √©, o exemplo com classes <code>A</code> e
<code>B</code> e pacotes <code>P1</code> e <code>P2</code>. Se realizar
a Movimenta√ß√£o de Classe discutida nesse exemplo via IDE, ocorrer√° algum
erro? Se sim, descreva o erro detectado pela IDE.</p>
<h2 class="unnumbered">Perguntas Frequentes</h2>
<p>Veja tamb√©m o <a href="./faq/refactoring-faq.html">FAQ</a> deste cap√≠tulo.</p>
<button onclick="darkMode()">Modo noturno</button>

<script>
function darkMode() {
   var element = document.body;
   element.classList.toggle("dark-mode");
}
</script>

</div>
</div>
</div>

<footer>
Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formul√°rio</a>.
</footer>
</body>
</html>
