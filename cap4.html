<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 4: Modelos – Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    q { quotes: "“" "”" "‘" "’"; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-8249107-3', 'auto');
     ga('send', 'pageview');
  </script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.1/mini-default.min.css">

  <style>
  body {
    background-color: #FCFCFC;
    foreground-color: black;
  }
  </style>
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-8 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">Índice</a>
</p>
<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="1" id="modelos" data-number="1"><span class="header-section-number">4</span> Modelos</h1>
<blockquote>
<p><em>All models are wrong, but some models are useful. So the question you need to ask is not <q>Is the model true?</q> (it never is) but <q>Is the model good enough for this particular application?</q></em> – George Box</p>
</blockquote>
<p>Este capítulo inicia com uma apresentação genérica sobre modelos de software (Seção 4.1). Em seguida, apresentamos uma visão geral sobre UML, que é a notação gráfica mais utilizada para construção de modelos de software (Seção 4.2). Também deixamos claro que vamos estudar UML visando a criação de esboços de software (<em>sketches</em>) e não desenhos técnicos detalhados (<em>blueprints</em>). Nas seções seguintes, apresentamos quatro diagramas UML com um maior nível de detalhes: Diagramas de Classes (Seção 4.3), Diagramas de Pacotes (Seção 4.4), Diagramas de Sequência (Seção 4.5) e Diagramas de Atividades (Seção 4.6).</p>
<h2 data-number="1.1" id="modelos-de-software" data-number="1.1"><span class="header-section-number">4.1</span> Modelos de Software</h2>
<p></p>
<p>Como vimos no capítulo anterior, requisitos documentam <q>o que</q> um sistema deve fazer, valendo-se de um nível de abstração próximo do problema e de seus usuários. Por outro lado, o código fonte é uma representação concreta, de baixo nível e executável do comportamento de um sistema. Portanto, existe uma lacuna entre esses dois mundos: requisitos e código fonte. Para preencher essa lacuna, desde a fundação da área, Engenheiros de Software investem na criação de <strong>modelos</strong>, os quais são criados para ajudar no entendimento e análise de um sistema. Para cumprir essa missão, os modelos usados em Engenharia de Software são mais detalhados do que requisitos, mas ainda menos complexos do que o código fonte de um sistema.</p>
<p>Modelos são largamente usados também em outras Engenharias. Por exemplo, uma engenheira civil pode decidir criar uma maquete para mostrar como será a ponte que ela foi contratada para construir. Em seguida, ela pode criar um modelo matemático e físico da ponte e usá-lo para simular e provar propriedades da mesma, tais como carga máxima, resistência a ventos, ondas, terremotos, etc.</p>
<p>Infelizmente, modelos de software — pelo menos até hoje — são menos efetivos do que os modelos matemáticos e físicos usados em outras Engenharias. O motivo é que ao abstrair detalhes eles também descartam parte da complexidade que é essencial aos sistemas modelados. Frederick Brooks comenta sobre essa questão em seu ensaio "<em>Não Existe Bala de Prata ..."</em> (<a href="https://doi.org/10.1109/MC.1987.1663532">link</a>):</p>
<blockquote>
<p><q>A complexidade de um software é uma propriedade essencial e não acidental. Portanto, representações de uma entidade de software que abstraem sua complexidade normalmente também abstraem sua essência. Por três séculos, matemáticos e físicos obtiveram grandes avanços construindo modelos simplificados de um fenômeno complexo, derivando propriedades de tais modelos e verificando tais propriedade por meio de experimentos. Esse paradigma funcionou porque as complexidades ignoradas não são propriedades essenciais do fenômeno sob estudo. Porém, essa abordagem não funciona quando as complexidades são essenciais.</q></p>
</blockquote>
<p> A frase que abre esse capítulo, do estatístico britânico George Box, também remete a uma reflexão sobre o uso prático de modelos. Apesar de a frase se referir a modelos matemáticos, ela se aplica a outros modelos, inclusive modelos de software. Segundo Box, todos os modelos são <q>errados</q>, pois são simplificações ou aproximações da realidade. Por isso, a questão principal consiste em avaliar se, apesar dessas simplificações, um modelo continua sendo uma abstração útil para o estudo de alguma propriedade do objeto ou fenômeno que ele modela.</p>
<p>Nesta introdução, estamos procurando calibrar as expectativas associadas ao estudo de modelos de software. Por um lado, como afirmamos, eles não têm a mesma efetividade de modelos em outras Engenharias. Além disso, via de regra, modelos de software não são formalismos matemáticos, mas sim representações gráficas de determinadas dimensões de um sistema de software. Por outro lado, isso não implica em dizer que modelos de software são inúteis, a ponto de não merecer um capítulo em um livro sobre práticas de Engenharia de Software Moderna. Se não criarmos expectativas irrealistas, eles podem ter um papel importante no desenvolvimento de sistemas de software, tal como veremos na próxima seção.</p>
<p>Se pensarmos em termos de atividades de desenvolvimento de software, a criação de modelos é considerada uma atividade de projeto (<em>design</em>). Durante o levantamento de requisitos, as atenções estão voltadas para a definição do problema que será resolvido pelo sistema. Quando se avança para atividades de design, o problema já deve estar devidamente entendido e as atenções se voltam para a concepção de uma solução capaz de resolvê-lo. Após essa solução ser projetada, ela deve ser implementada, usando-se linguagens de programação, bibliotecas, frameworks, bancos de dados, etc.</p>
<p>Especificamente, neste capítulo, iremos estudar um subconjunto dos diagramas propostos pela UML (<em>Unified Modelling Language</em>). Vamos começar descrevendo a história e o contexto que levou à criação da UML. Em seguida, vamos estudar alguns dos principais diagramas UML com um pouco mais de detalhe.</p>
<p></p>
<p><strong>Aprofundamento</strong>: Desde a década de 70, pesquisadores têm investigado o uso de modelos matemáticos em Engenharia de Software, por meio do que se chama de <strong>Métodos Formais</strong>. Esses métodos valem-se de uma notação matemática — baseada em lógica, teoria de conjuntos ou Redes de Petri, por exemplo — para derivar <strong>especificações formais</strong> para sistemas de software. Além de serem precisas e não-ambíguas, especificações formais podem ser usadas para provar propriedades de um sistema mesmo antes de sua implementação. Por exemplo, em tese, poderia-se provar que um sistema concorrente não possui deadlocks ou condições de corrida. Pode parecer ambicioso, mas isso ocorre em outras Engenharias. Retomando o exemplo do início da seção, engenheiros civis usam há séculos modelos matemáticos para provar, por exemplo, que uma ponte — antes de ser construída — vai suportar determinada carga e certas condições climáticas. No entanto, o uso de formalismos e especificações matemáticas em Engenharia de Software não avançou como em outras Engenharias. Por isso, eles são pouco usados atualmente, com exceção talvez de alguns sistemas de missão crítica.</p>
<h2 data-number="1.2" id="uml" data-number="1.2"><span class="header-section-number">4.2</span> UML</h2>
<p></p>
<p>UML é uma notação gráfica para modelagem de software. A linguagem define um conjunto de diagramas para documentar e ajudar no design de sistemas de software, particularmente sistemas orientados a objetos. As origens de UML datam da década de 80, quando o paradigma de orientação a objetos estava amadurecendo e vivendo seu auge. Assim, surgiram diversas linguagens orientadas a objetos, como C++, e também algumas notações gráficas para modelagem de software. Lembre-se que os sistemas na década de 80 eram desenvolvidos segundo o Modelo Waterfall, que prescreve uma grande e longa fase de design. A proposta de UML era que nessa fase seriam criados modelos gráficos, que depois seriam repassados para os programadores, para serem convertidos em código fonte.</p>
<p> Na verdade, UML é o resultado de um esforço para unificar as notações gráficas que surgiram no final das décadas de 80 e início da década de 90. Especificamente, a primeira versão de UML foi proposta em 1995, como resultado da unificação de notações que estavam sendo desenvolvidas de forma independente por três Engenheiros de Software conhecidos na época: Grady Booch, Jim Rumbaugh e Ivar Jacobson. Nessa época, surgiram também ferramentas para desenhar diagramas UML, as quais foram chamadas de <strong>ferramentas CASE</strong> (<em>Computer-Aided Software Engineering</em>). O nome é inspirado em ferramentas CAD (<em>Computer Aided Design</em>), usadas para criar modelos para produtos de Engenharia tradicional, como casas, pontes, automóveis, aviões, etc. Por isso, era importante ter uma padronização de UML, de forma que um diagrama criado em uma ferramenta CASE pudesse ser aberto e editado em uma outra ferramenta, de uma empresa diferente. De fato, em 1997, UML passou a ser um padrão gerenciado pela OMG, que é uma organização de padronização financiada por indústrias de software. Desde o início, o desenvolvimento de UML foi comandado por consultores influentes e por grandes empresas de ferramentas ou consultoria, como a Rational, que depois viria a ser comprada pela IBM.</p>
<h3 class="unnumbered" data-number="" id="como-usar-uml" class="unnumbered" data-number="">Como usar UML?</h3>
<p> Martin Fowler, em seu livro sobre UML (<a href="https://dl.acm.org/citation.cfm?id=861282">link</a>), propõe uma classificação sobre formas de uso dessa linguagem de modelagem. Segundo ele, existem três formas principais de uso de UML: como blueprint, como linguagem de programação ou como esboço. Vamos descrever cada uma delas nos próximos parágrafos.</p>
<p> <strong>UML como blueprint</strong> corresponde ao uso de UML vislumbrado por seus criadores, ainda na década de 90. Nessa forma de uso, defende-se que, após o levantamento de requisitos, seja produzido um conjunto de modelos — ou plantas técnicas (<em>blueprints</em>) — documentando diversos aspectos de um sistema e sempre usando diagramas UML. Esses modelos seriam criados por analistas de sistemas, usando-se ferramentas CASE e, depois, repassados a programadores, para codificação. Logo, UML como <em>blueprint</em> é recomendado quando se emprega processos de desenvolvimento do tipo Waterfall ou quando se adota o Processo Unificado (UP). Na verdade, UP foi proposto por pessoas com forte ligação com UML. No entanto, como já discutimos no Capítulo 2, o uso de UML na construção de modelos detalhados e completos é cada vez mais raro. Por exemplo, com métodos ágeis não existe uma longa fase inicial de design (<em>big design up front</em>). Em vez disso, decisões de design são tomadas e refinadas ao longo do desenvolvimento, em cada uma das iterações (ou <em>sprints</em>). Por isso, não iremos neste capítulo nos aprofundar no uso de UML como <em>blueprint</em>.</p>
<p> <strong>UML como linguagem de programação</strong> corresponde ao uso de UML vislumbrado pela OMG, após a padronização da linguagem de modelagem. De forma ambiciosa e pelo menos durante um período, vislumbrou-se a geração de código automaticamente a partir de modelos UML. Em outras palavras, não haveria mais uma fase de codificação, pois o código seria gerado diretamente a partir da <q>compilação</q> de modelos UML. Essa forma de uso é conhecida como <strong>Desenvolvimento Dirigido por Modelos</strong> (<em>Model Driven Development ou MDD</em>). Para que MDD fosse viável, UML foi expandida e ganhou novos recursos e diagramas. Foi a partir desse momento que a linguagem ganhou a reputação de ser pesada e complexa. Porém, mesmo com adição de complexidade extra, o uso de UML para geração de código não se tornou comum, pelo menos na grande maioria dos sistemas.</p>
<p> Resta então o terceiro uso, <strong>UML como esboço</strong>, que corresponde à forma que vamos estudar neste capítulo. Nela, usamos UML para construir diagramas leves e informais de partes de um sistema, vindo daí o nome esboço (<em>sketch</em>). Esses diagramas são usados para comunicação entre os desenvolvedores, em duas situações principais:</p>
<ul>
<li><p><strong>Engenharia Avante</strong> (<em>Forward Engineering</em>):   quando os desenvolvedores usam modelos UML para discutir e analisar alternativas de design, antes que exista qualquer código. Por exemplo, suponha que uma história tenha sido alocada para o sprint corrente. Antes de implementar a história, os desenvolvedores podem se reunir e fazer um esboço das principais classes que deverão ser criadas no sistema, bem como dos relacionamentos entre elas. O objetivo é validar a proposta de tais classes antes de começar a codificar.</p></li>
<li><p><strong>Engenharia Reversa</strong> (<em>Reverse Engineering</em>):   quando os desenvolvedores usam modelos UML para analisar e discutir uma funcionalidade que já se encontra implementada no código fonte. Por exemplo, um desenvolvedor mais experiente pode desenhar alguns diagramas UML para explicar para um desenvolvedor recém-contratado como uma funcionalidade está implementada. Normalmente, é mais fácil conduzir essa explicação usando modelos e diagramas gráficos, do que analisar e explicar cada linha de código. Ou seja, aplica-se aqui o ditado segundo o qual <q>uma figura vale mais do que mil palavras</q>.</p></li>
</ul>
<p>Nas duas situações, o objetivo não é gerar modelos completos e detalhados. Por isso, não se considera o uso de ferramentas complexas e caras, como ferramentas CASE. Muito menos se cogita a geração automática de código a partir desses esboços. Muitas vezes, os diagramas são desenhados em um quadro e, depois, fotografados e apagados. Adicionalmente, usa-se apenas um subconjunto dos diagramas UML.</p>
<p>Como os esboços são pequenos e informais, pode-se questionar a necessidade de uma linguagem padronizada nos cenários que mencionamos. No entanto, consideramos que é melhor usar uma notação existente há anos, mesmo que de forma parcial, do que inventar uma notação própria. Especificamente, o emprego de UML como esboço contribui para evitar dois extremos. Por um lado, ele não assume o emprego rígido, detalhado e sistemático de UML. Por outro lado, evita-se o uso de uma notação informal e <em>ad hoc</em>, cuja semântica pode não ser clara para todos os desenvolvedores. Além disso, UML costuma ser usada em livros, tutoriais e documentos que explicam o uso de frameworks ou técnicas de programação. Por exemplo, no Capítulo 6, usaremos diagramas UML para ilustrar o funcionamento de alguns padrões de projeto. Caso o leitor não tenha tido contato com UML, pode ser que ele tenha dificuldade para entender o conceito que está sendo explicado.</p>
<p>Sintetizando a descrição que acabamos de fazer, modelos de software, como diagramas UML, são usados para comunicação entre desenvolvedores. Ou seja, eles são escritos por e para desenvolvedores. Trata-se de uma diferença importante para documentos de requisitos, que, conforme vimos no capítulo anterior, são escritos por desenvolvedores, mas de forma que eles possam ser lidos e verificados pelos usuários finais do sistema.</p>
<p><strong>Mundo Real</strong>: No segundo semestre de 2013, Sebastian Baltes e Stephan Diehl — ambos pesquisadores da Universidade de Trier, na Alemanha — pediram 394 desenvolvedores para responder um questionário sobre o emprego de esboços (<em>sketches</em>) em atividades de projeto de software (<a href="https://arxiv.org/abs/1706.09172">link</a>). Esses desenvolvedores estavam distribuídos por mais de 32 países, embora a maioria fosse da Alemanha (54%). A análise das respostas obtidas revelou resultados interessantes sobre o uso de esboços em atividades de desenvolvimento de software, conforme descrito a seguir:</p>
<ul>
<li><p>24% dos desenvolvedores que participaram da pesquisa criaram o último esboço no mesmo dia em que responderam ao questionário e 39% no intervalo de tempo máximo de uma semana, antes da resposta. Portanto, esses percentuais indicam que esboços são criados com frequência por desenvolvedores de software.</p></li>
<li><p>58% dos últimos esboços criados pelos participantes foram depois arquivados, seja em papel (6%), digitalmente (42%) ou de ambas as formas (10%). Isso sugere que os desenvolvedores consideram que os esboços carregam informação importante, que talvez seja útil no futuro.</p></li>
<li><p>40% dos esboços foram feitos em papel, 18% em quadros e 39% em computadores.</p></li>
<li><p>52% dos esboços foram feitos para ajudar no projeto (<em>design</em>) da arquitetura do sistema, 48% para ajudar no projeto de novas funcionalidades, 46% para explicar alguma tarefa para um outro desenvolvedor, 45% para analisar requisitos e 44% para ajudar no entendimento de uma tarefa. A soma dos percentuais ultrapassa 100% porque os participantes podiam marcar mais de uma resposta.</p></li>
<li><p>48% dos esboços continham algum elemento de UML e 9% eram integralmente baseados em diagramas UML. Portanto, esses percentuais reforçam a importância de estudar UML, não como notação para documentação detalhada de sistemas (<em>blueprints</em>), mas para ajudar na construção de modelos informais e parciais.</p></li>
</ul>
<h3 class="unnumbered" data-number="" id="diagramas-uml" class="unnumbered" data-number="">Diagramas UML</h3>
<p>  </p>
<p>Os diagramas UML são classificados em dois grandes grupos:</p>
<ul>
<li><p><strong>Diagramas Estáticos (ou Estruturais)</strong> modelam a estrutura e organização de um sistema, incluindo informações sobre classes, atributos, métodos, pacotes, etc. Neste capítulo, vamos estudar dois diagramas estáticos: Diagramas de Classes e Diagramas de Pacotes.</p></li>
<li><p><strong>Diagramas Dinâmicos (ou Comportamentais)</strong> modelam eventos que ocorrem durante a execução de um sistema. Por exemplo, eles podem modelar uma sequência de chamadas de métodos. Neste capítulo, vamos estudar dois diagramas dinâmicos: Diagramas de Sequência e Diagramas de Atividades.</p></li>
</ul>
<p>Para entender melhor a diferença entre esses grupos de diagramas, diagramas estáticos lidam apenas com informações que estão disponíveis, por exemplo, quando da compilação do código resultante dos modelos. Essa visão é estática porque ela não muda, a não ser que sejam realizadas mudanças nos modelos. Já os diagramas dinâmicos fornecem uma visão de tempo de execução. Eles são dinâmicos porque é comum ter execuções diferentes de um mesmo programa. Por exemplo, os usuários podem executar o programa com entradas diferentes, selecionar opções e menus diferentes, etc. Em resumo, se estiver interessado em modelar a estrutura de um programa, você deve usar diagramas estáticos. Se seu interesse for modelar o comportamento de um programa — isto é, o que pode acontecer durante sua execução, quais métodos são de fato executados, etc — você deve usar algum diagrama dinâmico da UML.</p>
<p>Por fim, gostaríamos de lembrar que já tratamos de Diagramas de Casos de Uso no Capítulo 3, quando apresentamos técnicas para especificação de requisitos.</p>
<p> <strong>Aviso:</strong> Existem diversas versões de UML. No restante deste capítulo vamos usar a <strong>versão de UML que é adotada na 3a edição do livro UML Distilled, de Martin Fowler</strong> (<a href="https://dl.acm.org/citation.cfm?id=861282">link</a>). Esse livro foi o primeiro trabalho a discutir o uso de UML como esboço (<em>sketches</em>). Na verdade, vamos estudar um pequeno subconjunto da versão 2.0. Além de tratar de apenas quatro diagramas, não vamos cobrir todos os recursos de cada um deles. O nosso desafio ao escrever este capítulo foi selecionar os 20% (ou menos) dos recursos de UML que são responsáveis por 80% (ou mais) de seu uso prático nos dias de hoje. Para se ter uma ideia do nível de detalhe alcançado por UML, a especificação da versão mais recente da linguagem — versão 2.5.1, quando da escrita deste capítulo — possui 796 páginas. Ela pode ser encontrada no site da OMG (<a href="https://www.omg.org/">link</a>).</p>
<h2 data-number="1.3" id="diagramas-de-classes" data-number="1.3"><span class="header-section-number">4.3</span> Diagramas de Classes</h2>
<p> </p>
<p>Diagramas de classes são os diagramas mais usados da UML. Eles oferecem uma representação gráfica para um conjunto de classes, provendo informações sobre atributos, métodos e relacionamentos que existem entre as classes modeladas.</p>
<p>Um diagrama de classes é desenhado usando-se retângulos e setas. Cada uma das classes é representada por meio de um retângulo com três compartimentos, conforme mostra a figura a seguir. Esses compartimentos contêm o nome da classe (normalmente, em negrito), seus atributos e métodos.</p>
<p><img src="figs/cap4/class0.svg" style="width:28.0%" /></p>
<p>Mostra-se a seguir um diagrama com duas classes: <code>Pessoa</code> e <code>Fone</code>.</p>
<p><img src="figs/cap4/class1.svg" style="width:80.0%" /></p>
<p>Nesse diagrama, pode-se conferir que a classe <code>Pessoa</code> tem três atributos — <code>nome</code>, <code>sobrenome</code> e <code>fone</code> — e dois métodos — <code>setPessoa</code> e <code>getPessoa</code>. Os três atributos são privados, conforme indicado pelo sinal <q>-</q> antes de cada um. Informa-se também o tipo de cada atributo. Por sua vez, os dois métodos são públicos, conforme indicado pelo sinal <q>+</q>. O diagrama possui ainda uma segunda classe, chamada <code>Fone</code>, com três atributos privados — <code>codigo</code>, <code>numero</code> e <code>celular</code> — e três métodos públicos — <code>setFone</code>, <code>getFone</code> e <code>isCelular</code>. No caso dos métodos, informamos também o nome de seus parâmetros e o tipo de retorno.</p>
<p>Porém, se fosse somente isso, os diagramas dariam a impressão de que as classes de um sistema são <q>ilhas</q> sem comunicação entre si. No entanto, um dos principais objetivos de diagramas de classe é mostrar visualmente os relacionamentos que existem entre as classes de um sistema. Por isso, eles incluem também linhas e setas, as quais são usadas para representar três tipos de relacionamentos: <strong>associação</strong>, <strong>herança</strong> e <strong>dependência</strong>. Vamos tratar de cada um deles nos próximos parágrafos.</p>
<h3 data-number="1.3.1" id="associações" data-number="1.3.1"><span class="header-section-number">4.3.1</span> Associações</h3>
<p></p>
<p>Quando uma classe A possui um atributo b de um tipo B, dizemos que existe uma associação de A para B, a qual é representada por meio de uma seta, também de A para B. Na extremidade da seta, informa-se o nome do atributo de A responsável pela associação — no nosso caso, b. Veja o exemplo abaixo (nele, só mostramos as informações que nos interessam; por isso, o compartimento de atributos e métodos está vazio):</p>
<p><img src="figs/cap4/class2.svg" style="width:35.0%" /></p>
<p>Para ficar ainda mais claro, vamos mostrar como seria o código das classes A e B:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">class</span> A {</span>
<span id="cb1-2"><a href="#cb1-2"></a>   ...</span>
<span id="cb1-3"><a href="#cb1-3"></a>   <span class="kw">private</span> B b;</span>
<span id="cb1-4"><a href="#cb1-4"></a>   ...</span>
<span id="cb1-5"><a href="#cb1-5"></a>}</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">class</span> B {</span>
<span id="cb1-9"><a href="#cb1-9"></a>   ...</span>
<span id="cb1-10"><a href="#cb1-10"></a>}</span></code></pre></div>
<p>Portanto, usando associações, podemos transformar o primeiro diagrama que mostramos nesta seção, com as classes <code>Pessoa</code> e <code>Fone</code>, no seguinte diagrama:</p>
<p><img src="figs/cap4/class3.svg" style="width:80.0%" /></p>
<p>As duas versões do diagrama são semanticamente idênticas. A diferença é que na primeira versão as classes aparecem <q>ilhadas</q>. Já na segunda versão, mostrada acima, fica visualmente claro que existe uma associação de <code>Pessoa</code> para <code>Fone</code>. Reforçando, em ambos diagramas, <code>Pessoa</code> tem um atributo fone do tipo <code>Fone</code>. Porém, na primeira versão, esse atributo é mostrado dentro do compartimento de atributos da classe <code>Pessoa</code>. Já na segunda versão, ele é apresentado <q>fora</q> desse compartimento. Mais especificamente, na extremidade da seta que liga <code>Pessoa</code> a <code>Fone</code>. O objetivo é deixar claro que o atributo pertence a <code>Pessoa</code>, mas ele <q>aponta</q> para um objeto do tipo <code>Fone</code>.</p>
<p> Frequentemente, associações incluem informações de <strong>multiplicidade</strong>, que indicam quantos objetos podem estar associados ao atributo responsável pela associação. As informações de multiplicidade mais comuns são as seguintes: 1 (exatamente um objeto), 0..1 (zero ou um objeto) e * (zero ou mais objetos).</p>
<p>No próximo exemplo, incluímos informação sobre a multiplicidade da associação entre <code>Pessoa</code> e <code>Fone</code>, que no caso definimos como sendo 0..1. Essa informação consta acima do nome do atributo responsável pela associação, no caso, fone. E ela explicita que uma <code>Pessoa</code> pode ter zero ou um único telefone. Usando termos de programação, o atributo fone de <code>Pessoa</code> pode ter o valor null, isto é, a <code>Pessoa</code> em questão não tem <code>Fone</code> associado. Ou então ela pode se associar a um único objeto do tipo <code>Fone</code>.</p>
<p><img src="figs/cap4/class4.svg" style="width:80.0%" /></p>
<p>No próximo exemplo, a semântica já é diferente. Nesse caso, uma <code>Pessoa</code> pode estar associada a múltiplos objetos do tipo <code>Fone</code>, inclusive nenhum. Essa multiplicidade é representada pelo * que adicionamos logo acima da seta da associação.</p>
<p><img src="figs/cap4/class5.svg" style="width:80.0%" /></p>
<p>Neste segundo exemplo com informações de multiplicidade, o tipo do atributo <code>fone</code> deve ser um vetor de <code>Fone</code>. Para que fique claro, mostramos o código das classes:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">class</span> Pessoa {</span>
<span id="cb2-2"><a href="#cb2-2"></a>   <span class="kw">private</span> Fone[] fone;</span>
<span id="cb2-3"><a href="#cb2-3"></a>   ...</span>
<span id="cb2-4"><a href="#cb2-4"></a>}</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">class</span> Fone {</span>
<span id="cb2-6"><a href="#cb2-6"></a>   ...</span>
<span id="cb2-7"><a href="#cb2-7"></a>}</span></code></pre></div>
<p>Talvez o leitor possa se perguntar o que é mais correto: uma <code>Pessoa</code> ter no máximo um <code>Fone</code> (isto é, 0..1) ou uma <code>Pessoa</code> ter qualquer quantidade de <code>Fone</code> (isto é, *)? A resposta é simples: depende dos requisitos do sistema. Ou seja, quem deve responder a essa pergunta são os usuários do sistema que estamos modelando. Para nós, o que importa é que Diagramas de Classe são capazes de modelar qualquer um dos dois cenários.</p>
<p>Em alguns casos, informações de multiplicidade são também mostradas na extremidade contrária da seta, como no exemplo abaixo:</p>
<p><img src="figs/cap4/class6.svg" style="width:80.0%" /></p>
<p>Nesse diagrama, a multiplicidade 0..1 — da extremidade com a seta — indica que uma <code>Pessoa</code> pode ter zero ou um único <code>Fone</code>. Mas o mais importante é explicar a multiplicidade que foi adicionada na extremidade oposta da seta, isto é, a multiplicidade *. Ela indica que um <code>Fone</code> pode estar associado a mais de uma <code>Pessoa</code>. Em outras palavras, duas pessoas, distintas, podem compartilhar o mesmo objeto do tipo <code>Fone</code>. No entanto, a associação continua sendo unidirecional, isto é, <code>Pessoa</code> tem um atributo fone que representa o seu <code>Fone</code>. Porém, <code>Fone</code> não possui um atributo para armazenar as diversas pessoas a que ele pode estar associado. Tentando ser mais claro, dada uma <code>Pessoa</code> pode-se recuperar o seu <code>Fone</code>. Para isso, basta acessar o atributo fone. Mas dado um <code>Fone</code> não é possível saber, pelo menos via atributos, a quais objetos do tipo <code>Pessoa</code> ele está associado.</p>
<p>Para concluir, suponha que seja importante <q>navegar</q> nos dois sentidos da associação, isto é, de <code>Pessoa</code> para <code>Fone</code> e também de <code>Fone</code> para <code>Pessoa</code>. A solução para essa exigência é simples: basta tornar a <strong>associação bidirecional</strong>, isto é, adicionar uma seta em cada extremidade da linha que conecta as classes, como mostrado no próximo diagrama.</p>
<p><img src="figs/cap4/class7.svg" style="width:80.0%" /></p>
<p>Para não deixar dúvidas sobre a semântica de uma associação bidirecional, mostramos também o código das duas classes:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> Pessoa {</span>
<span id="cb3-2"><a href="#cb3-2"></a>   ...</span>
<span id="cb3-3"><a href="#cb3-3"></a>   <span class="kw">private</span> Fone fone;</span>
<span id="cb3-4"><a href="#cb3-4"></a>   ...</span>
<span id="cb3-5"><a href="#cb3-5"></a>}</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">class</span> Fone {</span>
<span id="cb3-8"><a href="#cb3-8"></a>   ...</span>
<span id="cb3-9"><a href="#cb3-9"></a>   <span class="kw">private</span> Pessoa[] dono;</span>
<span id="cb3-10"><a href="#cb3-10"></a>   ...</span>
<span id="cb3-11"><a href="#cb3-11"></a>}</span></code></pre></div>
<p>Nesse código, <code>Pessoa</code> possui um atributo privado fone do tipo <code>Fone</code>, que pode ser null; com isso, satisfazemos a extremidade 0..1 da associação bidirecional. Por outro lado, <code>Fone</code> possui um vetor privado, de nome dono, que vai referenciar objetos do tipo <code>Pessoa</code>; assim, satisfazemos a extremidade * da mesma associação.</p>
<p>No último diagrama de classes, omitimos todos os símbolos de visibilidade, tanto pública (+) como privada (-). Isso foi feito, de forma deliberada, para destacar que estamos tratando do uso de UML para criação de esboços, quando os diagramas são criados para discutir e ilustrar uma ideia de design. Logo, nesse contexto, não faz sentido exigir que os diagramas sejam sintaticamente perfeitos. Por isso, pequenos erros ou omissões são tolerados, principalmente quando não há prejuízo para o propósito que levou à criação do diagrama.</p>
<p><strong>Aprofundamento</strong>: UML — dependendo da versão que está sendo usada — admite notações diferentes para associações. Por exemplo, algumas vezes, informa-se um nome para a associação, o qual é mostrado logo acima e ao longo da seta que une as duas classes. Outras vezes, no caso de associações bidirecionais, as duas setas são omitidas — pois a padronização de UML define o seguinte: <q>uma associação em que nenhuma das extremidades é marcada com uma seta de navegabilidade é navegável em ambas as direções</q>. No entanto, essas notações alternativas tendem a ser confusas ou mesmo ambíguas. Por exemplo, Gonzalo Génova e mais dois pesquisadores da Universidade de Madrid, na Espanha, fazem a seguinte observação sobre o uso de associações bidirecionais sem setas: <q>infelizmente, isso pode introduzir ambiguidade na notação gráfica, porque não conseguimos mais distinguir entre associações bidirecionais e associações sem especificação de navegabilidade</q> em uma de suas extremidades. (<a href="http://www.jot.fm/issues/issue_2003_09/article4/">link</a>, Seção 3, quarto parágrafo). Existem ainda dois conceitos frequentemente mencionados quando estudamos associações em UML: composição e agregação. Composição é uma relação na qual a classe de destino <em>não</em> pode existir de forma independente da classe de origem. Por outro lado, quando as duas classes têm ciclos de vida independentes, temos uma relação de agregação. No entanto, na prática, esses conceitos também geram confusão e, por isso, resolvemos não incluí-los na explicação sobre diagramas de classes. A mesma opinião é compartilhada por outros autores. Por exemplo, Fowler afirma que <q>agregação é algo estritamente sem sentido; portanto, eu recomendo que você ignore esse conceito em seus diagramas</q> (<a href="https://dl.acm.org/citation.cfm?id=861282">link</a>, página 68).</p>
<h3 data-number="1.3.2" id="herança" data-number="1.3.2"><span class="header-section-number">4.3.2</span> Herança</h3>
<p></p>
<p>Em diagramas de classes, relações de herança são representadas por meio de setas com a extremidade não preenchida. Essas setas são usadas para conectar subclasses à sua classe base. No próximo exemplo, elas indicam que <code>PessoaFisica</code> e <code>PessoaJuridica</code> são subclasses de <code>Pessoa</code>. Como usual em orientação a objetos, subclasses herdam todos os atributos e métodos da classe base, mas também podem adicionar novos membros. Por exemplo, apenas <code>PessoaFisica</code> tem <code>cpf</code> e apenas <code>PessoaJuridica</code> tem <code>cnpj</code>.</p>
<p><img src="figs/cap4/class10.svg" style="width:85.0%" /></p>
<h3 class="unnumbered" data-number="" id="dependências" class="unnumbered" data-number="">Dependências</h3>
<p></p>
<p>Existe uma dependência de uma classe A para uma classe B, representada por uma seta com uma linha tracejada de A para B, quando a classe A usa a classe B, porém esse uso não ocorre por meio de associação (isto é, A não tem um atributo do tipo B) ou herança (isto é, A não é uma subclasse de B). Dependências ocorrem, por exemplo, quando um método de A declara um parâmetro ou variável local do tipo B ou quando um método de A lança uma exceção do tipo B. Uma dependência é considerada uma modalidade menos forte de relacionamento entre classes do que relacionamentos que ocorrem por meio de associação e herança.</p>
<p>Para ilustrar o uso de dependências em diagramas de classes, considere o seguinte trecho de código:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">import</span><span class="im"> java.util.Stack;</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">class</span> MinhaClasse {</span>
<span id="cb4-4"><a href="#cb4-4"></a>   ...</span>
<span id="cb4-5"><a href="#cb4-5"></a>   <span class="kw">private</span> <span class="dt">void</span> <span class="fu">metodoX</span>() {</span>
<span id="cb4-6"><a href="#cb4-6"></a>     <span class="bu">Stack</span> stack = <span class="kw">new</span> <span class="bu">Stack</span>();</span>
<span id="cb4-7"><a href="#cb4-7"></a>     ...</span>
<span id="cb4-8"><a href="#cb4-8"></a>   }</span>
<span id="cb4-9"><a href="#cb4-9"></a>   ...</span>
<span id="cb4-10"><a href="#cb4-10"></a>}</span></code></pre></div>
<p>Observe que o <code>metodoX</code> de <code>MinhaClasse</code> possui uma variável local do tipo <code>java.util.Stack</code>. Nesse caso, dizemos que existe uma dependência de <code>MinhaClasse</code> para <code>java.util.Stack</code>, a qual é modelada da seguinte forma:</p>
<p><img src="figs/cap4/class9.svg" style="width:50.0%" /></p>
<p>Algumas vezes, logo acima e ao longo da seta tracejada, informa-se o tipo da dependência, usando-se palavras como create (para indicar que a classe de origem instancia objetos da classe de destino da dependência) ou call (para indicar que a classe de origem chama métodos da classe de destino). Essas palavras são escritas entre sinais de menor (&lt;&lt;) e maior (&gt;&gt;). No diagrama a seguir, por exemplo, fica claro o tipo de dependência que <code>ShapeFactory</code> estabelece com a classe <code>Shape</code>.</p>
<p><img src="figs/cap4/class11.svg" style="width:60.0%" /></p>
<p>Uma classe pode ter dependências para um grande número de classes. No entanto, não se costuma representar todas elas em diagramas de classes, mas apenas as mais importantes e que estão diretamente relacionadas com a funcionalidade ou propriedade do sistema que pretendemos esboçar.</p>
<h2 data-number="1.4" id="diagramas-de-pacotes" data-number="1.4"><span class="header-section-number">4.4</span> Diagramas de Pacotes</h2>
<p> </p>
<p>Diagrama de pacotes são recomendados quando se pretende oferecer um modelo de mais alto nível de um sistema, que mostre apenas grupos de classes — isto é, pacotes — e as dependências entre eles. Para isso, UML define um retângulo especial para representar pacotes, mostrado abaixo:</p>
<p><img src="figs/cap4/package0.svg" style="width:25.0%" /></p>
<p>Ao contrário dos retângulos de classes, o retângulo de pacotes inclui apenas o nome do pacote (em negrito). Ele possui ainda um detalhe na parte de cima, na forma de um trapézio, para melhor diferenciá-lo dos retângulos de classe.</p>
<p>A próxima figura mostra um exemplo de diagrama de pacotes:</p>
<p><img src="figs/cap4/package1.svg" style="width:50.0%" /></p>
<p>Nesse diagrama, podemos ver que o sistema possui quatro pacotes principais: <code>MobileView</code>, <code>WebView</code>, <code>BusinessLayer</code> e <code>Persistence</code>. Podemos ver ainda as dependências — setas tracejadas — que existem entre eles. Ambos os pacotes <code>View</code> usam classes de <code>BusinessLayer</code>. Por outro lado, as classes de <code>BusinessLayer</code> também usam classes da <code>View</code>, por exemplo, para notificá-las da ocorrência de algum evento. Por isso, as setas que ligam os pacotes de <code>View</code> a <code>BusinessLayer</code> são bidirecionais. Por fim, apenas classes do pacote <code>BusinessLayer</code> usam classes do pacote <code>Persistence</code>.</p>
<p>Para concluir, gostaríamos de acrescentar duas observações:</p>
<ul>
<li><p>Dependências não incluem informações sobre quantas classes do pacote de origem dependem de classes do pacote de destino. Por exemplo, suponha dois pacotes P1 e P2, ambos com 100 classes. Suponha ainda que uma única classe de P1 use uma única classe de P2. Mesmo nesse caso, dizemos que existe uma dependência de P1 para P2.</p></li>
<li><p>Em diagramas de pacotes, temos um único tipo de seta, sempre tracejada, que representa qualquer tipo de relacionamento, seja ele por meio de associação, herança ou dependência simples. Essa semântica é diferente daquela que apresentamos para setas tracejadas em diagramas de classes. Nesses últimos, relações de associação e herança são representadas por meio de setas contínuas. Apenas as demais dependências são representadas por meio de setas tracejadas.</p></li>
</ul>
<h2 data-number="1.5" id="diagramas-de-sequência" data-number="1.5"><span class="header-section-number">4.5</span> Diagramas de Sequência</h2>
<p> </p>
<p>Diagramas de sequência são diagramas dinâmicos, também chamados de comportamentais. Por isso, em vez de classes, eles modelam objetos de um sistema. Adicionalmente, eles incluem informações sobre quais métodos desses objetos são executados em um determinado cenário de uso de um programa. Logo, eles são usados quando se pretende explicar o comportamento de um sistema, em um determinado cenário. Por exemplo, no final desta seção, vamos apresentar um diagrama de sequência que ilustra os métodos que são chamados quando um cliente chega em um caixa eletrônico e solicita uma operação de retirada de valores.</p>
<p>Antes disso, para iniciar a apresentação de diagramas de sequência, vamos usar o seguinte diagrama:</p>
<p><img src="figs/cap4/sequence1.svg" style="width:45.0%" /></p>
<p>Apesar de simples, esse diagrama serve para mostrar a dinâmica e a notação usada por diagramas de sequência. Como já dissemos, diagramas de sequência modelam objetos, os quais são representados por meio de retângulos, com o nome dos objetos modelados. Esses retângulos ficam dispostos logo na primeira linha do diagrama. Portanto, dois objetos são representados no diagrama anterior, de nomes <code>a1</code> e <code>b1</code>. Abaixo de cada objeto, desenha-se uma linha vertical, a qual pode assumir duas formas: (1) quando ela é desenhada de forma tracejada, o objeto está inativo, isto é, nenhum de seus métodos está sendo executado; (2) quando a linha fica cheia, ganhando um formato retangular, um dos métodos do objeto foi chamado e encontra-se em execução. Quando essa execução termina, a linha volta a ficar tracejada. Além disso, o início da chamada é indicado por uma seta na horizontal, com o nome do método chamado. O retorno da chamada é indicado por uma seta tracejada, com o nome do objeto retornado. No entanto, às vezes a seta de retorno é omitida, como no caso da chamada do método <code>g</code>. Existem dois motivos para essa omissão: (1) o tipo de retorno é <code>void</code>; ou (2) o objeto de retorno não é relevante, a ponto de merecer ser representado no diagrama.</p>
<p>No diagrama de sequência mostrado acima representamos apenas dois objetos (<code>a1</code> e <code>b1</code>). Mas um diagrama de sequência pode ter mais objetos. No entanto, esse número não pode crescer tanto, pois o diagrama acaba ficando complexo e de difícil entendimento. Por exemplo, pode não ser possível representá-lo em uma única folha de papel ou em uma tela de computador.</p>
<p>Um objeto pode ficar ativo e inativo diversas vezes em um mesmo diagrama. Ou seja, ele pode executar um método; ficar inativo; executar um novo método; ficar inativo, etc. Existe ainda um caso especial, quando um objeto chama um método dele mesmo, isto é, quando ele chama um método usando this. Para ilustrar esse caso, suponha o seguinte programa.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">class</span> A {</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="dt">void</span> <span class="fu">g</span>() {</span>
<span id="cb5-4"><a href="#cb5-4"></a>    ...</span>
<span id="cb5-5"><a href="#cb5-5"></a>  }   </span>
<span id="cb5-6"><a href="#cb5-6"></a> </span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="dt">void</span> <span class="fu">f</span>() {</span>
<span id="cb5-8"><a href="#cb5-8"></a>    ...</span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="fu">g</span>();</span>
<span id="cb5-10"><a href="#cb5-10"></a>    ...</span>
<span id="cb5-11"><a href="#cb5-11"></a>  }</span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a>  <span class="fu">main</span>() {</span>
<span id="cb5-14"><a href="#cb5-14"></a>    A a = <span class="kw">new</span> <span class="fu">A</span>();</span>
<span id="cb5-15"><a href="#cb5-15"></a>    a.<span class="fu">f</span>();</span>
<span id="cb5-16"><a href="#cb5-16"></a>  }</span>
<span id="cb5-17"><a href="#cb5-17"></a>}</span></code></pre></div>
<p>A execução desse programa é representada pelo diagrama de sequência a seguir. Observe como a chamada de <code>g()</code> feita por <code>f()</code> é representada por meio de um novo retângulo, que <q>sai</q> do retângulo que representa a ativação de <code>f()</code>.</p>
<p><img src="figs/cap4/sequence2.svg" style="width:30.0%" /></p>
<p>Para concluir, o próximo diagrama mostra um cenário mais real, que ilustra os métodos chamados quando o cliente de uma caixa eletrônico solicita um depósito de certo valor em sua conta.</p>
<p><img src="figs/cap4/sequence3.svg" style="width:60.0%" /></p>
<h3 data-number="1.5.1" id="diagramas-de-atividades" data-number="1.5.1"><span class="header-section-number">4.5.1</span> Diagramas de Atividades</h3>
<p> </p>
<p>Diagramas de atividades são usados para representar, em alto nível, um processo ou fluxo de execução. Os principais elementos desses diagramas são <strong>ações</strong> representadas por quadrados. Existem ainda elementos de <strong>controle</strong>, que definem a ordem de execução das ações. A próxima figura mostra um diagrama de atividades que modela o processo seguido após um usuário fechar uma compra em uma loja virtual. Para isso, assume-se que os produtos comprados já estão no carrinho de compra.</p>
<p><img src="figs/cap4/activity01.svg" style="width:40.0%" /></p>
<p>Para entender o funcionamento de um diagrama de atividades (como aquele mostrado acima), devemos assumir que existe uma ficha (<em>token</em>) imaginária que caminha pelos nodos do diagrama. A seguir, explicamos o comportamento de cada nodo de um diagrama de atividades, assumindo a existência dessa ficha.</p>
<p><strong>Nodo Inicial:</strong> Cria uma ficha para dar início à execução do processo. Feito isso, repassa a ficha para seu único fluxo de saída. Por definição, o nodo inicial não possui fluxo de entrada.</p>
<p><img src="figs/cap4/activity-t-inicial.svg" /></p>
<p><strong>Ações:</strong> Possuem um único fluxo de entrada e um único fluxo de saída. Para uma ação ser executada uma ficha precisa chegar no seu fluxo de entrada. Após a execução, repassa-se a ficha para o fluxo de saída.</p>
<p><img src="figs/cap4/activity-t-acao.svg" /></p>
<p><strong>Decisões:</strong> Possuem um único fluxo de entrada e dois ou mais fluxos de saída. Cada fluxo de saída possui uma variável booleana associada, chamada de guarda. Para se tomar uma decisão, precisa-se receber uma ficha no fluxo de entrada. Quando isso acontece, a ficha é repassada apenas para o fluxo de saída cuja condição é verdadeira.</p>
<p><img src="figs/cap4/activity-t-decisao.svg" /></p>
<p><strong>Merges:</strong> Podem possuir vários fluxos de entrada, mas um único fluxo de saída. Quando uma ficha chega em um dos fluxos de entrada, fazem seu repasse para o fluxo de saída. São usados para unir os fluxos de nodos de decisão.</p>
<p><img src="figs/cap4/activity-t-merge.svg" /></p>
<p><strong>Forks:</strong> Possuem um único fluxo de entrada e um ou mais fluxos de saída. Atuam como multiplicadores de ficha: quando recebem uma ficha no fluxo de entrada, criam e repassam fichas idênticas em cada fluxo de saída. Como resultado, passam a existir múltiplos processos em execução de forma paralela.</p>
<p><img src="figs/cap4/activity-t-fork.svg" /></p>
<p><strong>Joins:</strong> Possuem vários fluxos de entrada, mas um único fluxo de saída. Atuam como sorvedouros de fichas: esperam que fichas cheguem em todos os fluxos de entrada. Quando isso acontece, repassam uma única ficha para o fluxo de saída. Logo, são usados para sincronizar processos. Em outras palavras, transformar vários fluxos de execução em um único fluxo.</p>
<p><img src="figs/cap4/activity-t-join.svg" /></p>
<p><strong>Nodo Final:</strong> Pode possuir mais de um fluxo de entrada; mas não possui fluxos de saída. Quando uma ficha chega em um dos fluxos de entrada, encerra-se a execução do diagrama de atividades.</p>
<p><img src="figs/cap4/activity-t-final.svg" /></p>
<p><strong>Aprofundamento</strong>: Existem pelo menos três outras alternativas para modelagem de fluxos e processos:</p>
<ul>
<li><p><strong>Fluxogramas,</strong>  os quais foram propostos tão logo se começou a desenvolver os primeiros programas para computadores modernos. Diagramas de atividades são parecidos com fluxogramas; porém, eles incluem suporte a concorrência, por meio de <em>forks</em> e <em>joins</em>. Por outro lado, fluxogramas modelam processos sequenciais.</p></li>
<li><p><strong>Redes de Petri</strong>  é uma notação gráfica, proposta pelo matemático alemão Carl Adam Petri, em 1962, para modelagem de sistemas concorrentes. Redes de Petri possuem uma representação gráfica e também usam fichas (<em>tokens</em>) para marcar o estado corrente do sistema. Elas têm ainda a vantagem de possuir uma definição mais formal, principalmente quando comparada com a definição de diagramas de sequência. Por outro lado, esses últimos tendem a oferecer uma notação mais simples e fácil de entender.</p></li>
<li><p><strong>BPMN</strong> (<em>Business Process Model and Notation</em>)  é um esforço mais recente, que teve início nos anos 2000, visando a proposição de uma notação gráfica mais amigável para modelagem de processos de negócio do que aquela oferecida por diagramas de atividades. Um dos objetivos é propiciar que analistas de negócio possam ler, interpretar e validar diagramas BPMN.</p></li>
</ul>
<h2 class="unnumbered" data-number="" id="bibliografia" class="unnumbered" data-number="">Bibliografia</h2>
<p>Martin Fowler. UML Distilled: A Brief Guide to the Standard Object Modeling Language. Addison-Wesley, 2003.</p>
<p>Grady Booch, James Rumbaugh, Ivar Jacobson. The Unified Modeling Language User Guide. Addison-Wesley, 2005.</p>
<p>Craig Larman. Applying UML and Patterns: An Introduction to Object-Oriented Analysis and Design and Iterative Development. Prentice Hall, 2004.</p>
<h2 class="unnumbered" data-number="" id="exercícios-de-fixação" class="unnumbered" data-number="">Exercícios de Fixação</h2>
<p>1. Explique e discuta os três usos possíveis de UML:</p>
<ol type="a">
<li>Como blueprint (ou plantas técnicas detalhadas)</li>
<li>Como sketches (esboços)</li>
<li>Como linguagem de programação.</li>
</ol>
<p>2. Descreva cenários de uso de diagramas de classes UML como instrumento de:</p>
<ol type="a">
<li>Engenharia Reversa</li>
<li>Engenharia Avante (<em>Forward Engineering</em>).</li>
</ol>
<p>3. Modele os cenários descritos a seguir usando Diagramas de Classe UML.Veja que as classes são grafadas em uma fonte diferente.</p>
<ol type="a">
<li><p><code>ContaBancaria</code> possui exatamente um <code>Cliente</code>. Um <code>Cliente</code>, por sua vez, pode ter várias <code>ContaBancaria</code>. Existe navegabilidade em ambos os sentidos.</p></li>
<li><p><code>ContaPoupanca</code> e <code>ContaSalario</code> são subclasses de <code>ContaBancaria</code>.</p></li>
<li><p>No código de <code>ContaBancaria</code> declara-se uma variável local do tipo <code>BancoDados</code>.</p></li>
<li><p>Um <code>ItemPedido</code> se refere a um único <code>Produto</code> (sem navegabilidade). Um <code>Produto</code> pode ter vários <code>ItemPedido</code> (com navegabilidade).</p></li>
<li><p>A classe <code>Aluno</code> possui atributos <code>nome</code>, <code>matricula</code>, <code>curso</code> (todos privados); e métodos <code>getCurso()</code> e <code>cancelaMatricula()</code>, ambos públicos.</p></li>
</ol>
<p>4. (ENADE 2014, Tec. e Análise de Sistemas) Construa um diagrama de classes para representar as seguintes classes e associações:</p>
<ul>
<li><p>Uma revista científica possui título, INSS e periodicidade;</p></li>
<li><p>Essa revista publica diversas edições com os seguintes atributos: número da edição, volume da edição e data da edição. Importante destacar que cada instância da classe edição relaciona-se única e exclusivamente a uma instância da classe revista científica, não podendo relacionar-se com nenhuma outra;</p></li>
<li><p>Um artigo possui título e nome do autor. Um artigo é um conteúdo exclusivo de uma edição. E uma edição obrigatoriamente tem que possuir no mínimo 10 e no máximo 15 artigos.</p></li>
</ul>
<p>5. Crie diagramas de classes para os seguintes trechos de código:</p>
<p>(a)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">public</span> <span class="kw">class</span> HelloWorldSwing { </span>
<span id="cb6-2"><a href="#cb6-2"></a>   <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
<span id="cb6-3"><a href="#cb6-3"></a>     <span class="bu">JFrame</span> frame = <span class="kw">new</span> <span class="bu">JFrame</span>(<span class="st">&quot;Hello world!&quot;</span>);</span>
<span id="cb6-4"><a href="#cb6-4"></a>     frame.<span class="fu">setVisible</span>(<span class="kw">true</span>);</span>
<span id="cb6-5"><a href="#cb6-5"></a>   }</span>
<span id="cb6-6"><a href="#cb6-6"></a>}</span></code></pre></div>
<p>(b)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">class</span> HelloWorldSwing <span class="kw">extends</span> <span class="bu">JFrame</span> {</span>
<span id="cb7-2"><a href="#cb7-2"></a>   <span class="kw">public</span> <span class="fu">HelloWorldSwing</span>() {</span>
<span id="cb7-3"><a href="#cb7-3"></a>     <span class="kw">super</span>(<span class="st">&quot;Hello world!&quot;</span>);</span>
<span id="cb7-4"><a href="#cb7-4"></a>   }</span>
<span id="cb7-5"><a href="#cb7-5"></a>   <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
<span id="cb7-6"><a href="#cb7-6"></a>     HelloWorldSwing frame = <span class="kw">new</span> <span class="fu">HelloWorldSwing</span>();</span>
<span id="cb7-7"><a href="#cb7-7"></a>     frame.<span class="fu">setVisible</span>(<span class="kw">true</span>);</span>
<span id="cb7-8"><a href="#cb7-8"></a>   }</span>
<span id="cb7-9"><a href="#cb7-9"></a>}</span></code></pre></div>
<p>6. Mostre o diagrama de sequência relativo ao seguinte código. O diagrama deve começar com a seguinte chamada <em>a</em>.<em>m5()</em>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1"></a>A a = <span class="kw">new</span> <span class="fu">A</span>(); <span class="co">// variáveis globais</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>B b = <span class="kw">new</span> <span class="fu">B</span>();</span>
<span id="cb8-3"><a href="#cb8-3"></a>C c = <span class="kw">new</span> <span class="fu">C</span>();</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">class</span> C { </span>
<span id="cb8-6"><a href="#cb8-6"></a>   <span class="dt">void</span> <span class="fu">m1</span>() { <span class="kw">... </span>} </span>
<span id="cb8-7"><a href="#cb8-7"></a>}</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">class</span> B { </span>
<span id="cb8-9"><a href="#cb8-9"></a>   <span class="dt">void</span> <span class="fu">m2</span>() { <span class="kw">... </span>c.<span class="fu">m1</span>(); <span class="kw">... this</span>.<span class="fu">m3</span>(); <span class="kw">... </span>}   </span>
<span id="cb8-10"><a href="#cb8-10"></a>   <span class="dt">void</span> <span class="fu">m3</span>() { <span class="kw">... </span>c.<span class="fu">m1</span>(); <span class="kw">... </span>}</span>
<span id="cb8-11"><a href="#cb8-11"></a>   <span class="dt">void</span> <span class="fu">m4</span>() { <span class="kw">... </span>}</span>
<span id="cb8-12"><a href="#cb8-12"></a>}</span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">class</span> A { </span>
<span id="cb8-14"><a href="#cb8-14"></a>   <span class="dt">void</span> <span class="fu">m5</span>() { <span class="kw">... </span>b.<span class="fu">m2</span>(); <span class="kw">... </span>b.<span class="fu">m3</span>(); <span class="kw">... </span>b.<span class="fu">m4</span>(); <span class="kw">...  </span>}   </span>
<span id="cb8-15"><a href="#cb8-15"></a>}     </span></code></pre></div>
<p>7. Em diagramas de atividades, explique a diferença entre um nodo de <em>merge</em> e um nodo de <em>join</em>.</p>
<p>8. Qual é o erro do seguinte diagrama de atividades? Refaça o diagrama de forma a refletir corretamente a intenção do projetista.</p>
<p><img src="figs/cap4/activity-exercicio.svg" style="width:35.0%" /></p>
</div>
</div>
</div>

<footer>
ASERG/DCC/UFMG. Direitos autorais reservados. Versão para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formulário</a>.
</footer>
</body>
</html>
