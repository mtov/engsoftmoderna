<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 4: Modelos ‚Äì Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: 1;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">
<img src="https://engsoftmoderna.info/figs/capa/capa-3d.jpg"></a>
</p>

<p>
<a href="https://engsoftmoderna.info">P√°gina principal do livro</a>
</p>

<p>Compre na

<a href="https://www.amazon.com.br/gp/product/6500019504">Amazon</a>, 

<a href="https://www.submarino.com.br/produto/1768283036/engenharia-de-software-moderna">
      Submarino</a> ou 

<a href="https://loja.umlivro.com.br/engenharia-de-software-moderna-4778188/p">
      UmLivro</a>
</p>

<p>
Veja tamb√©m os cursos de extens√£o a dist√¢ncia 
<a href="http://www.engsoftmoderna.dcc.ufmg.br">Engenharia de Software Moderna</a> (48 horas) e
<a href="http://www.testesoft.dcc.ufmg.br">Teste de Software</a> (20 horas), oferecidos pelo DCC/ICEX/UFMG.</p>

<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="4" id="modelos"><span
class="header-section-number">4</span> Modelos <a href="#modelos"
class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>All models are wrong, but some models are useful. So the question
you need to ask is not <q>Is the model true?</q> (it never is) but <q>Is
the model good enough for this particular application?</q></em> ‚Äì George
Box</p>
</blockquote>
<p>Este cap√≠tulo inicia com uma apresenta√ß√£o gen√©rica sobre modelos de
software (Se√ß√£o 4.1). Em seguida, apresentamos uma vis√£o geral sobre
UML, que √© a nota√ß√£o gr√°fica mais utilizada para constru√ß√£o de modelos
de software (Se√ß√£o 4.2). Tamb√©m deixamos claro que vamos estudar UML
visando a cria√ß√£o de esbo√ßos de software (<em>sketches</em>) e n√£o
desenhos t√©cnicos detalhados (<em>blueprints</em>). Nas se√ß√µes
seguintes, apresentamos quatro diagramas UML com um maior n√≠vel de
detalhes: Diagramas de Classes (Se√ß√£o 4.3), Diagramas de Pacotes (Se√ß√£o
4.4), Diagramas de Sequ√™ncia (Se√ß√£o 4.5) e Diagramas de Atividades
(Se√ß√£o 4.6).</p>
<h2 data-number="4.1" id="modelos-de-software"><span
class="header-section-number">4.1</span> Modelos de Software <a
href="#modelos-de-software" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p>Como vimos no cap√≠tulo anterior, requisitos documentam <q>o que</q>
um sistema deve fazer, valendo-se de um n√≠vel de abstra√ß√£o pr√≥ximo do
problema e de seus usu√°rios. Por outro lado, o c√≥digo fonte √© uma
representa√ß√£o concreta, de baixo n√≠vel e execut√°vel do comportamento de
um sistema. Portanto, existe uma lacuna entre esses dois mundos:
requisitos e c√≥digo fonte. Para preencher essa lacuna, desde a funda√ß√£o
da √°rea, Engenheiros de Software investem na cria√ß√£o de
<strong>modelos</strong>, os quais s√£o criados para ajudar no
entendimento e an√°lise de um sistema. Para cumprir essa miss√£o, os
modelos usados em Engenharia de Software s√£o mais detalhados do que
requisitos, mas ainda menos complexos do que o c√≥digo fonte de um
sistema.</p>
<p>Modelos s√£o largamente usados tamb√©m em outras engenharias. Por
exemplo, uma engenheira civil pode decidir criar uma maquete para
mostrar como ser√° a ponte que ela foi contratada para construir. Em
seguida, ela pode criar um modelo matem√°tico e f√≠sico da ponte e us√°-lo
para simular e provar propriedades da mesma, tais como carga m√°xima,
resist√™ncia a ventos, ondas, terremotos, etc.</p>
<p>Infelizmente, modelos de software ‚Äî pelo menos at√© hoje ‚Äî s√£o menos
efetivos do que os modelos matem√°ticos usados em outras engenharias. O
motivo √© que ao abstrair detalhes eles tamb√©m descartam parte da
complexidade que √© essencial aos sistemas modelados. Frederick Brooks
comenta sobre essa quest√£o em seu ensaio cl√°ssico <em>N√£o Existe Bala de
Prata</em> (<a
href="https://doi.org/10.1109/MC.1987.1663532">link</a>):</p>
<blockquote>
<p><q>A complexidade de um software √© uma propriedade essencial e n√£o
acidental. Portanto, representa√ß√µes de uma entidade de software que
abstraem sua complexidade normalmente tamb√©m abstraem sua ess√™ncia. Por
tr√™s s√©culos, matem√°ticos e f√≠sicos obtiveram grandes avan√ßos
construindo modelos simplificados de um fen√¥meno complexo, derivando
propriedades de tais modelos e verificando tais propriedade por meio de
experimentos. Esse paradigma funcionou porque as complexidades ignoradas
n√£o s√£o propriedades essenciais do fen√¥meno sob estudo. Por√©m, essa
abordagem n√£o funciona quando as complexidades s√£o essenciais.</q></p>
</blockquote>
<p> A frase que abre esse cap√≠tulo, do estat√≠stico brit√¢nico George Box,
tamb√©m remete a uma reflex√£o sobre o uso pr√°tico de modelos. Apesar de a
frase se referir a modelos matem√°ticos, ela se aplica a outros modelos,
inclusive modelos de software. Segundo Box, todos os modelos s√£o
<q>errados</q>, pois s√£o simplifica√ß√µes ou aproxima√ß√µes da realidade.
Por isso, a quest√£o principal consiste em avaliar se, apesar dessas
simplifica√ß√µes, um modelo continua sendo uma abstra√ß√£o √∫til para o
estudo de alguma propriedade do objeto ou fen√¥meno que ele modela.</p>
<p>Nesta introdu√ß√£o, estamos procurando calibrar as expectativas
associadas ao estudo de modelos de software. Por um lado, como
afirmamos, eles n√£o t√™m a mesma efetividade de modelos em outras
Engenharias. Al√©m disso, via de regra, modelos de software n√£o s√£o
formalismos matem√°ticos, mas sim representa√ß√µes gr√°ficas de determinadas
dimens√µes de um sistema de software. Por outro lado, isso n√£o significa
dizer que modelos de software s√£o in√∫teis, a ponto de n√£o merecer um
cap√≠tulo em um livro sobre pr√°ticas de Engenharia de Software Moderna.
Se n√£o criarmos expectativas irrealistas, eles podem ter um papel
importante no desenvolvimento de sistemas de software, tal como veremos
na pr√≥xima se√ß√£o.</p>
<p>Se pensarmos em termos de atividades de desenvolvimento de software,
a cria√ß√£o de modelos √© considerada uma atividade de projeto
(<em>design</em>). Durante o levantamento de requisitos, as aten√ß√µes
est√£o voltadas para a defini√ß√£o do problema que ser√° resolvido pelo
sistema. Quando se avan√ßa para atividades de projeto, o problema j√° deve
estar devidamente entendido e as aten√ß√µes se voltam para a concep√ß√£o de
uma solu√ß√£o capaz de resolv√™-lo. Ap√≥s essa solu√ß√£o ser projetada, ela
deve ser implementada, usando-se linguagens de programa√ß√£o, bibliotecas,
frameworks, bancos de dados, etc.</p>
<p>Especificamente, neste cap√≠tulo, iremos estudar um subconjunto dos
diagramas propostos pela UML (<em>Unified Modelling Language</em>).
Vamos come√ßar descrevendo a hist√≥ria e o contexto que levou √† cria√ß√£o da
UML. Em seguida, vamos estudar alguns dos principais diagramas UML com
mais detalhes.</p>
<p></p>
<p><strong>Aprofundamento</strong>: Desde a d√©cada de 70, pesquisadores
t√™m investigado o uso de modelos matem√°ticos em Engenharia de Software,
por meio do que se chama de <strong>M√©todos Formais</strong>. Esses
m√©todos valem-se de uma nota√ß√£o matem√°tica ‚Äî baseada em l√≥gica, teoria
de conjuntos ou Redes de Petri, por exemplo ‚Äî para derivar
<strong>especifica√ß√µes formais</strong> para sistemas de software. Al√©m
de serem precisas e n√£o-amb√≠guas, especifica√ß√µes formais podem ser
usadas para provar propriedades de um sistema mesmo antes de sua
implementa√ß√£o. Por exemplo, em tese, poderia-se provar que um sistema
concorrente n√£o possui deadlocks ou condi√ß√µes de corrida. Pode parecer
ambicioso, mas isso ocorre em outras Engenharias. Retomando o exemplo do
in√≠cio da se√ß√£o, engenheiros civis usam h√° s√©culos modelos matem√°ticos
para provar, por exemplo, que uma ponte ‚Äî antes de ser constru√≠da ‚Äî vai
suportar determinada carga e certas condi√ß√µes clim√°ticas. No entanto, o
uso de formalismos e especifica√ß√µes matem√°ticas em Engenharia de
Software n√£o avan√ßou como em outras Engenharias. Por isso, eles s√£o
pouco usados atualmente, com exce√ß√£o talvez de alguns sistemas de miss√£o
cr√≠tica.</p>
<h2 data-number="4.2" id="uml"><span
class="header-section-number">4.2</span> UML <a href="#uml"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p></p>
<p>UML √© uma nota√ß√£o gr√°fica para modelagem de software. A linguagem
define um conjunto de diagramas para documentar e ajudar no design de
sistemas de software, particularmente sistemas orientados a objetos. As
origens de UML datam da d√©cada de 80, quando o paradigma de orienta√ß√£o a
objetos estava amadurecendo e vivendo seu auge. Assim, surgiram diversas
linguagens orientadas a objetos, como C++, e tamb√©m algumas nota√ß√µes
gr√°ficas para modelagem de software. Lembre-se que os sistemas na d√©cada
de 80 eram desenvolvidos segundo o Modelo Waterfall, que prescreve uma
grande e longa fase de design. A proposta de UML era que nessa fase
seriam criados modelos gr√°ficos, que depois seriam repassados para os
programadores, para serem convertidos em c√≥digo fonte.</p>
<p> Na verdade, UML √© o resultado de um esfor√ßo para unificar as
nota√ß√µes gr√°ficas que surgiram no final das d√©cadas de 80 e in√≠cio da
d√©cada de 90. Especificamente, a primeira vers√£o de UML foi proposta em
1995, como resultado da unifica√ß√£o de nota√ß√µes que estavam sendo
desenvolvidas de forma independente por tr√™s Engenheiros de Software
conhecidos na √©poca: Grady Booch, Jim Rumbaugh e Ivar Jacobson. Nessa
√©poca, surgiram tamb√©m ferramentas para desenhar diagramas UML, as quais
foram chamadas de <strong>ferramentas CASE</strong> (<em>Computer-Aided
Software Engineering</em>). O nome √© inspirado em ferramentas CAD
(<em>Computer Aided Design</em>), usadas para criar modelos para
produtos de Engenharia tradicional, como casas, pontes, autom√≥veis,
avi√µes, etc. Por isso, era importante ter uma padroniza√ß√£o de UML, de
forma que um diagrama criado em uma ferramenta CASE pudesse ser aberto e
editado em uma outra ferramenta, de uma empresa diferente. De fato, em
1997, UML passou a ser um padr√£o gerenciado pela OMG, que √© uma
organiza√ß√£o de padroniza√ß√£o financiada por ind√∫strias de software. Desde
o in√≠cio, o desenvolvimento de UML foi comandado por consultores
influentes e por grandes empresas de ferramentas ou consultoria, como a
Rational, que depois viria a ser comprada pela IBM.</p>
<h3 class="unnumbered" id="como-usar-uml">Como usar UML? <a
href="#como-usar-uml" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> Martin Fowler, em seu livro sobre UML (<a
href="https://dl.acm.org/citation.cfm?id=861282">link</a>), prop√µe uma
classifica√ß√£o sobre formas de uso dessa linguagem de modelagem. Segundo
ele, existem tr√™s formas de uso de UML: como blueprint, como linguagem
de programa√ß√£o ou como esbo√ßo. Vamos descrever cada uma delas nos
pr√≥ximos par√°grafos.</p>
<p> <strong>UML como blueprint</strong> corresponde ao uso de UML
vislumbrado por seus criadores, ainda na d√©cada de 90. Nessa forma de
uso, defende-se que, ap√≥s o levantamento de requisitos, seja produzido
um conjunto de modelos ‚Äî ou plantas t√©cnicas (<em>blueprints</em>) ‚Äî
documentando diversos aspectos de um sistema e sempre usando diagramas
UML. Esses modelos seriam criados por analistas de sistemas, usando-se
ferramentas CASE e, depois, repassados a programadores para codifica√ß√£o.
Logo, UML como <em>blueprint</em> √© recomendado quando se emprega
processos de desenvolvimento do tipo Waterfall ou quando se adota o
Processo Unificado (UP). Na verdade, UP foi proposto por pessoas com
forte liga√ß√£o com UML. No entanto, como j√° discutimos no Cap√≠tulo 2, o
uso de UML na constru√ß√£o de modelos detalhados e completos √© cada vez
mais raro. Por exemplo, com m√©todos √°geis n√£o existe uma longa fase
inicial de design (<em>big design up front</em>). Em vez disso, decis√µes
de design s√£o tomadas e refinadas ao longo do desenvolvimento, em cada
uma das itera√ß√µes (ou <em>sprints</em>). Por isso, n√£o iremos neste
cap√≠tulo nos aprofundar no uso de UML como <em>blueprint</em>.</p>
<p> <strong>UML como linguagem de programa√ß√£o</strong> corresponde ao
uso de UML vislumbrado pela OMG, ap√≥s a padroniza√ß√£o da linguagem de
modelagem. De forma ambiciosa e pelo menos durante um per√≠odo,
vislumbrou-se a gera√ß√£o de c√≥digo automaticamente a partir de modelos
UML. Em outras palavras, n√£o haveria mais uma fase de codifica√ß√£o, pois
o c√≥digo seria gerado diretamente a partir da <q>compila√ß√£o</q> de
modelos UML. Essa forma de uso √© conhecida como <strong>Desenvolvimento
Dirigido por Modelos</strong> (<em>Model Driven Development ou
MDD</em>). Para que MDD fosse vi√°vel, UML foi expandida e ganhou novos
recursos e diagramas. Foi a partir desse momento que a linguagem ganhou
a reputa√ß√£o de ser pesada e complexa. Por√©m, mesmo com adi√ß√£o de
complexidade extra, o uso de UML para gera√ß√£o de c√≥digo n√£o se tornou
comum, pelo menos na grande maioria dos sistemas.</p>
<p> Resta ent√£o o terceiro uso, <strong>UML como esbo√ßo</strong>, que
corresponde √† forma que vamos estudar neste cap√≠tulo. Nela, usamos UML
para construir diagramas leves e informais de partes de um sistema,
vindo da√≠ o nome esbo√ßo (<em>sketch</em>). Esses diagramas s√£o usados
para comunica√ß√£o entre os desenvolvedores, em duas situa√ß√µes
principais:</p>
<ul>
<li><p><strong>Engenharia Avante</strong> (<em>Forward
Engineering</em>): quando os desenvolvedores usam modelos UML para
discutir e analisar alternativas de design, antes que exista qualquer
c√≥digo. Por exemplo, suponha que uma hist√≥ria tenha sido alocada para o
sprint corrente. Antes de implementar a hist√≥ria, os desenvolvedores
podem se reunir e fazer um esbo√ßo das principais classes que dever√£o ser
criadas no sistema, bem como dos relacionamentos entre elas. O objetivo
√© validar a proposta de tais classes antes de come√ßar a
codificar.</p></li>
<li><p><strong>Engenharia Reversa</strong> (<em>Reverse
Engineering</em>): quando os desenvolvedores usam modelos UML para
analisar e discutir uma funcionalidade que j√° se encontra implementada
no c√≥digo fonte. Por exemplo, um desenvolvedor mais experiente pode
desenhar alguns diagramas UML para explicar para um desenvolvedor
rec√©m-contratado como uma funcionalidade est√° implementada. Normalmente,
√© mais f√°cil conduzir essa explica√ß√£o usando modelos e diagramas
gr√°ficos do que analisar e explicar cada linha de c√≥digo. Ou seja,
aplica-se aqui o ditado segundo o qual <q>uma figura vale mais do que
mil palavras</q>.</p></li>
</ul>
<p>Nas duas situa√ß√µes, o objetivo n√£o √© gerar modelos completos e
detalhados. Por isso, n√£o se considera o uso de ferramentas complexas e
caras, como ferramentas CASE. Muito menos se cogita a gera√ß√£o autom√°tica
de c√≥digo a partir desses esbo√ßos. Muitas vezes, os diagramas s√£o
desenhados em um quadro e, depois, fotografados e apagados.
Adicionalmente, usa-se apenas um subconjunto dos diagramas UML.</p>
<p>Como os esbo√ßos s√£o pequenos e informais, pode-se questionar a
necessidade de uma linguagem padronizada nos cen√°rios que mencionamos.
No entanto, consideramos que √© melhor usar uma nota√ß√£o existente h√°
anos, mesmo que de forma parcial, do que inventar uma nota√ß√£o pr√≥pria.
Especificamente, o emprego de UML como esbo√ßo contribui para evitar dois
extremos. Por um lado, ele n√£o assume o emprego r√≠gido, detalhado e
sistem√°tico de UML. Por outro lado, evita-se o uso de uma nota√ß√£o
informal e <em>ad hoc</em>, cuja sem√¢ntica pode n√£o ser clara para todos
os desenvolvedores. Al√©m disso, UML costuma ser usada em livros,
tutoriais e documentos que explicam o uso de frameworks ou t√©cnicas de
programa√ß√£o. Por exemplo, no Cap√≠tulo 6, usaremos diagramas UML para
ilustrar o funcionamento de alguns padr√µes de projeto. Caso o leitor n√£o
tenha tido contato com UML, pode ser que ele tenha dificuldade para
entender o conceito que est√° sendo explicado.</p>
<p>Sintetizando a descri√ß√£o que acabamos de fazer, modelos de software,
como diagramas UML, s√£o usados para comunica√ß√£o entre desenvolvedores.
Ou seja, eles s√£o escritos por e para desenvolvedores. Trata-se de uma
diferen√ßa importante para documentos de requisitos, que, conforme vimos
no cap√≠tulo anterior, s√£o escritos por desenvolvedores, mas de forma que
eles possam ser lidos e verificados pelos usu√°rios finais do
sistema.</p>
<p><strong>Mundo Real</strong>: No segundo semestre de 2013, Sebastian
Baltes e Stephan Diehl ‚Äî ambos pesquisadores da Universidade de Trier,
na Alemanha ‚Äî pediram 394 desenvolvedores para responder um question√°rio
sobre o emprego de esbo√ßos (<em>sketches</em>) em atividades de projeto
de software (<a href="https://arxiv.org/abs/1706.09172">link</a>). Esses
desenvolvedores estavam distribu√≠dos por mais de 32 pa√≠ses, embora a
maioria fosse da Alemanha (54%). A an√°lise das respostas obtidas revelou
resultados interessantes sobre o uso de esbo√ßos em atividades de projeto
e desenvolvimento de software, conforme descrito a seguir:</p>
<ul>
<li><p>24% dos desenvolvedores que participaram da pesquisa criaram o
√∫ltimo esbo√ßo no mesmo dia em que responderam ao question√°rio e 39% no
intervalo de tempo m√°ximo de uma semana, antes da resposta. Portanto,
esses percentuais indicam que esbo√ßos s√£o criados com frequ√™ncia por
desenvolvedores de software.</p></li>
<li><p>58% dos √∫ltimos esbo√ßos criados pelos participantes foram depois
arquivados, seja em papel (6%), digitalmente (42%) ou de ambas as formas
(10%). Isso sugere que os desenvolvedores consideram que os esbo√ßos
carregam informa√ß√£o importante, que talvez seja √∫til no futuro.</p></li>
<li><p>40% dos esbo√ßos foram feitos em papel, 18% em quadros e 39% em
computadores.</p></li>
<li><p>52% dos esbo√ßos foram feitos para ajudar no projeto
(<em>design</em>) da arquitetura do sistema, 48% para ajudar no projeto
de novas funcionalidades, 46% para explicar alguma tarefa para um outro
desenvolvedor, 45% para analisar requisitos e 44% para ajudar no
entendimento de uma tarefa. A soma dos percentuais ultrapassa 100%
porque os participantes podiam marcar mais de uma resposta.</p></li>
<li><p>48% dos esbo√ßos continham algum elemento de UML e 9% eram
integralmente baseados em diagramas UML. Portanto, esses percentuais
refor√ßam a import√¢ncia de estudar UML, n√£o como nota√ß√£o para
documenta√ß√£o detalhada de sistemas (<em>blueprints</em>), mas para
ajudar na constru√ß√£o de modelos informais e parciais.</p></li>
</ul>
<h3 class="unnumbered" id="diagramas-uml">Diagramas UML <a
href="#diagramas-uml" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Os diagramas UML s√£o classificados em dois grandes grupos:</p>
<ul>
<li><p><strong>Diagramas Est√°ticos (ou Estruturais)</strong> modelam a
estrutura e organiza√ß√£o de um sistema, incluindo informa√ß√µes sobre
classes, atributos, m√©todos, pacotes, etc. Neste cap√≠tulo, vamos estudar
dois diagramas est√°ticos: Diagramas de Classes e Diagramas de
Pacotes.</p></li>
<li><p><strong>Diagramas Din√¢micos (ou Comportamentais)</strong> modelam
eventos que ocorrem durante a execu√ß√£o de um sistema. Por exemplo, eles
podem modelar uma sequ√™ncia de chamadas de m√©todos. Neste cap√≠tulo,
vamos estudar dois diagramas din√¢micos: Diagramas de Sequ√™ncia e
Diagramas de Atividades.</p></li>
</ul>
<p>Para entender melhor a diferen√ßa entre esses grupos de diagramas,
diagramas est√°ticos lidam apenas com informa√ß√µes que est√£o dispon√≠veis,
por exemplo, quando da compila√ß√£o do c√≥digo resultante dos modelos. Essa
vis√£o √© est√°tica porque ela n√£o muda, a n√£o ser que sejam realizadas
mudan√ßas nos modelos. J√° os diagramas din√¢micos fornecem uma vis√£o de
tempo de execu√ß√£o. Eles s√£o din√¢micos porque √© comum ter execu√ß√µes
diferentes de um mesmo programa. Por exemplo, os usu√°rios podem executar
o programa com entradas diferentes, selecionar op√ß√µes e menus
diferentes, etc. Em resumo, se estiver interessado em modelar a
estrutura de um programa, voc√™ deve usar diagramas est√°ticos. Se seu
interesse for modelar o comportamento de um programa ‚Äî isto √©, o que
pode acontecer durante sua execu√ß√£o, quais m√©todos s√£o de fato
executados, etc. ‚Äî voc√™ deve usar algum diagrama din√¢mico da UML. Por
fim, gostar√≠amos de lembrar que tratamos de Diagramas de Casos de Uso no
Cap√≠tulo 3, quando apresentamos t√©cnicas para especifica√ß√£o de
requisitos.</p>
<p> <strong>Aviso:</strong> Existem diversas vers√µes de UML. No restante
deste cap√≠tulo vamos usar a <strong>vers√£o de UML que √© adotada na 3a
edi√ß√£o do livro UML Distilled, de Martin Fowler</strong> (<a
href="https://dl.acm.org/citation.cfm?id=861282">link</a>). Esse livro
foi o primeiro trabalho a discutir o uso de UML como esbo√ßo
(<em>sketches</em>). Na verdade, vamos estudar um pequeno subconjunto da
vers√£o 2.0. Al√©m de tratar de apenas quatro diagramas, n√£o vamos cobrir
todos os recursos de cada um deles. O nosso desafio ao escrever este
cap√≠tulo foi selecionar os 20% (ou menos) dos recursos de UML que s√£o
respons√°veis por 80% (ou mais) de seu uso pr√°tico nos dias de hoje. Para
se ter uma ideia do n√≠vel de detalhe alcan√ßado por UML, a especifica√ß√£o
da vers√£o mais recente da linguagem ‚Äî vers√£o 2.5.1, no momento da
escrita deste cap√≠tulo ‚Äî possui 796 p√°ginas. Ela pode ser encontrada no
site da OMG (<a href="https://www.omg.org/">link</a>).</p>
<h2 data-number="4.3" id="diagrama-de-classes"><span
class="header-section-number">4.3</span> Diagrama de Classes <a
href="#diagrama-de-classes" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Diagramas de classes s√£o os diagramas mais usados da UML. Eles
oferecem uma representa√ß√£o gr√°fica para um conjunto de classes, provendo
informa√ß√µes sobre atributos, m√©todos e relacionamentos que existem entre
as classes modeladas.</p>
<p>Um diagrama de classes √© desenhado usando-se ret√¢ngulos e setas. Cada
uma das classes √© representada por meio de um ret√¢ngulo com tr√™s
compartimentos, conforme mostra a figura a seguir. Esses compartimentos
cont√™m o nome da classe (normalmente, em negrito), seus atributos e
m√©todos, como tamb√©m ilustrado a seguir:</p>
<p><img src="figs/cap4/class0.svg" style="width:28.0%" /></p>
<p>Mostra-se a seguir um diagrama com duas classes: <code>Pessoa</code>
e <code>Fone</code>.</p>
<p><img src="figs/cap4/class1.svg" style="width:90.0%" /></p>
<p>Nesse diagrama, pode-se conferir que a classe <code>Pessoa</code> tem
tr√™s atributos ‚Äî <code>nome</code>, <code>sobrenome</code> e
<code>fone</code> ‚Äî e dois m√©todos ‚Äî <code>setPessoa</code> e
<code>getPessoa</code>. Os tr√™s atributos s√£o privados, conforme
indicado pelo sinal <q>-</q> antes de cada um. Informa-se tamb√©m o tipo
de cada atributo. Por sua vez, os dois m√©todos s√£o p√∫blicos, conforme
indicado pelo sinal <q>+</q>. O diagrama possui ainda uma segunda
classe, chamada <code>Fone</code>, com tr√™s atributos privados ‚Äî
<code>codigo</code>, <code>numero</code> e <code>celular</code> ‚Äî e tr√™s
m√©todos p√∫blicos ‚Äî <code>setFone</code>, <code>getFone</code> e
<code>isCelular</code>. No caso dos m√©todos, informamos tamb√©m o nome de
seus par√¢metros e o tipo de retorno.</p>
<p>Por√©m, se fosse somente isso, os diagramas dariam a impress√£o de que
as classes de um sistema s√£o <q>ilhas</q> sem comunica√ß√£o entre si. No
entanto, um dos principais objetivos de diagramas de classe √© mostrar
visualmente os relacionamentos que existem entre as classes de um
sistema. Por isso, eles incluem tamb√©m linhas e setas, as quais s√£o
usadas para representar tr√™s tipos de relacionamentos:
<strong>associa√ß√£o</strong>, <strong>heran√ßa</strong> e
<strong>depend√™ncia</strong>. Vamos tratar de cada um deles nos pr√≥ximos
par√°grafos.</p>
<h3 data-number="4.3.1" id="associa√ß√µes"><span
class="header-section-number">4.3.1</span> Associa√ß√µes <a
href="#associa√ß√µes" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>Quando uma classe A possui um atributo <code>b</code> de um tipo B,
dizemos que existe uma associa√ß√£o de A para B, a qual √© representada por
meio de uma seta, tamb√©m de A para B. Na extremidade da seta, informa-se
o nome do atributo de A respons√°vel pela associa√ß√£o ‚Äî no nosso caso,
<code>b</code>. Veja o exemplo abaixo (nele, s√≥ mostramos as informa√ß√µes
que nos interessam; por isso, o compartimento de atributos e m√©todos
est√° vazio):</p>
<p><img src="figs/cap4/class2.svg" style="width:40.0%" /></p>
<p>Para ficar ainda mais claro, vamos mostrar como seria o c√≥digo das
classes A e B:</p>
<pre><code>class A {
   ...
   private B b;
   ...
}


class B {
   ...
}</code></pre>
<p>Portanto, usando associa√ß√µes, podemos transformar o primeiro diagrama
que mostramos nesta se√ß√£o, com as classes <code>Pessoa</code> e
<code>Fone</code>, no seguinte diagrama:</p>
<p><img src="figs/cap4/class3.svg" style="width:90.0%" /></p>
<p>As duas vers√µes do diagrama s√£o semanticamente id√™nticas. A diferen√ßa
√© que na primeira vers√£o as classes aparecem <q>ilhadas</q>. J√° na
segunda vers√£o, mostrada acima, fica visualmente claro que existe uma
associa√ß√£o de <code>Pessoa</code> para <code>Fone</code>. Refor√ßando, em
ambos diagramas, <code>Pessoa</code> tem um atributo fone do tipo
<code>Fone</code>. Por√©m, na primeira vers√£o, esse atributo √© mostrado
dentro do compartimento de atributos da classe <code>Pessoa</code>. J√°
na segunda vers√£o, ele √© apresentado <q>fora</q> desse compartimento.
Mais especificamente, na extremidade da seta que liga
<code>Pessoa</code> a <code>Fone</code>. O objetivo √© deixar claro que o
atributo pertence a <code>Pessoa</code>, mas ele <q>aponta</q> para um
objeto do tipo <code>Fone</code>.</p>
<p> Frequentemente, associa√ß√µes incluem informa√ß√µes de
<strong>multiplicidade</strong>, que indicam quantos objetos podem estar
associados ao atributo respons√°vel pela associa√ß√£o. As informa√ß√µes de
multiplicidade mais comuns s√£o as seguintes: 1 (exatamente um objeto),
0..1 (zero ou um objeto) e * (zero ou mais objetos).</p>
<p>No pr√≥ximo exemplo, inclu√≠mos informa√ß√£o sobre a multiplicidade da
associa√ß√£o entre <code>Pessoa</code> e <code>Fone</code>, que no caso
definimos como sendo 0..1. Essa informa√ß√£o consta acima do nome do
atributo respons√°vel pela associa√ß√£o, no caso, fone. E ela explicita que
uma <code>Pessoa</code> pode ter zero ou um √∫nico telefone. Usando
termos de programa√ß√£o, o atributo fone de <code>Pessoa</code> pode ter o
valor null, isto √©, a <code>Pessoa</code> em quest√£o n√£o tem
<code>Fone</code> associado. Ou ent√£o ela pode se associar a um √∫nico
objeto do tipo <code>Fone</code>.</p>
<p><img src="figs/cap4/class4.svg" style="width:85.0%" /></p>
<p>No pr√≥ximo exemplo, a sem√¢ntica j√° √© diferente. Nesse caso, uma
<code>Pessoa</code> pode estar associada a m√∫ltiplos objetos do tipo
<code>Fone</code>, inclusive a nenhum. Essa multiplicidade √©
representada pelo * que adicionamos logo acima da seta da
associa√ß√£o.</p>
<p><img src="figs/cap4/class5.svg" style="width:90.0%" /></p>
<p>Neste segundo exemplo com informa√ß√µes de multiplicidade, o tipo do
atributo <code>fone</code> deve ser um vetor de <code>Fone</code>. Para
que fique claro, mostramos o c√≥digo das classes a seguir:</p>
<pre><code>class Pessoa {
   private Fone[] fone;
   ...
}
class Fone {
   ...
}
</code></pre>
<p>Talvez o leitor possa se perguntar o que √© mais correto: uma
<code>Pessoa</code> ter no m√°ximo um <code>Fone</code> (isto √©, 0..1) ou
uma <code>Pessoa</code> ter qualquer quantidade de <code>Fone</code>
(isto √©, *)? A resposta √© simples: depende dos requisitos do sistema. Ou
seja, quem deve responder a essa pergunta s√£o os usu√°rios do sistema que
estamos modelando. Para n√≥s, o que importa √© que diagramas de classe s√£o
capazes de modelar qualquer um dos dois cen√°rios.</p>
<p>Em alguns casos, informa√ß√µes de multiplicidade s√£o tamb√©m mostradas
na extremidade contr√°ria da seta, como no exemplo abaixo:</p>
<p><img src="figs/cap4/class6.svg" style="width:90.0%" /></p>
<p>Nesse diagrama, a multiplicidade 0..1 ‚Äî da extremidade com a seta ‚Äî
indica que uma <code>Pessoa</code> pode ter zero ou um √∫nico
<code>Fone</code>. Mas o mais importante √© explicar a multiplicidade que
foi adicionada na extremidade oposta da seta, isto √©, a multiplicidade
*. Ela indica que um <code>Fone</code> pode estar associado a mais de
uma <code>Pessoa</code>. Em outras palavras, duas pessoas, distintas,
podem compartilhar o mesmo objeto do tipo <code>Fone</code>. No entanto,
a associa√ß√£o continua sendo unidirecional, isto √©, <code>Pessoa</code>
tem um atributo fone que representa o seu <code>Fone</code>. Por√©m,
<code>Fone</code> n√£o possui um atributo para armazenar as diversas
pessoas a que ele pode estar associado. Tentando ser mais claro, dada
uma <code>Pessoa</code> pode-se recuperar o seu <code>Fone</code>. Para
isso, basta acessar o atributo fone. Mas dado um <code>Fone</code> n√£o √©
poss√≠vel saber, pelo menos via atributos, a quais objetos do tipo
<code>Pessoa</code> ele est√° associado.</p>
<p>Para concluir, suponha que seja importante <q>navegar</q> nos dois
sentidos da associa√ß√£o, isto √©, de <code>Pessoa</code> para
<code>Fone</code> e tamb√©m de <code>Fone</code> para
<code>Pessoa</code>. A solu√ß√£o para essa exig√™ncia √© simples: basta
tornar a <strong>associa√ß√£o bidirecional</strong>, isto √©, adicionar uma
seta em cada extremidade da linha que conecta as classes, como mostrado
no pr√≥ximo diagrama.</p>
<p><img src="figs/cap4/class7.svg" style="width:90.0%" /></p>
<p>Para n√£o deixar d√∫vidas sobre a sem√¢ntica de uma associa√ß√£o
bidirecional, mostramos tamb√©m o c√≥digo das duas classes:</p>
<pre><code>class Pessoa {
   ...
   private Fone fone;
   ...
}

class Fone {
   ...
   private Pessoa[] dono;
   ...
}</code></pre>
<p>Nesse c√≥digo, <code>Pessoa</code> possui um atributo privado
<code>fone</code> do tipo <code>Fone</code>, que pode ser null; com
isso, satisfazemos a extremidade 0..1 da associa√ß√£o bidirecional. Por
outro lado, <code>Fone</code> possui um vetor privado, de nome
<code>dono</code>, que referencia objetos do tipo <code>Pessoa</code>;
assim, satisfazemos a extremidade * da mesma associa√ß√£o.</p>
<p>No √∫ltimo diagrama de classes, omitimos todos os s√≠mbolos de
visibilidade, tanto p√∫blica (+) como privada (-). Isso foi feito, de
forma deliberada, para destacar que estamos tratando do uso de UML para
cria√ß√£o de esbo√ßos, quando os diagramas s√£o criados para discutir e
ilustrar uma ideia de projeto. Logo, nesse contexto, n√£o faz sentido
exigir que os diagramas sejam sintaticamente perfeitos. Por isso,
pequenos erros ou omiss√µes s√£o tolerados, principalmente quando n√£o h√°
preju√≠zo para o prop√≥sito do diagrama.</p>
<p><strong>Aprofundamento</strong>: UML ‚Äî dependendo da vers√£o que est√°
sendo usada ‚Äî admite nota√ß√µes diferentes para associa√ß√µes. Por exemplo,
algumas vezes, informa-se um nome para a associa√ß√£o, o qual √© mostrado
logo acima e ao longo da seta que une as duas classes. Outras vezes, no
caso de associa√ß√µes bidirecionais, as duas setas s√£o omitidas ‚Äî pois a
padroniza√ß√£o de UML define o seguinte: <q>uma associa√ß√£o em que nenhuma
das extremidades √© marcada com uma seta de navegabilidade √© naveg√°vel em
ambas as dire√ß√µes</q>. No entanto, essas nota√ß√µes alternativas tendem a
ser confusas ou mesmo amb√≠guas. Por exemplo, Gonzalo G√©nova e mais dois
pesquisadores da Universidade de Madrid, na Espanha, fazem a seguinte
observa√ß√£o sobre o uso de associa√ß√µes bidirecionais sem setas:
<q>infelizmente, isso pode introduzir ambiguidade na nota√ß√£o gr√°fica,
porque n√£o conseguimos mais distinguir entre associa√ß√µes bidirecionais e
associa√ß√µes sem especifica√ß√£o de navegabilidade</q> em uma de suas
extremidades (<a
href="http://dx.doi.org/10.5381/jot.2003.2.5.a4">link</a>, Se√ß√£o 3,
quarto par√°grafo). Existem ainda dois conceitos frequentemente
mencionados quando estudamos associa√ß√µes em UML: composi√ß√£o e agrega√ß√£o.
Composi√ß√£o √© uma rela√ß√£o na qual a classe de destino <em>n√£o</em> pode
existir de forma independente da classe de origem. Por outro lado,
quando as duas classes t√™m ciclos de vida independentes, temos uma
rela√ß√£o de agrega√ß√£o. No entanto, na pr√°tica, esses conceitos tamb√©m
geram confus√£o e, por isso, resolvemos n√£o os incluir na explica√ß√£o
sobre diagramas de classes. A mesma opini√£o √© compartilhada por outros
autores. Por exemplo, Fowler afirma que <q>agrega√ß√£o √© algo estritamente
sem sentido; portanto, eu recomendo que voc√™ ignore esse conceito em
seus diagramas</q> (<a
href="https://dl.acm.org/citation.cfm?id=861282">link</a>, p√°gina
68).</p>
<h3 data-number="4.3.2" id="heran√ßa"><span
class="header-section-number">4.3.2</span> Heran√ßa <a href="#heran√ßa"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>Em diagramas de classes, rela√ß√µes de heran√ßa s√£o representadas por
meio de setas com a extremidade n√£o preenchida. Essas setas s√£o usadas
para conectar subclasses √† sua classe base. No pr√≥ximo exemplo, elas
indicam que <code>PessoaFisica</code> e <code>PessoaJuridica</code> s√£o
subclasses de <code>Pessoa</code>. Como usual em orienta√ß√£o a objetos,
subclasses herdam todos os atributos e m√©todos da classe base, mas
tamb√©m podem adicionar novos membros. Por exemplo, apenas
<code>PessoaFisica</code> tem <code>cpf</code> e apenas
<code>PessoaJuridica</code> tem <code>cnpj</code>.</p>
<p><img src="figs/cap4/class10.svg" style="width:95.0%" /></p>
<h3 data-number="4.3.3" id="depend√™ncias"><span
class="header-section-number">4.3.3</span> Depend√™ncias <a
href="#depend√™ncias" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>Existe uma depend√™ncia de uma classe A para uma classe B,
representada por uma seta com uma linha tracejada de A para B, quando a
classe A usa a classe B, por√©m esse uso n√£o ocorre por meio de
associa√ß√£o (isto √©, A n√£o tem um atributo do tipo B) ou heran√ßa (isto √©,
A n√£o √© uma subclasse de B). Depend√™ncias ocorrem, por exemplo, quando
um m√©todo de A declara um par√¢metro ou vari√°vel local do tipo B ou
quando um m√©todo de A lan√ßa uma exce√ß√£o do tipo B. Uma depend√™ncia √©
considerada uma modalidade menos forte de relacionamento entre classes
do que relacionamentos que ocorrem por meio de associa√ß√£o e heran√ßa.</p>
<p>Para ilustrar o uso de depend√™ncias, considere o seguinte trecho de
c√≥digo:</p>
<pre><code>import java.util.Stack;

class MinhaClasse {
   ...
   private void metodoX() {
     Stack stack = new Stack();
     ...
   } ...
}</code></pre>
<p>Observe que o <code>metodoX</code> de <code>MinhaClasse</code> possui
uma vari√°vel local do tipo <code>java.util.Stack</code>. Nesse caso,
dizemos que existe uma depend√™ncia de <code>MinhaClasse</code> para
<code>java.util.Stack</code>, a qual √© modelada da seguinte forma:</p>
<p><img src="figs/cap4/class9.svg" style="width:65.0%" /></p>
<p>Algumas vezes, logo acima e ao longo da seta tracejada, informa-se o
tipo da depend√™ncia, usando-se palavras como create (para indicar que a
classe de origem instancia objetos da classe de destino da depend√™ncia)
ou call (para indicar que a classe de origem chama m√©todos da classe de
destino). Essas palavras s√£o escritas entre sinais de menor (&lt;&lt;) e
maior (&gt;&gt;). No diagrama a seguir, por exemplo, fica claro o tipo
de depend√™ncia que <code>ShapeFactory</code> estabelece com a classe
<code>Shape</code>.</p>
<p><img src="figs/cap4/class11.svg" style="width:65.0%" /></p>
<p>Uma classe pode ter depend√™ncias para um grande n√∫mero de classes. No
entanto, n√£o se costuma representar todas elas em diagramas de classes,
mas apenas as mais importantes e que est√£o diretamente relacionadas com
a funcionalidade ou propriedade do sistema que pretendemos esbo√ßar.</p>
<h2 data-number="4.4" id="diagrama-de-pacotes"><span
class="header-section-number">4.4</span> Diagrama de Pacotes <a
href="#diagrama-de-pacotes" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Diagramas de pacotes s√£o recomendados quando se pretende oferecer um
modelo de mais alto n√≠vel de um sistema, que mostre apenas grupos de
classes ‚Äî isto √©, pacotes ‚Äî e as depend√™ncias entre eles. Para isso, UML
define um ret√¢ngulo especial para representar pacotes, mostrado
abaixo:</p>
<p><img src="figs/cap4/package0.svg" style="width:25.0%" /></p>
<p>Ao contr√°rio dos ret√¢ngulos de classes, o ret√¢ngulo de pacotes inclui
apenas o nome do pacote (em negrito). Ele possui ainda um detalhe na
parte de cima, na forma de um trap√©zio, para melhor diferenci√°-lo dos
ret√¢ngulos de classe.</p>
<p>A figura da pr√≥xima p√°gina mostra um exemplo de diagrama de pacotes:
Nesse diagrama, podemos ver que o sistema possui quatro pacotes
principais: <code>MobileView</code>, <code>WebView</code>,
<code>BusinessLayer</code> e <code>Persistence</code>. Podemos ver ainda
as depend√™ncias ‚Äî setas tracejadas ‚Äî que existem entre eles. Ambos os
pacotes <code>View</code> usam classes de <code>BusinessLayer</code>.
Por outro lado, as classes de <code>BusinessLayer</code> tamb√©m usam
classes da <code>View</code>, por exemplo, para notific√°-las da
ocorr√™ncia de algum evento. Por isso, as setas que ligam os pacotes de
<code>View</code> a <code>BusinessLayer</code> s√£o bidirecionais. Por
fim, apenas classes do pacote <code>BusinessLayer</code> usam classes do
pacote <code>Persistence</code>.</p>
<p>Para concluir, gostar√≠amos de acrescentar duas observa√ß√µes:</p>
<ul>
<li><p>Depend√™ncias n√£o incluem informa√ß√µes sobre quantas classes do
pacote de origem dependem de classes do pacote de destino. Por exemplo,
suponha dois pacotes P1 e P2, ambos com 100 classes. Suponha ainda que
uma √∫nica classe de P1 use uma √∫nica classe de P2. Mesmo nesse caso,
dizemos que existe uma depend√™ncia de P1 para P2.</p></li>
<li><p>Em diagramas de pacotes, temos um √∫nico tipo de seta, sempre
tracejada, que representa qualquer tipo de relacionamento, seja ele por
meio de associa√ß√£o, heran√ßa ou depend√™ncia simples. Essa sem√¢ntica √©
diferente daquela que apresentamos para setas tracejadas em diagramas de
classes. Nesses √∫ltimos, rela√ß√µes de associa√ß√£o e heran√ßa s√£o
representadas por meio de setas cont√≠nuas. Apenas as demais depend√™ncias
s√£o representadas por meio de setas tracejadas.</p></li>
</ul>
<p><img src="figs/cap4/package1.svg" style="width:60.0%" /></p>
<h2 data-number="4.5" id="diagrama-de-sequ√™ncia"><span
class="header-section-number">4.5</span> Diagrama de Sequ√™ncia <a
href="#diagrama-de-sequ√™ncia" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Diagramas de sequ√™ncia s√£o diagramas din√¢micos, tamb√©m chamados de
comportamentais. Por isso, em vez de classes, eles modelam objetos de um
sistema. Adicionalmente, eles incluem informa√ß√µes sobre quais m√©todos
desses objetos s√£o executados em um determinado cen√°rio de uso de um
programa. Logo, eles s√£o usados quando se pretende explicar o
comportamento de um sistema, em um determinado cen√°rio. Por exemplo, no
final desta se√ß√£o, vamos apresentar um diagrama de sequ√™ncia que ilustra
os m√©todos que s√£o chamados quando um cliente chega em um caixa
eletr√¥nico e solicita uma opera√ß√£o de retirada de valores.</p>
<p>Antes disso, para iniciar a apresenta√ß√£o de diagramas de sequ√™ncia,
vamos usar o diagrama da pr√≥xima p√°gina. Apesar de simples, esse
diagrama serve para mostrar a din√¢mica e a nota√ß√£o usada por diagramas
de sequ√™ncia. Como j√° dissemos, diagramas de sequ√™ncia modelam objetos,
os quais s√£o representados por meio de ret√¢ngulos, com o nome dos
objetos modelados. Esses ret√¢ngulos ficam dispostos logo na primeira
linha do diagrama. Portanto, dois objetos s√£o representados no diagrama
anterior, de nomes <code>a1</code> e <code>b1</code>. Abaixo de cada
objeto, desenha-se uma linha vertical, a qual pode assumir duas formas:
(1) quando ela √© desenhada de forma tracejada, o objeto est√° inativo,
isto √©, nenhum de seus m√©todos est√° sendo executado; (2) quando a linha
fica cheia, ganhando um formato retangular, um dos m√©todos do objeto foi
chamado e encontra-se em execu√ß√£o. Quando essa execu√ß√£o termina, a linha
volta a ficar tracejada. Al√©m disso, o in√≠cio da chamada √© indicado por
uma seta na horizontal, com o nome do m√©todo chamado. O retorno da
chamada √© indicado por uma seta tracejada, com o nome do objeto
retornado. No entanto, √†s vezes a seta de retorno √© omitida, como no
caso da chamada do m√©todo <code>g</code>. Existem dois motivos para essa
omiss√£o: (1) o tipo de retorno √© <code>void</code>; ou (2) o objeto de
retorno n√£o √© relevante, a ponto de merecer ser representado no
diagrama.</p>
<p><img src="figs/cap4/sequence1.svg" style="width:65.0%" /></p>
<p>No diagrama de sequ√™ncia mostrado acima representamos apenas dois
objetos (<code>a1</code> e <code>b1</code>). Mas um diagrama de
sequ√™ncia pode ter mais objetos. No entanto, esse n√∫mero n√£o pode
crescer tanto, pois o diagrama acaba ficando complexo e de dif√≠cil
entendimento. Por exemplo, pode n√£o ser poss√≠vel represent√°-lo em uma
√∫nica folha de papel ou em uma tela de computador.</p>
<p>Um objeto pode ficar ativo e inativo diversas vezes em um mesmo
diagrama. Ou seja, ele pode executar um m√©todo; ficar inativo; executar
um novo m√©todo; ficar inativo, etc. Existe ainda um caso especial,
quando um objeto chama um m√©todo dele mesmo, isto √©, quando ele chama um
m√©todo usando this. Para ilustrar esse caso, suponha o seguinte
programa.</p>
<pre><code>class A {

  void g() { 
    ... 
  } 

  void f() {
    ... 
    g(); 
    ...
  }

  main() {
    A a = new A();
    a.f();
  }
}</code></pre>
<p>A execu√ß√£o desse programa √© representada pelo diagrama de sequ√™ncia a
seguir. Observe como a chamada de <code>g()</code> feita por
<code>f()</code> √© representada por meio de um novo ret√¢ngulo, que
<q>sai</q> do ret√¢ngulo que representa a ativa√ß√£o da fun√ß√£o
<code>f()</code>.</p>
<p><img src="figs/cap4/sequence2.svg" style="width:38.0%" /></p>
<p>Para concluir, o pr√≥ximo diagrama mostra um cen√°rio mais real, que
ilustra os m√©todos chamados quando o cliente de uma caixa eletr√¥nico
solicita um dep√≥sito de certo valor em sua conta.</p>
<p><img src="figs/cap4/sequence3.svg" style="width:75.0%" /></p>
<h2 data-number="4.6" id="diagrama-de-atividades"><span
class="header-section-number">4.6</span> Diagrama de Atividades <a
href="#diagrama-de-atividades" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Diagramas de atividades s√£o usados para representar, em alto n√≠vel,
um processo ou fluxo de execu√ß√£o. Os principais elementos desses
diagramas s√£o <strong>a√ß√µes</strong> representadas por ret√¢ngulos.
Existem ainda elementos de <strong>controle</strong>, que definem a
ordem de execu√ß√£o das a√ß√µes. A figura da pr√≥xima p√°gina mostra um
diagrama de atividades que modela o processo seguido ap√≥s um usu√°rio
fechar uma compra em uma loja virtual. Para isso, assume-se que os
produtos comprados j√° est√£o no carrinho de compra. Para entender o
funcionamento de um diagrama de atividades (como aquele mostrado na
figura), devemos assumir que existe uma ficha (<em>token</em>)
imagin√°ria que caminha pelos nodos do diagrama. A seguir, explicamos o
comportamento de cada nodo de um diagrama de atividades, assumindo a
exist√™ncia dessa ficha.</p>
<p><img src="figs/cap4/activity01.svg" style="width:55.0%" /></p>
<p><strong>Nodo Inicial:</strong> Cria uma ficha para dar in√≠cio √†
execu√ß√£o do processo. Feito isso, repassa a ficha para seu √∫nico fluxo
de sa√≠da. Por defini√ß√£o, o nodo inicial n√£o possui fluxo de entrada.</p>
<p><img src="figs/cap4/activity-t-inicial.svg"
style="width:15.0%" /></p>
<p><strong>A√ß√µes:</strong> Possuem um √∫nico fluxo de entrada e um √∫nico
fluxo de sa√≠da. Para uma a√ß√£o ser executada uma ficha precisa chegar no
seu fluxo de entrada. Ap√≥s a execu√ß√£o, repassa-se a ficha para o fluxo
de sa√≠da.</p>
<p><img src="figs/cap4/activity-t-acao.svg" style="width:25.0%" /></p>
<p><strong>Decis√µes:</strong> Possuem um √∫nico fluxo de entrada e dois
ou mais fluxos de sa√≠da. Cada fluxo de sa√≠da possui uma vari√°vel
booleana associada, chamada de guarda. Para se tomar uma decis√£o,
precisa-se receber uma ficha no fluxo de entrada. Quando isso acontece,
a ficha √© repassada apenas para o fluxo de sa√≠da cuja condi√ß√£o √©
verdadeira.</p>
<p><img src="figs/cap4/activity-t-decisao.svg"
style="width:30.0%" /></p>
<p><strong>Merges:</strong> Podem possuir v√°rios fluxos de entrada, mas
um √∫nico fluxo de sa√≠da. Quando uma ficha chega em um dos fluxos de
entrada, fazem seu repasse para o fluxo de sa√≠da. S√£o usados para unir
os fluxos de nodos de decis√£o.</p>
<p><img src="figs/cap4/activity-t-merge.svg" style="width:20.0%" /></p>
<p><strong>Forks:</strong> Possuem um √∫nico fluxo de entrada e um ou
mais fluxos de sa√≠da. Atuam como multiplicadores de ficha: quando
recebem uma ficha no fluxo de entrada, criam e repassam fichas id√™nticas
em cada fluxo de sa√≠da. Como resultado, passam a existir m√∫ltiplos
processos em execu√ß√£o de forma paralela.</p>
<p><img src="figs/cap4/activity-t-fork.svg" style="width:20.0%" /></p>
<p><strong>Joins:</strong> Possuem v√°rios fluxos de entrada, mas um
√∫nico fluxo de sa√≠da. Atuam como sorvedouros de fichas: esperam que
fichas cheguem em todos os fluxos de entrada. Quando isso acontece,
repassam uma √∫nica ficha para o fluxo de sa√≠da. Logo, s√£o usados para
sincronizar processos. Em outras palavras, transformar v√°rios fluxos de
execu√ß√£o em um √∫nico fluxo.</p>
<p><img src="figs/cap4/activity-t-join.svg" style="width:20.0%" /></p>
<p><strong>Nodo Final:</strong> Pode possuir mais de um fluxo de
entrada; mas n√£o possui fluxos de sa√≠da. Quando uma ficha chega em um
dos fluxos de entrada, encerra-se a execu√ß√£o do diagrama de
atividades.</p>
<p><img src="figs/cap4/activity-t-final.svg" style="width:15.0%" /></p>
<p><strong>Aprofundamento</strong>: Existem pelo menos tr√™s outras
alternativas para modelagem de fluxos e processos:</p>
<ul>
<li><p><strong>Fluxogramas,</strong> os quais foram propostos t√£o logo
se come√ßou a desenvolver os primeiros programas para computadores
modernos. Diagramas de atividades s√£o parecidos com fluxogramas; por√©m,
eles incluem suporte a concorr√™ncia, por meio de <em>forks</em> e
<em>joins</em>. Por outro lado, fluxogramas modelam processos
sequenciais.</p></li>
<li><p><strong>Redes de Petri</strong> √© uma nota√ß√£o gr√°fica, proposta
pelo matem√°tico alem√£o Carl Adam Petri, em 1962, para modelagem de
sistemas concorrentes. Redes de Petri possuem uma representa√ß√£o gr√°fica
e tamb√©m usam fichas (<em>tokens</em>) para marcar o estado corrente do
sistema. Elas t√™m ainda a vantagem de possuir uma defini√ß√£o mais formal,
principalmente quando comparada com a defini√ß√£o de diagramas de
atividades. Por outro lado, esses √∫ltimos tendem a oferecer uma nota√ß√£o
mais simples e f√°cil de entender.</p></li>
<li><p><strong>BPMN</strong> (<em>Business Process Model and
Notation</em>) √© um esfor√ßo mais recente, que teve in√≠cio nos anos 2000,
visando a proposi√ß√£o de uma nota√ß√£o gr√°fica mais amig√°vel para modelagem
de processos de neg√≥cio do que aquela oferecida por diagramas de
atividades. Um dos objetivos √© propiciar que analistas de neg√≥cio possam
ler, interpretar e validar diagramas BPMN.</p></li>
</ul>
<h2 class="unnumbered" id="bibliografia">Bibliografia <a
href="#bibliografia" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Martin Fowler. UML Distilled: A Brief Guide to the Standard Object
Modeling Language. Addison-Wesley, 2003.</p>
<p>Grady Booch, James Rumbaugh, Ivar Jacobson. The Unified Modeling
Language User Guide. Addison-Wesley, 2005.</p>
<p>Craig Larman. Applying UML and Patterns: An Introduction to
Object-Oriented Analysis and Design and Iterative Development.
Prentice-Hall, 2004.</p>
<h2 class="unnumbered" id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o
<a href="#exerc√≠cios-de-fixa√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>1. Explique e discuta os tr√™s usos poss√≠veis de UML:</p>
<ol type="a">
<li>Como blueprint (ou plantas t√©cnicas detalhadas)</li>
<li>Como sketches (esbo√ßos)</li>
<li>Como linguagem de programa√ß√£o.</li>
</ol>
<p>2. Descreva cen√°rios de uso de diagramas de classes UML como
instrumento dos seguintes tipos de engenharia:</p>
<ol type="a">
<li>Engenharia Reversa</li>
<li>Engenharia Avante (<em>Forward Engineering</em>).</li>
</ol>
<p>3. Modele os cen√°rios descritos a seguir usando Diagramas de Classe
UML. Veja que as classes s√£o grafadas em uma fonte diferente.</p>
<ol type="a">
<li><p><code>ContaBancaria</code> possui exatamente um
<code>Cliente</code>. Um <code>Cliente</code>, por sua vez, pode ter
v√°rias <code>ContaBancaria</code>. Existe navegabilidade em ambos os
sentidos.</p></li>
<li><p><code>ContaPoupanca</code> e <code>ContaSalario</code> s√£o
subclasses de <code>ContaBancaria</code>.</p></li>
<li><p>No c√≥digo de <code>ContaBancaria</code> declara-se uma vari√°vel
local do tipo <code>BancoDados</code>.</p></li>
<li><p>Um <code>ItemPedido</code> se refere a um √∫nico
<code>Produto</code> (sem navegabilidade). Um <code>Produto</code> pode
ter v√°rios <code>ItemPedido</code> (com navegabilidade).</p></li>
<li><p>A classe <code>Aluno</code> possui atributos <code>nome</code>,
<code>matricula</code>, <code>curso</code> (todos privados); e m√©todos
<code>getCurso()</code> e <code>cancelaMatricula()</code>, ambos
p√∫blicos.</p></li>
</ol>
<p>4. (ENADE 2014, Tec. e An√°lise de Sistemas) Construa um diagrama de
classes para representar as seguintes classes e associa√ß√µes:</p>
<ul>
<li><p>Uma revista cient√≠fica possui t√≠tulo, ISSN e
periodicidade;</p></li>
<li><p>Essa revista publica diversas edi√ß√µes com os seguintes atributos:
n√∫mero da edi√ß√£o, volume da edi√ß√£o e data da edi√ß√£o. Importante destacar
que cada inst√¢ncia da classe edi√ß√£o relaciona-se √∫nica e exclusivamente
a uma inst√¢ncia da classe revista cient√≠fica, n√£o podendo relacionar-se
com nenhuma outra;</p></li>
<li><p>Um artigo possui t√≠tulo e nome do autor. Um artigo √© um conte√∫do
exclusivo de uma edi√ß√£o. E uma edi√ß√£o obrigatoriamente tem que possuir
no m√≠nimo 10 e no m√°ximo 15 artigos.</p></li>
</ul>
<p>5. Crie diagramas de classes para os seguintes trechos de c√≥digo:</p>
<p>(a)</p>
<pre><code>public class HelloWorldSwing { 

   public static void main(String[] args) {
     JFrame frame = new JFrame(&quot;Hello world!&quot;);
     frame.setVisible(true);
   }

}</code></pre>
<p>(b)</p>
<pre><code>class HelloWorldSwing extends JFrame {

   public HelloWorldSwing() {
     super(&quot;Hello world!&quot;);
   }

   public static void main(String[] args) {
     HelloWorldSwing frame = new HelloWorldSwing();
     frame.setVisible(true);
   }

}</code></pre>
<p>6. Mostre o diagrama de sequ√™ncia relativo ao seguinte c√≥digo. O
diagrama deve come√ßar com a seguinte chamada
<em>a</em>.<em>m5()</em>.</p>
<pre><code>A a = new A(); // vari√°veis globais
B b = new B();
C c = new C();

class C { 
   void m1() { ... } 
}

class B { 
   void m2() { ... c.m1(); ... this.m3(); ... }
   void m3() { ... c.m1(); ... }
   void m4() { ... }
}

class A { 
   void m5() { ... b.m2(); ... b.m3(); ... b.m4(); ...  }
}     </code></pre>
<p>7. Em diagramas de atividades, explique a diferen√ßa entre um nodo de
<em>merge</em> e um nodo de <em>join</em>.</p>
<p>8. Qual √© o erro do seguinte diagrama de atividades? Refa√ßa o
diagrama de forma a refletir corretamente a inten√ß√£o do projetista.</p>
<p><img src="figs/cap4/activity-exercicio.svg"
style="width:50.0%" /></p>
<button onclick="darkMode()">Modo noturno</button>

<script>
function darkMode() {
   var element = document.body;
   element.classList.toggle("dark-mode");
}
</script>

</div>
</div>
</div>

<footer>
Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formul√°rio</a>.
</footer>
</body>
</html>
