<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 7: Arquitetura ‚Äì Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">
<img src="https://engsoftmoderna.info/figs/capa/capa-3d.jpg"></a>
</p>

<p>
<a href="https://engsoftmoderna.info">P√°gina principal do livro</a>
</p>

<p>Compre na

<a href="https://www.amazon.com.br/gp/product/6500019504">Amazon</a> ou
<!--
<a href="https://www.submarino.com.br/produto/1768283036/engenharia-de-software-moderna">
      Submarino</a> ou 
<a href="https://loja.umlivro.com.br/engenharia-de-software-moderna-4778188/p">
      UmLivro</a>
-->
<a href="https://www.casasbahia.com.br/livros/InformaticaCertificacao/livrosdeinformatica/engenharia-de-software-moderna-1513074930.html">Casas Bahia</a>
</p>

<p>
Veja tamb√©m os cursos de extens√£o a dist√¢ncia 
<a href="https://www.engsoftmoderna.dcc.ufmg.br">Engenharia de Software Moderna</a> (48 horas) e
<a href="https://www.testesoft.dcc.ufmg.br">Teste de Software</a> (20 horas), oferecidos pelo DCC/UFMG. Matr√≠culas abertas para as turmas do segundo semestre de 2023.</p>


<!---
<p>
Veja tamb√©m nosso <a href="https://engsoftmoderna.info/curso">curso de extens√£o</a> a dist√¢ncia, com certificados emitidos pelo DCC/UFMG. 
</p>
--->
<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="7" id="arquitetura"><span
class="header-section-number">7</span> Arquitetura <a
href="#arquitetura" class="anchor-link" aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>Architecture is about the important stuff. Whatever that is.</em>
‚Äì Ralph Johnson</p>
</blockquote>
<p>Este cap√≠tulo inicia com uma introdu√ß√£o ao conceito de arquitetura de
software. Em seguida, discutimos diversos padr√µes arquiteturais,
incluindo: Arquitetura em Camadas e, especificamente, Arquitetura em
Tr√™s Camadas (Se√ß√£o 7.2), Arquitetura MVC (Se√ß√£o 7.3) e Arquitetura
baseada em Microsservi√ßos (Se√ß√£o 7.4). No caso de microsservi√ßos,
procuramos mostrar o contexto que levou ao surgimento desse padr√£o
arquitetural, bem como discutimos seus principais benef√≠cios e desafios.
Em seguida, discutimos dois padr√µes arquiteturais usados para garantir
escalabilidade e desacoplamento em sistemas distribu√≠dos: Filas de
Mensagens (Se√ß√£o 7.5) e Publish/Subscribe (Se√ß√£o 7.6). Terminamos o
cap√≠tulo discutindo outros padr√µes arquiteturais (Se√ß√£o 7.7) e dando um
exemplo de anti-padr√£o arquitetural (Se√ß√£o 7.8).</p>
<h2 data-number="7.1" id="introdu√ß√£o"><span
class="header-section-number">7.1</span> Introdu√ß√£o <a
href="#introdu√ß√£o" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> Existe mais de uma defini√ß√£o para arquitetura de software. Uma das
mais comuns considera que arquitetura preocupa-se com <q>projeto em mais
alto n√≠vel</q>. Ou seja, o foco deixa de ser a organiza√ß√£o e interfaces
de classes individuais e passa a ser em unidades de maior tamanho, sejam
elas pacotes, componentes, m√≥dulos, subsistemas, camadas ou servi√ßos ‚Äî o
nome n√£o importa tanto neste primeiro momento. De forma gen√©rica, os
termos que acabamos de mencionar devem ser entendidos como conjuntos de
classes relacionadas.</p>
<p>Al√©m de possu√≠rem um <q>maior tamanho</q>, os componentes
arquiteturais devem ser relevantes para que um sistema atenda a seus
objetivos. Por exemplo, suponha que voc√™ trabalhe em um sistema de
informa√ß√µes. Certamente, esse sistema inclui um m√≥dulo de persist√™ncia,
que faz a interface com o banco de dados. Esse m√≥dulo √© fundamental em
sistemas de informa√ß√µes, pois eles t√™m como objetivo principal
automatizar e persistir informa√ß√µes relativas a processos de neg√≥cio.
Por outro lado, suponha agora que voc√™ trabalhe em um sistema que usa
t√©cnicas de intelig√™ncia artificial para diagnosticar doen√ßas. O sistema
tamb√©m possui um m√≥dulo de persist√™ncia para armazenar dados das doen√ßas
que s√£o diagnosticadas. Por√©m, esse m√≥dulo, al√©m de simples, n√£o √©
relevante para o objetivo principal do sistema. Logo, ele n√£o faz parte
da sua arquitetura.</p>
<p>Existe ainda uma segunda defini√ß√£o para arquitetura de software. Tal
como expresso na frase de Ralph Johnson que abre esse cap√≠tulo, ela
considera que arquitetura de software inclui as decis√µes de projeto mais
importantes em um sistema. Essas decis√µes s√£o t√£o importantes que, uma
vez tomadas, dificilmente poder√£o ser revertidas no futuro. Portanto,
essa segunda forma de definir arquitetura √© mais ampla do que a primeira
que apresentamos. Ela considera que arquitetura n√£o √© apenas um conjunto
de m√≥dulos, mas um conjunto de decis√µes. √â verdade que dentre essas
decis√µes, inclui-se a defini√ß√£o dos m√≥dulos principais de um sistema.
Mas outras decis√µes tamb√©m s√£o contempladas, como a escolha da linguagem
de programa√ß√£o e do banco de dados que ser√£o usados no desenvolvimento.
De fato, uma vez que um sistema √© implementado com um determinado banco
de dados, dificilmente consegue-se migrar para um outro banco de dados.
Prova disso √© que ainda hoje temos exemplos de sistemas cr√≠ticos que
funcionam com bancos de dados n√£o-relacionais e que s√£o implementados em
linguagens como COBOL.</p>
<p> <strong>Padr√µes arquiteturais</strong> prop√µem uma organiza√ß√£o de
mais alto n√≠vel para sistemas de software, incluindo seus principais
m√≥dulos e as rela√ß√µes entre eles. Essas rela√ß√µes definem, por exemplo,
que um m√≥dulo A pode (ou n√£o pode) usar os servi√ßos de um m√≥dulo B.
Neste cap√≠tulo, vamos estudar padr√µes arquiteturais que d√£o origem √†s
seguintes arquiteturas: Arquitetura em Camadas (Se√ß√£o 7.2), Arquitetura
Model-View-Controller ou MVC (Se√ß√£o 7.3), Microsservi√ßos (Se√ß√£o 7.4),
Arquitetura Orientada a Mensagens (Se√ß√£o 7.5) e Arquitetura
Publish/Subscribe (Se√ß√£o 7.6).</p>
<p>Para finalizar, iremos apresentar de forma breve outros padr√µes
arquiteturais, como pipes e filtros (Se√ß√£o 7.7). Vamos tamb√©m dar um
exemplo de um anti-padr√£o arquitetural, conhecido como <em>big ball of
mud</em> (Se√ß√£o 7.8).</p>
<p></p>
<p><strong>Aprofundamento</strong>: Alguns autores ‚Äî como Taylor et al.
(<a href="https://dl.acm.org/citation.cfm?id=1538494">link</a>) ‚Äî fazem
uma distin√ß√£o entre padr√µes e <strong>estilos arquiteturais</strong>.
Segundo eles, padr√µes focam em solu√ß√µes para problemas espec√≠ficos de
arquitetura; enquanto estilos arquiteturais prop√µem que os m√≥dulos de um
sistema devem ser organizados de uma determinado modo, o que n√£o
necessariamente ocorre visando resolver um problema espec√≠fico. Assim,
para esses autores, MVC √© um padr√£o arquitetural que resolve o problema
de separar apresenta√ß√£o e modelo em sistemas de interfaces gr√°ficas. Por
outro lado, Pipes &amp; Filtros constituem um estilo arquitetural. Neste
cap√≠tulo, por√©m, n√£o vamos fazer essa distin√ß√£o. Em vez disso,
chamaremos todos eles de padr√µes arquiteturais.</p>
<h3 data-number="7.1.1" id="debate-tanenbaum-torvalds"><span
class="header-section-number">7.1.1</span> Debate Tanenbaum-Torvalds <a
href="#debate-tanenbaum-torvalds" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> No in√≠cio de 1992, um debate acalorado sobre a arquitetura de
sistemas operacionais tomou conta de um grupo de discuss√£o da Internet.
Apesar de v√°rios desenvolvedores e pesquisadores terem participado da
discuss√£o, ela ficou conhecida como <strong>Debate
Tanenbaum-Torvalds</strong> (<a
href="https://dl.acm.org/citation.cfm?id=553109">link</a>, ap√™ndice A,
p√°gina 102). Tanenbaum (Andrew) √© um pesquisador da √°rea de sistemas
operacionais, autor de livros-texto na √°rea e professor da Vrije
Universiteit, em Amsterd√£, na Holanda. E Torvalds (Linus) na √©poca era
estudante de Computa√ß√£o na Universidade de Helsinki, na Finl√¢ndia.</p>
<p> A discuss√£o come√ßou quando Tanenbaum postou uma mensagem no grupo
com o t√≠tulo <q>Linux est√° obsoleto</q>. O seu principal argumento era
que o Linux seguia uma <strong>arquitetura monol√≠tica</strong>, na qual
todas as fun√ß√µes do sistema operacional ‚Äî como gerenciamento de
processos, gerenciamento de mem√≥ria e sistemas de arquivos, por exemplo
‚Äî s√£o implementadas em um √∫nico arquivo execut√°vel, que roda em modo
supervisor. Desde essa √©poca, Tanenbaum argumentava que a melhor solu√ß√£o
para sistemas operacionais era uma <strong>arquitetura
microkernel</strong>, na qual o kernel fica respons√°vel apenas pelas
fun√ß√µes mais b√°sicas do sistema. As demais fun√ß√µes rodam como processos
independentes e fora do kernel. Linus respondeu √† mensagem de forma
enf√°tica, alegando que pelo menos o Linux j√° era uma realidade na √©poca,
enquanto que o sistema baseado em um microkernel que estava sendo
desenvolvido por Tanenbaum apresentava diversos problemas e bugs. A
discuss√£o continuou forte e Tanembaum chegou a declarar que Torvalds
tinha sorte por n√£o ter sido seu aluno; se fosse, ele certamente n√£o
teria obtido uma boa nota com o projeto monol√≠tico do Linux. Um
coment√°rio interessante foi feito em seguida por Ken Thompson, um dos
projetistas das primeiras vers√µes do Unix:</p>
<blockquote>
<p><q>Na minha opini√£o, √© mais f√°cil implementar um sistema operacional
com um kernel monol√≠tico. Mas √© tamb√©m mais f√°cil que ele se transforme
em uma bagun√ßa √† medida que o kernel √© modificado.</q></p>
</blockquote>
<p>Na verdade, Thompson previu o futuro, pois em 2009, Linus declarou o
seguinte em uma confer√™ncia:</p>
<blockquote>
<p><q>N√£o somos mais o kernel simples, pequeno e hiper-eficiente que
imaginei h√° 15 anos. Em vez disso, nosso kernel est√° ficando grande e
inchado. E sempre que adicionamos novas funcionalidades, o cen√°rio
piora.</q></p>
</blockquote>
<p>Esse coment√°rio consta de uma p√°gina da Wikip√©dia (<a
href="https://en.wikipedia.org/wiki/Criticism_of_Linux">link</a>) e foi
objeto de diversas mat√©rias em sites de tecnologia na √©poca. Ele revela
que arquitetura n√£o s√£o apenas decis√µes importantes e dif√≠ceis de
reverter. Muitas vezes, s√£o tamb√©m decis√µes que levam anos para que seus
efeitos negativos fiquem mais claros e comecem a causar problemas.</p>
<h2 data-number="7.2" id="arquitetura-em-camadas"><span
class="header-section-number">7.2</span> Arquitetura em Camadas <a
href="#arquitetura-em-camadas" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p><strong>Arquitetura em camadas</strong> √© um dos padr√µes
arquiteturais mais usados, desde que os primeiros sistemas de software
de maior porte foram constru√≠dos nas d√©cadas de 60 e 70. Em sistemas que
seguem esse padr√£o, as classes s√£o organizadas em m√≥dulos de maior
tamanho, chamados de <strong>camadas</strong>. As camadas s√£o dispostas
de forma hier√°rquica, como em um bolo. Assim, uma camada somente pode
usar servi√ßos ‚Äî isto √©, chamar m√©todos, instanciar objetos, estender
classes, declarar par√¢metros, lan√ßar exce√ß√µes, etc. ‚Äî da camada
imediatamente inferior.</p>
<p>Dentre outras aplica√ß√µes, arquiteturas em camadas s√£o muito usadas na
implementa√ß√£o de protocolos de rede. Por exemplo, HTTP √© um protocolo de
aplica√ß√£o, que usa servi√ßos de um protocolo de transporte; por exemplo,
TCP. Por sua vez, TCP usa servi√ßos de um protocolo de rede; por exemplo,
IP. Finalmente, a camada IP usa servi√ßos de um protocolo de comunica√ß√£o;
por exemplo, Ethernet.</p>
<p>Uma arquitetura em camadas particiona a complexidade envolvida no
desenvolvimento de um sistema em componentes menores (as camadas). Como
uma segunda vantagem, ela disciplina as depend√™ncias entre essas
camadas. Como dissemos, a camada <em>n</em> somente pode usar servi√ßos
da camada <em>n-1</em>. Isso ajuda no entendimento, manuten√ß√£o e
evolu√ß√£o de um sistema. Por exemplo, torna-se mais f√°cil trocar uma
camada por outra (por exemplo, mudar de TCP para UDP). Fica mais f√°cil
tamb√©m o re√∫so de uma camada por mais de uma camada superior. Por
exemplo, a camada de transporte pode ser usada por v√°rios protocolos de
aplica√ß√£o, como HTTP, SMTP, DHCP, etc.</p>
<p> </p>
<p><strong>Aprofundamento</strong>: Uma das primeiras propostas de
arquitetura em camadas foi elaborada por Edsger W. Dijkstra, em 1968,
para um sistema operacional denominado THE (<a
href="https://doi.org/10.1145/363095.363143">link</a>). As camadas
propostas por Dijkstra foram as seguintes: multiprograma√ß√£o (camada 0),
aloca√ß√£o de mem√≥ria (camada 1), comunica√ß√£o entre processos (camada 2),
gerenciamento de entrada/sa√≠da (camada 3) e programas dos usu√°rios
(camada 4). Dijkstra conclui o artigo destacando que os benef√≠cios de
uma estrutura hier√°rquica s√£o mais importantes ainda em projetos de
maior porte.</p>
<h3 data-number="7.2.1" id="arquitetura-em-tr√™s-camadas"><span
class="header-section-number">7.2.1</span> Arquitetura em Tr√™s Camadas
<a href="#arquitetura-em-tr√™s-camadas" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p> Esse tipo de arquitetura √© comum na constru√ß√£o de sistemas de
informa√ß√£o corporativos. At√© o final da d√©cada de 80, aplica√ß√µes
corporativas ‚Äî como folhas de pagamento, controle de estoque ou sistemas
financeiros ‚Äî executavam em <strong>mainframes</strong>, que eram
computadores fisicamente grandes e tamb√©m muito caros. As aplica√ß√µes
eram monol√≠ticas e acessadas por meio de <q>terminais burros</q>, isto
√©, sem qualquer capacidade de processamento e com uma interface
totalmente textual. Com o avan√ßo nas tecnologias de rede e de hardware,
foi poss√≠vel migrar esses sistemas de mainframes para outras
plataformas. Foi nessa √©poca que arquiteturas em tr√™s camadas se
tornaram uma alternativa muito comum.</p>
<p>As tr√™s camadas dessa arquitetura s√£o as seguintes:</p>
<ul>
<li><p>Interface com o Usu√°rio, tamb√©m chamada de camada de
apresenta√ß√£o, √© respons√°vel por toda intera√ß√£o com o usu√°rio. Ela trata
tanto da exibi√ß√£o de informa√ß√£o, como da coleta e processamento de
entradas e eventos de interfaces, tais como cliques em bot√µes, marca√ß√£o
de texto, etc. A camada de interface pode ser uma aplica√ß√£o desktop, em
Windows ou outro sistema operacional com interface gr√°fica, como tamb√©m
Web. Por exemplo, um sistema acad√™mico deve prover uma interface para os
professores lan√ßarem as notas de suas disciplinas. O elemento principal
dessa interface pode ser um formul√°rio com duas colunas: nome do aluno e
nota. O c√≥digo que implementa esse formul√°rio deve estar na camada de
interface.</p></li>
<li><p>L√≥gica de Neg√≥cio, tamb√©m conhecida como camada de aplica√ß√£o,
implementa as regras de neg√≥cio do sistema. No sistema acad√™mico que
estamos usando como exemplo, podemos ter a seguinte regra de neg√≥cio: as
notas s√£o maiores ou iguais a zero e menores ou iguais ao valor da
avalia√ß√£o. Quando um professor solicitar o lan√ßamento das notas de uma
disciplina, cabe √† camada de l√≥gica verificar se essa regra √© obedecida.
Uma outra regra de neg√≥cio pode ser a seguinte: ap√≥s o lan√ßamento de
qualquer nota, os alunos devem ser avisados por meio de um
e-mail.</p></li>
<li><p>Banco de Dados, que armazena os dados manipulados pelo sistema.
Por exemplo, no nosso sistema acad√™mico, ap√≥s lan√ßamento e valida√ß√£o das
notas, elas s√£o salvas em um banco de dados.</p></li>
</ul>
<p>Normalmente, uma arquitetura em tr√™s camadas √© uma arquitetura
distribu√≠da. Isto √©, a camada de interface executa na m√°quina dos
clientes. A camada de neg√≥cio executa em um servidor, muitas vezes
chamado de servidor de aplica√ß√£o. E, por fim, temos o banco de dados. A
figura da pr√≥xima p√°gina mostra um exemplo, que assume que a interface
oferecida aos clientes √© uma interface gr√°fica.</p>
<figure>
<img src="figs/cap7/tiers3.svg" style="width:80.0%"
alt="Arquitetura em tr√™s camadas" />
<figcaption aria-hidden="true">Arquitetura em tr√™s camadas</figcaption>
</figure>
<p>Em sistemas tr√™s camadas, a camada de aplica√ß√£o pode ter diversos
m√≥dulos, incluindo uma fachada, para facilitar o acesso ao sistema pelos
clientes, e um m√≥dulo de persist√™ncia, com a fun√ß√£o de isolar o banco de
dados dos demais m√≥dulos.</p>
<p> Por fim, gostar√≠amos de mencionar que √© poss√≠vel ter sistemas em
<strong>duas camadas</strong>. Nesses casos, as camadas de interface e
de aplica√ß√£o s√£o unidas em uma √∫nica camada, que executa no cliente. A
camada restante continua sendo o banco de dados. A desvantagem de
arquiteturas em duas camadas √© que todo o processamento ocorre nos
clientes, que, portanto, devem ter um maior poder de computa√ß√£o.</p>
<h2 data-number="7.3" id="arquitetura-mvc"><span
class="header-section-number">7.3</span> Arquitetura MVC <a
href="#arquitetura-mvc" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>O padr√£o arquitetural MVC (Model-View-Controller) foi proposto no
final da d√©cada de 70 e, em seguida, usado na implementa√ß√£o de
Smalltalk-80, que √© considerada uma das primeiras linguagens orientadas
a objetos. Al√©m de utilizarem conceitos de orienta√ß√£o a objetos,
programas em Smalltalk foram pioneiros no uso de interfaces gr√°ficas,
com janelas, bot√µes, scroll bars, mouse, etc. Isso em uma √©poca em que
os sistemas operacionais ofereciam apenas interfaces de linha de comando
e os programas tinham uma interface textual, isto √©, as telas eram uma
matriz de caracteres, com, por exemplo, 25 linhas e 80 colunas.</p>
<p> MVC foi o padr√£o arquitetural escolhido pelos projetistas de
Smalltalk para implementa√ß√£o de interfaces gr√°ficas. Especificamente,
MVC define que as classes de um sistema devem ser organizadas em tr√™s
grupos:</p>
<ul>
<li><p>Vis√£o: classes respons√°veis pela apresenta√ß√£o da interface
gr√°fica do sistema, incluindo janelas, bot√µes, menus, barras de rolagem,
etc.</p></li>
<li><p>Controladoras: classes que tratam e interpretam eventos gerados
por dispositivos de entrada, como mouse e teclado. Como resultado de
tais eventos, Controladoras podem solicitar uma altera√ß√£o no estado do
Modelo ou da Vis√£o. Suponha, por exemplo, uma Calculadora. Quando o
usu√°rio clica em um bot√£o <q>+</q>, uma classe Controladora deve
capturar esse evento e chamar um m√©todo do Modelo. Como um segundo
exemplo, quando o usu√°rio clicar no bot√£o <q>Dark UI</q>, cabe tamb√©m a
uma classe Controladora solicitar √† Vis√£o para mudar as cores da
interface gr√°fica para tons mais escuros.</p></li>
<li><p>Modelo: classes que armazenam os dados manipulados pela aplica√ß√£o
e que t√™m a ver com o dom√≠nio do sistema em constru√ß√£o. Assim, classes
de modelo n√£o t√™m qualquer conhecimento ou depend√™ncia para classes de
Vis√£o e Controladoras. Al√©m de dados, classes de modelo podem conter
m√©todos que alteram o estado dos objetos de dom√≠nio.</p></li>
</ul>
<p>Portanto, em uma arquitetura MVC, a interface gr√°fica √© formada por
objetos de vis√£o e por controladores. Por√©m, em muitos sistemas n√£o
existe uma distin√ß√£o clara entre Vis√£o e Controladores. Segundo Fowler
(<a href="https://dl.acm.org/citation.cfm?id=579257">link</a>, p√°gina
331), mesmo a maioria das vers√µes de Smalltalk n√£o separa esses dois
componentes. Por isso, fica mais f√°cil entender da seguinte forma:</p>
<p>MVC = (Vis√£o + Controladores) + Modelo = Interface Gr√°fica +
Modelo</p>
<p>A pr√≥xima figura mostra as depend√™ncias entre as classes de uma
arquitetura MVC. A figura primeiro refor√ßa que a interface gr√°fica √©
composta pela Vis√£o e por Controladores. Podemos observar tamb√©m que a
Interface Gr√°fica pode depender do Modelo. Por√©m, classes de Modelo n√£o
t√™m depend√™ncias para classes da Interface Gr√°fica. Na verdade, podemos
entender a Interface Gr√°fica como sendo observadora do Modelo. Quando o
estado dos objetos do Modelo √© alterado, deve-se atualizar
automaticamente a interface do sistema.</p>
<figure>
<img src="figs/cap7/mvc.svg" style="width:60.0%"
alt="Arquitetura MVC" />
<figcaption aria-hidden="true">Arquitetura MVC</figcaption>
</figure>
<p>Dentre as vantagens de arquiteturas MVC, podemos citar:</p>
<ul>
<li><p>MVC favorece a especializa√ß√£o do trabalho de desenvolvimento. Por
exemplo, pode-se ter desenvolvedores especialistas na implementa√ß√£o de
interfaces gr√°ficas, os quais s√£o chamados de desenvolvedores de
front-end. Por outro lado, desenvolvedores de classes de Modelo n√£o
precisam conhecer e implementar c√≥digo de interface com
usu√°rios.</p></li>
<li><p>MVC permite que classes de Modelo sejam usadas por diferentes
Vis√µes, como ilustrado na pr√≥xima figura. Neste exemplo, um objeto de
Modelo armazena dois valores: hora e minutos. Esses dados s√£o
apresentados em duas vis√µes diferentes. Na primeira, como um rel√≥gio
anal√≥gico. Na segunda, como um rel√≥gio digital.</p>
<figure>
<img src="figs/cap7/clock.png" style="width:40.0%"
alt="Sistema MVC com mais de uma vis√£o (interface gr√°fica)" />
<figcaption aria-hidden="true">Sistema MVC com mais de uma vis√£o
(interface gr√°fica)</figcaption>
</figure></li>
<li><p>MVC favorece testabilidade. Como veremos no pr√≥ximo cap√≠tulo, √©
mais f√°cil testar objetos n√£o-visuais, isto √©, n√£o relacionados com a
implementa√ß√£o de interfaces gr√°ficas. Por isso, ao separar objetos de
apresenta√ß√£o de objetos de Modelo, fica mais f√°cil testar esses
√∫ltimos.</p></li>
</ul>
<p> Vamos concluir com um resumo sobre MVC, na vis√£o de Fowler e Beck
(<a href="https://dl.acm.org/citation.cfm?id=311424">link</a>, Cap. 12,
p√°g. 370):</p>
<blockquote>
<p><q>O cora√ß√£o e a parte mais preciosa de MVC est√° na separa√ß√£o entre
c√≥digo de interface com o usu√°rio (a Vis√£o, tamb√©m chamada de
apresenta√ß√£o) e a l√≥gica do dom√≠nio (o Modelo). As classes de
apresenta√ß√£o implementam apenas a l√≥gica necess√°ria para lidar com a
interface do usu√°rio. Por outro lado, objetos de dom√≠nio n√£o incluem
c√≥digo visual, mas apenas l√≥gica de neg√≥cios. Isso separa duas partes
complexas de sistemas de software em partes que s√£o mais f√°ceis de se
modificar. Tamb√©m permite v√°rias apresenta√ß√µes da mesma l√≥gica de
neg√≥cio.</q></p>
</blockquote>
<p><strong>Pergunta Frequente</strong>: <strong>Qual a diferen√ßa entre
MVC e tr√™s camadas?</strong> A resposta vai ser um pouco longa e vamos
nos basear na evolu√ß√£o hist√≥rica dessas arquiteturas:</p>
<ul>
<li><p>Como comentamos, MVC surgiu no final da d√©cada de 70, para ajudar
na constru√ß√£o de interfaces gr√°ficas. Isto √©, aplica√ß√µes que incluem uma
interface com janelas, bot√µes, caixas de texto, etc. Como exemplo,
podemos citar um pacote de escrit√≥rio, com aplica√ß√µes como Word, Excel e
Powerpoint, no caso do sistema operacional Windows.</p></li>
<li><p>Na d√©cada de 90, as tecnologias de redes, sistemas distribu√≠dos e
bancos de dados se tornaram comuns. Viabilizou-se ent√£o a constru√ß√£o de
aplica√ß√µes distribu√≠das com tr√™s camadas. Nesse caso, MVC pode ser usado
na implementa√ß√£o da camada de interface, que pode, por exemplo, ser uma
aplica√ß√£o nativa em Windows, implementada usando-se linguagens como
Visual Basic ou Java (neste √∫ltimo caso, usando-se frameworks como
Swing). Resumindo, a aplica√ß√£o, como um todo segue, uma arquitetura em
tr√™s camadas, mas usa MVC na camada de interface com o usu√°rio.</p></li>
<li><p>No in√≠cio dos anos 2000, a Web se popularizou e a interface das
aplica√ß√µes migrou para HTML e, depois, para HTML e JavaScript. A
confus√£o entre os termos MVC e tr√™s camadas surgiu ent√£o nessa √©poca,
principalmente devido ao aparecimento de frameworks para implementa√ß√£o
de sistemas Web que se denominaram frameworks MVC. Como exemplo, podemos
citar Spring (para Java), Ruby on Rails, Django (para Python) e CakePHP.
Na verdade, esses frameworks expandiram e adaptaram o conceito de MVC
para Web. Por exemplo, eles for√ßam a organiza√ß√£o de um sistema Web em
tr√™s partes (veja tamb√©m na pr√≥xima figura): vis√£o, composta por p√°ginas
HTML; controladores, que processam uma solicita√ß√£o e geram uma nova
vis√£o como resposta e modelo, que √© a camada que persiste os dados em um
banco de dados.</p></li>
</ul>
<figure>
<img src="figs/cap7/mvc-web.svg" style="width:75.0%"
alt="Arquitetura MVC Web" />
<figcaption aria-hidden="true">Arquitetura MVC Web</figcaption>
</figure>
<p>Logo, apesar de sistemas Web serem parecidos com sistemas tr√™s
camadas, os frameworks Web mais populares optaram por usar termos
t√≠picos de MVC para nomear seus componentes. Portanto, a melhor maneira
de responder √† pergunta √© afirmar que existem duas vertentes de sistemas
MVC: a vertente cl√°ssica, que surgiu com Smalltalk-80 e a vertente Web,
que se tornou comum na d√©cada de 90 e in√≠cio dos anos 2000. Essa √∫ltima
vertente lembra bastante sistemas tr√™s camadas.</p>
<h3 data-number="7.3.1" id="exemplo-single-page-applications"><span
class="header-section-number">7.3.1</span> Exemplo: Single Page
Applications <a href="#exemplo-single-page-applications"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Em uma aplica√ß√£o Web tradicional, com formul√°rios, menus e bot√µes,
toda vez que o usu√°rio gera um evento ‚Äî por exemplo, clica em um bot√£o
<q>Gravar</q> ‚Äî ocorre uma intera√ß√£o entre o navegador e o servidor Web.
Isto √©, o navegador envia informa√ß√µes para o servidor Web, que as
processa e devolve uma nova p√°gina para ser exibida para o usu√°rio.
Essas aplica√ß√µes s√£o ent√£o menos interativas e responsivas, devido ao
atraso da comunica√ß√£o entre navegador e servidor Web.</p>
<p> Recentemente, surgiu um novo tipo de sistema Web, chamado de
<strong>Single Page Applications (SPAs)</strong>. Essas aplica√ß√µes s√£o
mais parecidas com aplica√ß√µes desktop do que com aplica√ß√µes Web
tradicionais. Ao se entrar em uma SPA, ela carrega para o navegador todo
o c√≥digo, incluindo p√°ginas HTML e scripts em CSS e JavaScript. Com
isso, apesar de usar um navegador, o usu√°rio tem a impress√£o de que ele
est√° usando uma aplica√ß√£o local, pois n√£o ocorre mais uma atualiza√ß√£o da
p√°gina do navegador toda vez que ele gera certos eventos. Diversas
aplica√ß√µes modernas s√£o SPAs, sendo o GMail, provavelmente, o exemplo
mais conhecido. Evidentemente, continua existindo uma parte da aplica√ß√£o
no servidor, com a qual a SPA comunica-se frequentemente. Por exemplo,
quando chega um novo e-mail o GMail atualiza a lista de mensagens na
caixa de entrada. Para que isso ocorra de forma autom√°tica, a
comunica√ß√£o entre a SPA e o servidor deve ser ass√≠ncrona.</p>
<p> Existem diversos frameworks ‚Äî todos em JavaScript ‚Äî para
implementa√ß√£o de SPAs. A seguir, mostramos um exemplo usando Vue.js.</p>
<pre><code>&lt;html&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;

&lt;body&gt;

&lt;h3&gt;Uma Simples SPA&lt;/h3&gt;

&lt;div id=&quot;ui&quot;&gt;
  Temperatura: {{ temperatura }}
  &lt;p&gt;&lt;button v-on:click=&quot;incTemperatura&quot;&gt;Incrementa
  &lt;/button&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
var model = new Vue({
  el: &#39;#ui&#39;,
  data: {
    temperatura: 60
  },
  methods: {
    incTemperatura: function() {
      this.temperatura++;
    }
  }
})
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>Essa aplica√ß√£o apresenta uma temperatura na tela do navegador e um
bot√£o para increment√°-la (veja figura a seguir).</p>
<figure>
<img src="figs/cap7/spa.png" style="width:27.0%"
alt="Interface da Single-Page Application do exemplo" />
<figcaption aria-hidden="true">Interface da Single-Page Application do
exemplo</figcaption>
</figure>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo do exemplo est√° dispon√≠vel
neste <a
href="https://gist.github.com/mtov/ac1120c5b3e0a85d39bb7b05d20ee307">link</a>.
Se quiser executar a aplica√ß√£o no seu navegador, basta usar esse <a
href="https://engsoftmoderna.info/examples/vue.html">link</a>.</p>
<p>O interessante √© que SPAs seguem uma arquitetura parecida com MVC. No
exemplo mostrado, a interface da SPA, contendo vis√£o e controle, √©
implementada em HTML, mais precisamente no c√≥digo delimitado pela tag
&lt;div&gt;. O modelo √© implementado em JavaScript, usando-se Vue.js. O
c√≥digo do modelo est√° delimitado pela tag &lt;script&gt;.</p>
<p> Um segundo ponto interessante √© que o framework Vue.js se encarrega
de propagar para a vis√£o qualquer altera√ß√£o no modelo. Por exemplo,
quando o m√©todo <code>incTemperatura</code> √© executado, o valor da
temperatura √© automaticamente atualizado na interface. O processo
contr√°rio tamb√©m √© verdadeiro, apesar de n√£o ser exercitado em nosso
exemplo, que √© bem simples. Esse recurso de frameworks para constru√ß√£o
de SPAs √© chamado de <strong>two-way data binding</strong>.</p>
<h2 data-number="7.4" id="microsservi√ßos"><span
class="header-section-number">7.4</span> Microsservi√ßos <a
href="#microsservi√ßos" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Como discutimos no Cap√≠tulo 2, m√©todos √°geis preconizam itera√ß√µes
r√°pidas, com entregas frequentes de novas releases, a fim de obter
feedback e, se for preciso, efetuar mudan√ßas de rumo. Por√©m, mesmo que
uma empresa adote um m√©todo √°gil ‚Äî como Scrum ‚Äî ela vai enfrentar um
<q>gargalo</q> arquitetural quando precisar lan√ßar novas releases de um
produto de forma frequente.</p>
<p> Esse gargalo ocorre porque sistemas, via de regra, seguem em tempo
de execu√ß√£o uma arquitetura monol√≠tica. Ou seja, mesmo que o
desenvolvimento tenha sido particionado em m√≥dulos M1, M2, M3, ‚Ä¶, Mn, em
tempo de execu√ß√£o esses m√≥dulos s√£o executados, pelo sistema
operacional, como um processo √∫nico. Assim, todos os m√≥dulos
compartilham o mesmo espa√ßo de endere√ßamento. Em outras palavras, em
tempo de execu√ß√£o o sistema √© um grande <strong>monolito</strong>, como
ilustra a pr√≥xima figura.</p>
<figure>
<img src="figs/cap7/monolito.svg" style="width:37.0%"
alt="Monolito com nove m√≥dulos. Em tempo de execu√ß√£o, o sistema executa como um √∫nico processo, representado pelo quadrado que delimita os 9 m√≥dulos." />
<figcaption aria-hidden="true">Monolito com nove m√≥dulos. Em tempo de
execu√ß√£o, o sistema executa como um √∫nico processo, representado pelo
quadrado que delimita os 9 m√≥dulos.</figcaption>
</figure>
<p>Em um monolito, sempre existe o risco de que uma mudan√ßa realizada
por um time T em um m√≥dulo Mi cause um efeito colateral em um m√≥dulo Mj.
Por exemplo, Mi e Mj podem compartilhar uma vari√°vel global ou um
atributo est√°tico. Uma mudan√ßa nessa vari√°vel, realizada em Mi, pode
comprometer o funcionamento de Mj. Na realidade, esse risco √© maior do
que um leitor iniciante em desenvolvimento de sistemas pode
imaginar.</p>
<p>Para evitar que os clientes sejam surpreendidos com bugs inesperados
em seus sistemas, as empresas que usam arquiteturas monol√≠ticas adotam
um processo rigoroso e <q>burocr√°tico</q> para o lan√ßamento de novas
releases. Esse processo pode incluir at√© mesmo testes manuais antes da
libera√ß√£o do sistema para produ√ß√£o. Por testes manuais, queremos dizer
um testador usar as funcionalidades mais cr√≠ticas do sistema, de forma a
simular uma sess√£o de uso por um cliente final.</p>
<p>Para resolver esse gargalo ‚Äî o desenvolvimento passou a ser √°gil, mas
a entrada em produ√ß√£o permanece burocr√°tica ‚Äî, recentemente, algumas
empresas passaram a migrar os seus monolitos para uma arquitetura
baseada em <strong>microsservi√ßos</strong>. A ideia √© simples: certos
grupos de m√≥dulos s√£o executados em processos independentes, sem
compartilhamento de mem√≥ria. Ou seja, o sistema √© decomposto em m√≥dulos
n√£o apenas em tempo de desenvolvimento, mas tamb√©m em tempo de execu√ß√£o.
Com isso, as chances de que mudan√ßas em um m√≥dulo causem problemas em
outros m√≥dulos ficam bem menores.</p>
<p>Quando os m√≥dulos s√£o separados em processos distintos n√£o h√° mais
possibilidade de que um m√≥dulo acesse um recurso interno de outro
m√≥dulo, como uma vari√°vel global, um atributo est√°tico ou uma interface
interna. Em vez disso, por constru√ß√£o, toda comunica√ß√£o tem que ocorrer
via interfaces p√∫blicas dos m√≥dulos. Assim, microsservi√ßos s√£o um
instrumento para garantir que os times de desenvolvimento somente usem
interfaces p√∫blicas de outros sistemas. A obedi√™ncia √† essa regra √©
garantida pelo sistema operacional.</p>
<p>A pr√≥xima figura mostra uma vers√£o baseada em microsservi√ßos do nosso
exemplo. Nela, continuam existindo nove m√≥dulos. Mas eles s√£o executados
por seis processos independentes, representados pelos quadrados ou
ret√¢ngulos em volta dos m√≥dulos. Os m√≥dulos M1, M2, M3 e M6 s√£o
executados, cada um deles, em um processo independente. Os m√≥dulos M4 e
M5 s√£o executados em um quinto processo. Por fim, os m√≥dulos M7, M8 e M9
s√£o executados, em conjunto, em um sexto processo.</p>
<figure>
<img src="figs/cap7/microservices1.svg" style="width:37.0%"
alt="Servidor com seis microsservi√ßos: M1, M2, M3, M4-M5, M6, M7-M8-M9. Cada microsservi√ßo executa como um processo aut√¥nomo." />
<figcaption aria-hidden="true">Servidor com seis microsservi√ßos: M1, M2,
M3, M4-M5, M6, M7-M8-M9. Cada microsservi√ßo executa como um processo
aut√¥nomo.</figcaption>
</figure>
<p>At√© esse ponto da explica√ß√£o, usamos o termo processo, mas o nome do
padr√£o refere-se a eles como <strong>servi√ßos</strong>. Ainda, os
servi√ßos s√£o micro porque n√£o implementam funcionalidades complexas.
Lembre-se que eles s√£o desenvolvidos por times √°geis, que como dissemos
no Cap√≠tulo 2, s√£o times pequenos, com cerca de cinco desenvolvedores,
por exemplo. Consequentemente, times pequenos n√£o t√™m capacidade para
implementar grandes servi√ßos.</p>
<p> Uma segunda vantagem de microsservi√ßos √©
<strong>escalabilidade</strong>. Quando um monolito enfrenta problemas
de performance, uma solu√ß√£o consiste em disponibilizar inst√¢ncias do
sistema em m√°quinas diferentes, como mostra a pr√≥xima figura. Essa
solu√ß√£o √© chamada de <strong>escalabilidade horizontal</strong>. Por
exemplo, ela permite dividir os clientes do sistema entre as duas
inst√¢ncias mostradas na figura. Como se trata de um monolito, as duas
inst√¢ncias s√£o id√™nticas, isto √©, possuem os mesmos m√≥dulos.</p>
<figure>
<img src="figs/cap7/monolito2.svg" style="width:60.0%"
alt="Servidor 1, executando o monolito em um √∫nico processo. E Servidor 2, executando uma r√©plica do monolito." />
<figcaption aria-hidden="true">Servidor 1, executando o monolito em um
√∫nico processo. E Servidor 2, executando uma r√©plica do
monolito.</figcaption>
</figure>
<p>Por√©m, os problemas de performance podem ser causados por servi√ßos
espec√≠ficos; por exemplo, apenas pelo servi√ßo de autentica√ß√£o de
usu√°rios. Ent√£o, microsservi√ßos permitem replicar apenas os componentes
diretamente relacionados com tais problemas de performance. A pr√≥xima
figura mostra uma nova instala√ß√£o do nosso sistema baseado em
microsservi√ßos.</p>
<figure>
<img src="figs/cap7/escalabilidade.svg" style="width:60.0%"
alt="Servidor 1, com todos os microsservi√ßos, exceto M1. Servidor 2, executando seis processos, todos eles relativos a M1." />
<figcaption aria-hidden="true">Servidor 1, com todos os microsservi√ßos,
exceto M1. Servidor 2, executando seis processos, todos eles relativos a
M1.</figcaption>
</figure>
<p>O segundo servidor que foi disponibilizado inclui apenas inst√¢ncias
do servi√ßo M1. A suposi√ß√£o √© que M1 √© respons√°vel pela maior parte dos
problemas de performance da instala√ß√£o inicial. Na primeira instala√ß√£o,
t√≠nhamos uma √∫nica inst√¢ncia de M1. Agora, temos seis inst√¢ncias, todas
elas rodando em um novo servidor.</p>
<p>At√© o momento, listamos duas vantagens de microsservi√ßos: (1) eles
permitem a evolu√ß√£o mais r√°pida e independente de um sistema, permitindo
que cada time tenha seu pr√≥prio regime de libera√ß√£o de novas releases;
(2) eles permitem escalar um sistema em um n√≠vel de granularidade mais
fino do que √© poss√≠vel com monolitos. Mas existem pelo menos mais duas
vantagens:</p>
<ul>
<li><p>Como os microsservi√ßos s√£o aut√¥nomos e independentes eles podem
ser implementados em tecnologias diferentes, incluindo linguagens de
programa√ß√£o, frameworks e bancos de dados. O microsservi√ßo de cadastro
de clientes em um sistema de com√©rcio eletr√¥nico, por exemplo, pode ser
implementado em Java com um banco de dados relacional. J√° o
microsservi√ßo de recomenda√ß√£o de novas compras pode ser implementado em
Python com um banco de dados NoSQL.</p></li>
<li><p>Quando se usa um monolito, falhas s√£o totais. Se o banco de dados
cair, todos os servi√ßos ficam fora do ar. Por outro lado, em
arquiteturas baseadas em microsservi√ßos podemos ter <strong>falhas
parciais</strong>. Por exemplo, suponha que o microsservi√ßo de
recomenda√ß√£o de compras do exemplo do item anterior fique fora do ar. Os
clientes ainda conseguir√£o pesquisar por produtos, fazer compras, etc.
Mas eles ir√£o receber uma mensagem na √°rea de recomenda√ß√£o da p√°gina
dizendo que as recomenda√ß√µes est√£o desabilitadas; ou ent√£o, essa √°rea
ficar√° vazia; ou ainda, ela n√£o ser√° apresentada para os usu√°rios
durante o per√≠odo em que o microsservi√ßo de recomenda√ß√µes estiver fora
do ar.</p></li>
</ul>
<p>Arquiteturas baseadas em microsservi√ßos tornaram-se poss√≠veis devido
ao aparecimento de plataformas de <strong>computa√ß√£o em nuvem</strong>.
Com essas plataformas, empresas n√£o precisam mais comprar e manter
hardware e software b√°sico, como sistema operacional, bancos de dados e
servidores Web. Em vez disso, elas podem alugar uma m√°quina virtual em
uma plataforma de computa√ß√£o em nuvem e pagar por hora de utiliza√ß√£o da
m√°quina. Com isso, fica mais f√°cil escalar um microsservi√ßo
horizontalmente, acrescentando novas m√°quinas virtuais.</p>
<p> </p>
<p><strong>Aprofundamento</strong>: Microsservi√ßos constituem um exemplo
de aplica√ß√£o da <strong>Lei de Conway</strong>. Formulada em 1968 por
Melvin Conway, ela √© uma das leis emp√≠ricas sobre desenvolvimento de
software, assim como a Lei de Brooks, que estudamos no Cap√≠tulo 1. A Lei
de Conway afirma o seguinte: empresas tendem a adotar arquiteturas de
software que s√£o c√≥pias de suas estruturas organizacionais. Em outras
palavras, a arquitetura dos sistemas de uma empresa tende a espelhar seu
organograma. Por isso, n√£o √© coincid√™ncia que microsservi√ßos sejam
usados, principalmente, por grandes empresas de Internet que possuem
centenas de times de desenvolvimento distribu√≠dos em diversos pa√≠ses.
Al√©m de descentralizados, esses times s√£o aut√¥nomos e sempre
incentivados a produzir inova√ß√µes.</p>
<h3 data-number="7.4.1" id="gerenciamento-de-dados"><span
class="header-section-number">7.4.1</span> Gerenciamento de Dados <a
href="#gerenciamento-de-dados" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Pelo menos na sua forma pura, microsservi√ßos devem ser aut√¥nomos
tamb√©m do ponto de vista de dados. Isto √©, eles devem gerenciar os dados
de que precisam para prover o seu servi√ßo. Logo, o cen√°rio ilustrado
pela figura a seguir ‚Äî no qual dois microsservi√ßos compartilham o mesmo
banco de dados ‚Äî n√£o √© recomend√°vel em uma arquitetura baseada em
microsservi√ßos.</p>
<p><img src="figs/cap7/dados1.svg" style="width:27.0%" /></p>
<p>O ideal √© que M1 e M2 sejam independentes tamb√©m do ponto de vista de
bancos de dados, com mostrado na pr√≥xima figura. O principal motivo √©
que quando se t√™m um √∫nico banco de dados ele tamb√©m pode se transformar
em um gargalo √† evolu√ß√£o do sistema.</p>
<p><img src="figs/cap7/dados2.svg" style="width:27.0%" /></p>
<p>Por exemplo, equipes e arquiteturas tradicionais de desenvolvimento
costumam ter um administrador de dados, a quem cabe cuidar das tabelas
do banco de dados. Qualquer mudan√ßa no banco de dados ‚Äî como a cria√ß√£o
de uma coluna em uma tabela ‚Äî precisa da aprova√ß√£o do administrador de
dados. Logo, essa autoridade central tem que conciliar os interesses,
muitas vezes conflitantes, das diversas equipes de desenvolvimento. Por
isso, suas decis√µes podem se tornar lentas e burocr√°ticas, atrasando a
evolu√ß√£o do sistema.</p>
<h3 data-number="7.4.2" id="quando-n√£o-usar-microsservi√ßos"><span
class="header-section-number">7.4.2</span> Quando N√£o Usar
Microsservi√ßos? <a href="#quando-n√£o-usar-microsservi√ßos"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p></p>
<p>At√© esse momento, apresentamos as vantagens e benef√≠cios de
microsservi√ßos. Mas √© importante dizer que essa arquitetura √© mais
complexa do que uma arquitetura monol√≠tica. O motivo √© que
microsservi√ßos s√£o processos independentes, isto √©, eles por constru√ß√£o
d√£o origem a sistemas distribu√≠dos. Logo, ao usar microsservi√ßos, temos
que enfrentar todos os desafios que aparecem quando se implementa um
sistema distribu√≠do. Dentre eles, podemos citar:</p>
<ul>
<li><p>Complexidade: quando dois m√≥dulos executam em um mesmo processo,
a comunica√ß√£o entre eles √© por meio de chamadas de m√©todos. Quando esses
m√≥dulos est√£o em m√°quinas diferentes, a comunica√ß√£o entre eles deve usar
algum protocolo de comunica√ß√£o, como <strong>HTTP/REST</strong>. Ou
seja, os desenvolvedores ter√£o que dominar e usar um conjunto de
tecnologias para comunica√ß√£o em redes.</p></li>
<li><p>Lat√™ncia: a comunica√ß√£o entre microsservi√ßos tamb√©m envolve um
atraso maior, que chamamos de <strong>lat√™ncia</strong>. Quando um
cliente chama um m√©todo em um sistema monol√≠tico, a lat√™ncia √© m√≠nima.
Por exemplo, √© raro um desenvolvedor deixar de usar uma chamada de
m√©todo apenas para melhorar o desempenho de seu sistema. Por√©m, esse
cen√°rio muda quando o servi√ßo chamado est√° em uma outra m√°quina, talvez
do outro lado do planeta no caso de uma empresa global. Nessas
situa√ß√µes, existe um custo de comunica√ß√£o que n√£o √© desprez√≠vel.
Qualquer que seja o protocolo de comunica√ß√£o usado, essa chamada ter√°
que passar pelo cabo da rede ‚Äî ou pelo ar e pela fibra √≥tica ‚Äî at√©
chegar √† m√°quina de destino.</p></li>
<li><p>Transa√ß√µes Distribu√≠das: Como vimos, microsservi√ßos devem ser
aut√¥nomos tamb√©m do ponto de vista de dados. Isso torna mais complexo
garantir que opera√ß√µes que operam em dois ou mais bancos de dados sejam
at√¥micas, isto √©, ou elas executam com sucesso em todos os bancos ou
ent√£o falham. Suponha, por exemplo, dois microsservi√ßos de pagamento via
cart√£o de cr√©dito, que vamos chamar de X e Y. Suponha que uma loja
virtual permita dividir o valor da compra entre os dois cart√µes. Por
exemplo, uma compra de R$ 2.000,00 pode ser paga debitando-se R$
1.500,00 no cart√£o X e R$ 500,00 no cart√£o Y. Por√©m, essas transa√ß√µes
devem ser at√¥micas: ou os dois cart√µes s√£o debitados ou nenhum deles √©
debitado. Por isso, em arquiteturas baseadas em microsservi√ßos,
protocolos de transa√ß√µes distribu√≠das, como <strong>two-phase
commit</strong>, podem ser necess√°rios para garantir uma sem√¢ntica de
transa√ß√µes em opera√ß√µes que escrevem em mais de um banco de
dados.</p></li>
</ul>
<h2 data-number="7.5" id="arquiteturas-orientadas-a-mensagens"><span
class="header-section-number">7.5</span> Arquiteturas Orientadas a
Mensagens <a href="#arquiteturas-orientadas-a-mensagens"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Neste tipo de arquitetura, a comunica√ß√£o entre clientes e servidores
√© mediada por um terceiro servi√ßo que tem a √∫nica fun√ß√£o de prover uma
<strong>fila de mensagens</strong>, como mostra a pr√≥xima figura.</p>
<figure>
<img src="figs/cap7/mom.svg" style="width:80.0%"
alt="Arquitetura Orientada a Mensagens" />
<figcaption aria-hidden="true">Arquitetura Orientada a
Mensagens</figcaption>
</figure>
<p>Os clientes atuam como produtores de informa√ß√µes, isto √©, eles
inserem mensagens na fila. E os servidores atuam como consumidores de
mensagens, isto √©, eles retiram mensagens da fila e processam a
informa√ß√£o contida nelas. Uma mensagem √© um registro (ou um objeto) com
um conjunto de dados. E uma fila de mensagens √© uma estrutura do tipo
FIFO (<em>first in, first out</em>), isto √©, a primeira mensagem a
entrar na fila √© a primeira a ser consumida pelo servidor.</p>
<p>Com o uso de filas de mensagens, a comunica√ß√£o pelo lado do cliente
torna-se <strong>ass√≠ncrona</strong>, pois uma vez que a informa√ß√£o seja
colocada na fila, o cliente est√° liberado para continuar seu
processamento. Por isso, √© importante que o servi√ßo de mensagens seja
instalado em uma m√°quina est√°vel e com alto poder de processamento.
Tamb√©m √© importante que a fila de mensagens seja persistente. Se o
servidor que gerencia a fila cair, os dados n√£o podem ser perdidos. Como
filas de mensagens s√£o muito usadas na constru√ß√£o de sistemas
distribu√≠dos, existem solu√ß√µes prontas no mercado. Ou seja,
provavelmente voc√™ n√£o vai implementar sua pr√≥pria fila de mensagens,
mas usar solu√ß√µes de empresas conhecidas ou ent√£o mantidas por funda√ß√µes
de desenvolvimento de sistemas de c√≥digo aberto. Algumas vezes, filas de
mensagens s√£o chamadas tamb√©m de <strong>brokers</strong> de
mensagens.</p>
<p>Al√©m de permitirem comunica√ß√£o ass√≠ncrona entre clientes e
servidores, filas de mensagens viabilizam duas formas de desacoplamento
entre os componentes de uma aplica√ß√£o distribu√≠da:</p>
<ul>
<li><p><strong>Desacoplamento no espa√ßo</strong>: clientes n√£o precisam
conhecer os servidores e vice-versa. Em outras palavras, o cliente √©
exclusivamente um produtor de informa√ß√µes. Mas ele n√£o precisa saber
quem vai consumir essa informa√ß√£o. O racioc√≠nio inverso vale para
servidores.</p></li>
<li><p><strong>Desacoplamento no tempo</strong>: clientes e servidores
n√£o precisam estar simultaneamente dispon√≠veis para se comunicarem. Se o
servidor estiver fora do ar, os clientes podem continuar produzindo
mensagens e colocando-as na fila. Quando o servidor voltar a funcionar,
ele ir√° processar essas mensagens.</p></li>
</ul>
<p>Desacoplamento no espa√ßo torna solu√ß√µes baseadas em filas de
mensagens bastante flex√≠veis. Os times de desenvolvimento ‚Äî tanto do
sistema cliente, como do sistema servidor ‚Äî podem trabalhar e evoluir
seus sistemas com autonomia. Atrasos de um time n√£o travam a evolu√ß√£o de
outros times, por exemplo. Para isso, basta que o formato das mensagens
permane√ßa est√°vel ao longo do tempo. J√° desacoplamento no tempo torna a
solu√ß√£o robusta a falhas. Por exemplo, quedas do servidor n√£o t√™m
impacto nos clientes. No entanto, √© importante que o broker de mensagens
seja est√°vel e capaz de armazenar uma grande quantidade de mensagens.
Para garantir a disponibilidade desses brokers, eles costumam ser
gerenciados pelos times de infraestrutura b√°sica das empresas.</p>
<p>Filas de mensagens permitem tamb√©m escalar mais facilmente um sistema
distribu√≠do. Para isso, basta configurar m√∫ltiplos servidores consumindo
mensagens da mesma fila, como mostra a pr√≥xima figura.</p>
<figure>
<img src="figs/cap7/mom2.svg" style="width:80.0%"
alt="Fila de Mensagens com v√°rios consumidores" />
<figcaption aria-hidden="true">Fila de Mensagens com v√°rios
consumidores</figcaption>
</figure>
<h3 data-number="7.5.1" id="exemplo-empresa-de-telecomunica√ß√µes"><span
class="header-section-number">7.5.1</span> Exemplo: Empresa de
Telecomunica√ß√µes <a href="#exemplo-empresa-de-telecomunica√ß√µes"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p>Suponha que uma empresa de telecomunica√ß√µes tenha dois sistemas
principais: vendas e engenharia. O sistema de vendas √© respons√°vel pela
intera√ß√£o com os clientes da empresa, incluindo vendas de pacotes de
voz, dados e TV a cabo. Por outro lado, o sistema de engenharia √©
respons√°vel por ativar e configurar os servi√ßos contratados, interagindo
para isso com os equipamentos da empresa, tais como centrais
telef√¥nicas, esta√ß√µes de celulares, roteadores, etc. Portanto, quando um
servi√ßo √© contratado no sistema de vendas, ele tem que ser provisionado
no sistema de engenharia.</p>
<p>Essa empresa de telecomunica√ß√µes pode usar uma fila de mensagens para
mediar a comunica√ß√£o entre o sistema de vendas e o sistema de
engenharia. Ao se vender um novo pacote de servi√ßos, o sistema de vendas
ir√° depositar uma mensagem na fila de mensagens, com as informa√ß√µes do
pacote. Cabe ao sistema de engenharia ler essa mensagem e ativar o
servi√ßo que foi vendido.</p>
<p> Ao optar por uma fila de mensagens, a integra√ß√£o entre os sistemas
de vendas e de engenharia pode n√£o ocorrer em tempo real. Por exemplo,
se o servi√ßo de engenharia estiver ocupado, com v√°rias ativa√ß√µes
complexas de servi√ßos pendentes, pode demorar um pouco at√© que um
determinado servi√ßo seja ativado. Por outro lado, a solu√ß√£o com fila de
mensagens permite ativar os servi√ßos mais rapidamente do que por meio de
uma solu√ß√£o <strong>batch</strong>. Nesse tipo de solu√ß√£o, o sistema de
vendas geraria ao final de cada dia um arquivo com todos os pacotes
vendidos. Esse arquivo seria processado durante a noite pelo sistema de
engenharia. Portanto, um cliente poderia ter que esperar quase 24 horas
para ter seu servi√ßo ativado.</p>
<h2 data-number="7.6" id="arquiteturas-publishsubscribe"><span
class="header-section-number">7.6</span> Arquiteturas Publish/Subscribe
<a href="#arquiteturas-publishsubscribe" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> Em arquiteturas publish/subscribe, as mensagens s√£o chamadas de
<strong>eventos</strong>. Os componentes da arquitetura s√£o chamados de
<strong>publicadores</strong> (<em>publishers</em>) e
<strong>assinantes</strong> (<em>subscribers</em>) de eventos.
Publicadores produzem eventos e os publicam no servi√ßo de
publish/subscribe, que normalmente executa em uma m√°quina separada.
Assinantes devem previamente assinar eventos de seu interesse. Quando um
evento √© publicado, os seus assinantes s√£o notificados, conforme mostra
a pr√≥xima figura.</p>
<figure>
<img src="figs/cap7/pubsub.svg" style="width:80.0%"
alt="Arquitetura Publish/Subscribe" />
<figcaption aria-hidden="true">Arquitetura
Publish/Subscribe</figcaption>
</figure>
<p>Assim como ocorre quando se usa filas de mensagens, arquiteturas
publish/subscribe tamb√©m oferecem desacoplamento no espa√ßo e no tempo.
No entanto, existem duas diferen√ßas principais entre publish/subscribe e
sistemas baseados em filas de mensagens:</p>
<ul>
<li><p>Em publish/subscribe, um evento gera notifica√ß√µes em todos os
seus assinantes. Por outro lado, em filas de mensagens, as mensagens s√£o
sempre consumidas ‚Äî isto √©, retiradas da fila ‚Äî por um √∫nico servidor.
Portanto, em publish/subscribe temos um estilo de comunica√ß√£o de 1 para
<em>n</em>, tamb√©m conhecido como <strong>comunica√ß√£o em grupo</strong>.
J√° em filas de mensagens, a comunica√ß√£o √© 1 para 1, tamb√©m chamada de
<strong>comunica√ß√£o ponto-a-ponto</strong>.</p></li>
<li><p>Em publish/subscribe, os assinantes s√£o notificados
assincronamente. Primeiro, eles assinam certos eventos e, ent√£o,
continuam seu processamento. Quando o evento de interesse ocorre, eles
s√£o notificados por meio da execu√ß√£o de um determinado m√©todo. Por outro
lado, quando se usa uma fila de mensagens, os servidores ‚Äî isto √©, os
consumidores das mensagens ‚Äî t√™m que <q>puxar</q> (<em>pull</em>) as
mensagens da fila.</p></li>
</ul>
<p>Em alguns sistemas publish/subscribe, eventos s√£o organizados em
<strong>t√≥picos</strong>, que funcionam como categorias de eventos.
Quando um publicador produz um evento, ele deve informar seu t√≥pico.
Assim, clientes n√£o precisam assinar todos os eventos que ocorrem no
sistema, mas apenas eventos de um determinado t√≥pico.</p>
<p> Arquiteturas publish/subscribe s√£o, √†s vezes, chamadas de
<strong>arquiteturas orientadas a eventos</strong>. O servi√ßo de
publish/subscribe, √†s vezes, √© chamado tamb√©m de <strong>broker de
eventos</strong>, pois ele funciona como um barramento por onde devem
trafegar todos os eventos. √â importante mencionar ainda que um sistema
publish/subscribe lembra o padr√£o de projeto
<strong>Observador</strong>, que estudamos no Cap√≠tulo 6. No entanto,
publish/subscribe √© uma solu√ß√£o para implementa√ß√£o de sistemas
distribu√≠dos. Ou seja, produtores e assinantes s√£o processos distintos
e, na maioria das vezes, distribu√≠dos. Por outro lado, o padr√£o de
projeto Observador n√£o foi proposto no contexto de arquiteturas
distribu√≠das.</p>
<h3 data-number="7.6.1" id="exemplo-companhia-a√©rea"><span
class="header-section-number">7.6.1</span> Exemplo: Companhia A√©rea <a
href="#exemplo-companhia-a√©rea" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p>Vamos agora usar os sistemas de uma companhia a√©rea para ilustrar uma
arquitetura publish/subscribe. Suponha que essa companhia tem um sistema
de vendas, que √© usado pelos clientes para comprar passagens a√©reas.
Ap√≥s efetuar uma venda, esse sistema pode gerar um evento com todos os
dados da opera√ß√£o, tais como data, hor√°rio, n√∫mero do v√¥o e dados do
passageiro. A figura a seguir ilustra a arquitetura proposta para o
sistema.</p>
<figure>
<img src="figs/cap7/ciaaerea.svg" style="width:80.0%"
alt="Arquitetura Pub/Sub em uma companhia a√©rea" />
<figcaption aria-hidden="true">Arquitetura Pub/Sub em uma companhia
a√©rea</figcaption>
</figure>
<p>O evento <q>venda</q> ser√° ent√£o assinado por tr√™s sistemas da
companhia a√©rea: (1) sistema de milhagens, pois as milhas relativas √†
passagem devem ser creditadas na conta do passageiro; (2) sistema de
marketing, que pode usar os dados da venda para fazer ofertas para o
cliente, como aluguel de carros ou promo√ß√£o para classe executiva; (3)
Sistema de contabilidade, pois a venda que foi realizada precisa ser
inclu√≠da na contabilidade da empresa.</p>
<p>Essa arquitetura tem as seguintes caracter√≠sticas interessantes: (1)
comunica√ß√£o em grupo, pois o mesmo evento √© assinado por tr√™s sistemas;
(2) desacoplamento no espa√ßo, pois o sistema de vendas n√£o tem
conhecimento dos sistemas interessados nos eventos que ele publica; (3)
desacoplamento no tempo, pois o sistema de publish/subscribe reenvia os
eventos caso os sistemas assinantes estejam fora do ar; (4) notifica√ß√£o
ass√≠ncrona, pois os assinantes s√£o notificados assim que um evento
ocorre; isto √©, eles n√£o precisam consultar periodicamente o sistema
publish/subscribe sobre a ocorr√™ncia dos eventos de interesse.</p>
<h2 data-number="7.7" id="outros-padr√µes-arquiteturais"><span
class="header-section-number">7.7</span> Outros Padr√µes Arquiteturais <a
href="#outros-padr√µes-arquiteturais" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Pipes e Filtros</strong> √© um tipo de arquitetura orientada a
dados, na qual os programas ‚Äî chamados de <strong>filtros</strong> ‚Äî t√™m
como fun√ß√£o processar os dados recebidos na entrada e gerar uma nova
sa√≠da. Os filtros s√£o conectados por meio de <strong>pipes</strong>, que
agem como buffers. Isto √©, pipes s√£o usados para armazenar a sa√≠da de um
filtro, enquanto ela n√£o √© lida pelo pr√≥ximo filtro da sequ√™ncia. Com
isso, os filtros n√£o precisam conhecer seus antecessores e sucessores, o
que torna esse tipo de arquitetura bastante flex√≠vel, permitindo as mais
variadas combina√ß√µes de programas. Al√©m disso, por constru√ß√£o, filtros
podem ser executados em paralelo. O exemplo cl√°ssico de arquitetura
baseada em pipes e filtros s√£o os comandos de sistemas Unix. Por
exemplo, a linha de comando:</p>
<p><code>ls | grep csv | sort</code></p>
<p>especifica a execu√ß√£o de tr√™s comandos (filtros) que s√£o conectados
por dois pipes (barras verticais). No caso dos comandos Unix, as
entradas e sa√≠das s√£o sempre arquivos texto.</p>
<p> <strong>Cliente/Servidor</strong> √© uma arquitetura muito usada na
implementa√ß√£o de servi√ßos b√°sicos de rede. Clientes e servidores s√£o os
dois √∫nicos m√≥dulos desse tipo de arquitetura e eles se comunicam por
meio de uma rede. Os clientes solicitam servi√ßos ao m√≥dulo servidor e
aguardam o processamento. Arquiteturas cliente/servidor s√£o usadas para
implementar servi√ßos como os seguintes: (1) servi√ßo de impress√£o, que
possibilita que clientes imprimam em uma impressora remota, que n√£o est√°
fisicamente conectada √† m√°quina deles; (2) servi√ßo de arquivos, que
possibilita que clientes acessem o sistema de arquivos (isto √©, o disco)
de uma m√°quina servidora; (3) servi√ßo de bancos de dados, que permite
que clientes acessem um banco de dados instalado em uma outra m√°quina;
(4) servi√ßo Web, que permite que clientes (no caso, navegadores) acessem
recursos (no caso, p√°ginas HTML) armazenadas e providas por um servidor
Web.</p>
<p> Arquiteturas <strong>peer-to-peer</strong> s√£o arquiteturas
distribu√≠das nas quais os m√≥dulos da aplica√ß√£o podem desempenhar tanto o
papel de cliente, como o papel de servidor. Em outras palavras, esses
m√≥dulos ‚Äî chamados de <strong>pares</strong> ‚Äî s√£o tanto consumidores
como provedores de recursos. Por exemplo, BitTorrent √© um protocolo
peer-to-peer para compartilhamento de arquivos na Internet. Aplica√ß√µes
que implementam o protocolo podem tanto prover arquivos como realizar o
download de arquivos dispon√≠veis na rede.</p>
<h2 data-number="7.8" id="anti-padr√µes-arquiteturais"><span
class="header-section-number">7.8</span> Anti-padr√µes Arquiteturais <a
href="#anti-padr√µes-arquiteturais" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Vamos encerrar este cap√≠tulo com a descri√ß√£o de um
<strong>anti-padr√£o</strong> arquitetural, isto √©, uma organiza√ß√£o de
sistemas que n√£o √© recomendada. Talvez, o mais conhecido anti-padr√£o √©
chamado de <strong>big ball of mud</strong> (ou <q>grande bola de
lama</q>). Esse anti-padr√£o ‚Äî proposto por Brian Foote e Joseph Yoder
(<a href="https://joeyoder.com/PDFs/mud.pdf">link</a>) ‚Äî descreve
sistemas nos quais qualquer m√≥dulo comunica-se com praticamente qualquer
outro m√≥dulo, como mostra a pr√≥xima figura. Ou seja, um <q>big ball of
mud</q> n√£o possui uma arquitetura definida. Em vez disso, o que existe
√© uma explos√£o no n√∫mero de depend√™ncias, que d√° origem a um espaguete
de c√≥digo. Consequentemente, a manuten√ß√£o do sistema torna-se muito
dif√≠cil e arriscada.</p>
<figure>
<img src="figs/cap7/big-ball-mud.svg" style="width:50.0%"
alt="Anti-padr√£o big ball of mud" />
<figcaption aria-hidden="true">Anti-padr√£o <em>big ball of
mud</em></figcaption>
</figure>
<p></p>
<p><strong>Mundo Real</strong>: Em um artigo publicado em 2009 na
revista IEEE Software (<a
href="https://doi.org/10.1109/MS.2009.42">link</a>), Santonu Sarkar e
mais cinco colegas ‚Äî na √©poca consultores da empresa indiana InfoSys ‚Äî
descrevem uma experi√™ncia de modulariza√ß√£o de um grande sistema
banc√°rio. O sistema nasceu no final da d√©cada de 90 e desde ent√£o
aumentou seu tamanho em 10 vezes: passou de 2.5 milh√µes para mais de 25
milh√µes de linhas de c√≥digo! Segundo os autores, os times de
desenvolvimento do sistema contavam com <q>v√°rias centenas de
engenheiros</q>. Apesar de n√£o usarem o termo, o artigo caracteriza a
arquitetura desse sistema banc√°rio como uma <q>big ball of mud</q>. Por
exemplo, os autores mencionam que apenas um diret√≥rio, chamado
<q>sources</q>, possu√≠a quase 15 mil arquivos. Em seguida, eles analisam
o problema que era manter esse sistema: (1) o tempo de aprendizado de
novos engenheiros s√≥ aumentava, passando de tr√™s para sete meses, no
intervalo de cinco anos; (2) frequentemente, a corre√ß√£o de bugs
introduzia novos bugs no sistema; (3) o tempo de implementa√ß√£o de novas
funcionalidades, mesmo que simples, tamb√©m estava aumentando muito.</p>
<p>Pode parecer que sistemas como esse ‚Äî analisado no artigo da IEEE
Software ‚Äî s√£o exce√ß√µes. Por√©m, eles s√£o mais comuns do que se pode
imaginar. E a origem do problema reside na transforma√ß√£o do c√≥digo em
uma <q>big ball of mud</q>. De forma interessante, os autores citam que
o banco tentou contornar o problema adotando pr√°ticas como documenta√ß√£o
detalhada, revis√µes de c√≥digo e programa√ß√£o em pares. Por√©m, todas se
mostraram incapazes de atenuar os problemas causados pela arquitetura em
forma de <q>big ball of mud</q>.</p>
<h2 class="unnumbered" id="bibliografia">Bibliografia <a
href="#bibliografia" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>James Lewis, Martin Fowler. Microservices: a definition of this new
architectural term. Blog post, 2014.</p>
<p>Martin Fowler. Patterns of Enterprise Application Architecture,
Addison-Wesley, 2002.</p>
<p>Martin Fowler. Who Needs an Architect, IEEE Software, vol.¬†20, issue
5, p.¬†11-13, 2003.</p>
<p>Patrick Eugster et al.¬†The many faces of publish/subscribe. ACM
Computing Surveys, vol.¬†35, issue 2, p.¬†114-131, 2003.</p>
<p>Glenn Krasner, Stephen Pope. A cookbook for using the model-view
controller user interface paradigm in Smalltalk-80. Journal of
Object-Oriented Programming, vol.¬†1, issue 3, p.¬†26-49, 1988.</p>
<p>Kevlin Henney, Frank Buschmann, Douglas Schmidt. Pattern-Oriented
Software Architecture: A Pattern Language for Distributed Computing,
vol.¬†4, John Wiley &amp; Sons, 2007.</p>
<h2 class="unnumbered" id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o
<a href="#exerc√≠cios-de-fixa√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>1. Dada a sua complexidade, sistemas de bancos de dados s√£o
componentes relevantes na arquitetura de qualquer tipo de sistema.
Verdadeiro ou falso? Justifique a sua resposta.</p>
<p>2. Descreva tr√™s vantagens de arquiteturas MVC.</p>
<p>3. Qual a diferen√ßa entre classes Controladoras em uma Arquitetura
MVC tradicional e classes Controladoras de um sistema Web implementado
usando um framework MVC como Ruby on Rails?</p>
<p>4. Descreva resumidamente quatro vantagens de microsservi√ßos.</p>
<p>5. Por que microsservi√ßos n√£o s√£o uma bala de prata? Isto √©, descreva
pelo menos tr√™s desvantagens do uso de microsservi√ßos.</p>
<p>6. Explique a rela√ß√£o entre a Lei de Conway e microsservi√ßos.</p>
<p>7. Explique o que significa desacoplamento no espa√ßo e desacoplamento
no tempo. Por que arquiteturas baseadas em filas de mensagens e
arquiteturas Publish/Subscribe oferecem essas formas de
desacoplamento?</p>
<p>8. Quando uma empresa deve considerar o uso de uma arquitetura
baseada em filas de mensagens ou uma arquitetura publish/subscribe?</p>
<p>9. Explique o objetivo do conceito de t√≥picos em uma arquitetura
publish/subscribe.</p>
<p>10. (POSCOMP, 2019, adaptado) Marque V ou F.</p>
<p>( ) O padr√£o MVC √© uma adapta√ß√£o do padr√£o arquitetural Camadas. A
Camada Vis√£o lida com a apresenta√ß√£o e a manipula√ß√£o da interface, a
Camada Modelo organiza os objetos espec√≠ficos da aplica√ß√£o, e a Camada
Controle posiciona-se entre estas duas com as regras do neg√≥cio.</p>
<p>( ) O padr√£o Broker √© voltado a problemas de ambientes distribu√≠dos.
Sugere uma arquitetura na qual um componente (broker) estabelece uma
media√ß√£o que permite um desacoplamento entre clientes e servidores.</p>
<p>( ) Mesmo que um dado padr√£o arquitetural ofere√ßa uma solu√ß√£o para o
problema sendo resolvido, nem sempre ele √© adequado. Fatores como
contexto e o sistema de for√ßas que afeta a solu√ß√£o fazem tamb√©m parte do
processo de avalia√ß√£o e da escolha de padr√µes adequados.</p>
<h2 class="unnumbered">Perguntas Frequentes</h2>
<p>Veja tamb√©m o <a href="./faq/arquitetura-faq.html">FAQ</a> deste cap√≠tulo.</p>
<button onclick="darkMode()">Modo noturno</button>

<script>
function darkMode() {
   var element = document.body;
   element.classList.toggle("dark-mode");
}
</script>

</div>
</div>
</div>

<footer>
Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formul√°rio</a>.
</footer>
</body>
</html>
