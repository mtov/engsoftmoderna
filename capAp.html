<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Apêndice A: Git – Engenharia de Software Moderna	(Livro Digital)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    q { quotes: "“" "”" "‘" "’"; }
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-8249107-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-8249107-3');
  </script>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.1/mini-default.min.css">

  <style>
  body {
    background-color: #FFFFFF;
    foreground-color: black;
  }
  </style>
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-8 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info"><img src="https://engsoftmoderna.info/figs/capa/foto-capitulos-html.png" width="240"></a>
</p>

<p>
<a href="https://engsoftmoderna.info">Página principal do livro</a>
</p>


<p>
<a href="https://twitter.com/engsoftmoderna?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-size="large" data-lang="pt" data-show-count="true">Follow @engsoftmoderna</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</p>


<!---

<p> <b> Novidade:</b> Estamos também no 
<a href="https://twitter.com/engsoftmoderna"
  onclick="trackOutboundLink('https://twitter.com/engsoftmoderna', 'twitter', 'twitter'); return false;">
  Twitter</a>.
</p>

--->


<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna (Livro Digital)</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="1" id="git" data-number="1"><span class="header-section-number">1</span> Git</h1>
<blockquote>
<p><em>The best way to learn git is probably to first only do very basic things and not even look at some of the things you can do until you are familiar and confident about the basics.</em> – Linus Torvalds</p>
</blockquote>
<p>  Neste apêndice, apresentamos e discutimos exemplos de uso do sistema Git, que é o sistema de controle de versões mais usado atualmente. Inspirados pela frase acima, de Linus Torvalds, criador do Git, vamos focar nos conceitos e comandos básicos desse sistema. Como sugere a frase, é importante dominar esses comandos antes de se aventurar no uso de comandos mais avançados. Caso o leitor não tenha conhecimento dos objetivos e vantagens proporcionados por um sistema de controle de versões, recomendamos primeiro a leitura da seção <q>Controle de Versões</q>, do Capítulo 10 deste livro.</p>
<h2 data-number="1.1" id="init-clone" data-number="1.1"><span class="header-section-number">1.1</span> Init &amp; Clone</h2>
<p> </p>
<p>Para começar a usar o git para gerenciar as versões de um sistema devemos executar um dos seguintes comandos: <strong>init</strong> ou <strong>clone</strong>. O comando <code>init</code> cria um repositório vazio. O segundo comando — <code>clone</code> — primeiro chama <code>init</code> para criar um repositório vazio. Em seguida, ele copia para esse repositório todos os commits de um repositório remoto, passado como parâmetro. Seja, por exemplo, o seguinte comando:</p>
<p><code>git clone https://github.com/NOME-USER/NOME-REPO</code></p>
<p>Esse comando clona para o diretório corrente um repositório armazenado remotamente no GitHub. Portanto, devemos usar clone quando vamos trabalhar em um projeto que já está em andamento e que já possui commits em um repositório central. No exemplo, esse repositório é disponibilizado pelo GitHub.</p>
<h2 data-number="1.2" id="commit" data-number="1.2"><span class="header-section-number">1.2</span> Commit</h2>
<p></p>
<p>Commits são usados para criar snapshots (ou fotografias) dos arquivos de um sistema. Uma vez tiradas essas fotografias, elas são armazenadas no sistema de controle de versões, de forma compactada e otimizada, para não ocupar muito espaço em disco. Posteriormente, pode-se recuperar qualquer uma das fotografias, para, por exemplo, restaurar uma implementação antiga de um determinado arquivo.</p>
<p>Recomenda-se que desenvolvedores realizem commits periodicamente, sempre que tiverem efetuado uma mudança importante no código. Em sistemas de controle de versões distribuídos, como o git, os commits são primeiro armazenados no repositório local do desenvolvedor. Por isso, o custo de um commit é pequeno e, portanto, desenvolvedores podem realizar diversos commits ao longo de um dia de trabalho. Na verdade, o que não é recomendável é a realização de commits grandes, com modificações importantes em diversos arquivos. Também não recomenda-se que um commit inclua modificações relativas a mais de uma tarefa de manutenção. Por exemplo, não é recomendável corrigir dois bugs em um mesmo commit. Em vez disso, cada bug deve ser corrigido em um commit separado. Assim, facilita-se uma futura análise do código, caso, por exemplo, um cliente volte a reclamar que seu bug não foi corrigido.</p>
<p>Commits também possuem metadados, incluindo data, hora, autor e uma mensagem, que descreve a modificação realizada pelo commit. A próxima figura mostra uma página do GitHub que exibe os metadados principais de um commit do repositório google/guava. Pode-se observar que o commit refere-se a um refactoring, o que fica claro no seu título. Em seguida, o refactoring é explicado em detalhes na mensagem do commit. Na última linha da figura, podemos ver o nome do autor do commit e a informação de que ele foi realizado há 13 dias.</p>
<figure>
<img src="figs/capAp/commit.png" style="width:93.0%" alt="" /><figcaption>Commit no GitHub</figcaption>
</figure>
<p>Na última linha da figura também podemos observar que todo commit possui um identificador único, no caso:</p>
<p><code>1c757483665f0ba8fed31a2af7e31643a4590256</code></p>
<p>Esse identificador possui 20 bytes, normalmente representados em hexadecimal. Esses bytes correspondem a uma verificação de consistência (<em>check sum</em>) do conteúdo do commit, conforme computado por uma função hash SHA-1.</p>
<h2 data-number="1.3" id="add" data-number="1.3"><span class="header-section-number">1.3</span> Add</h2>
<p></p>
<p>Na máquina local, o sistema git manipula três áreas distintas:</p>
<ul>
<li><p>Um <strong>diretório de trabalho</strong>,  onde devemos salvar os arquivos que pretendemos versionar. Às vezes, essa área é chamada também de árvore de trabalho (<em>working tree</em>).</p></li>
<li><p>O <strong>repositório</strong> propriamente dito, que armazena o histórico de commits.</p></li>
<li><p>Uma área intermediária, chamada de <strong>index</strong> ou <strong>stage</strong>, que    armazena temporariamente os arquivos que se pretende versionar. Tais arquivos são ditos rastreáveis (<strong>tracked)</strong>.</p></li>
</ul>
<p>Dentre essas três áreas, o desenvolvedor acessa apenas o diretório de trabalho, que funciona como um diretório comum do sistema operacional. As duas outras áreas são internas ao git e manipuladas exclusivamente por ele. Como qualquer diretório, o diretório de trabalho pode conter diversos arquivos. Porém, apenas aqueles adicionados ao index, por meio de um <strong>add</strong>, serão gerenciados pelo git.</p>
<p>Além de armazenar a lista de arquivos versionados, o index também armazena o conteúdo deles. Por isso, antes de fazer um <code>commit</code> devemos executar um <code>add</code>, para salvar o conteúdo do arquivo no index. Feito isso, podemos usar um <code>commit</code> para salvar no repositório local a versão adicionada ao index. Esse fluxo é ilustrado na próxima figura.</p>
<figure>
<img src="figs/capAp/add.svg" style="width:55.0%" alt="" /><figcaption>Comandos <code>add</code> e <code>commit</code></figcaption>
</figure>
<p><strong>Exemplo</strong>: Suponha o seguinte arquivo simples, mas suficiente para explicar os comandos <code>add</code> e <code>commit</code>.</p>
<pre><code>// arq1 
x = 10; </code></pre>
<p>Após criar esse arquivo, o desenvolvedor executou o seguinte comando:</p>
<p><code>git add arq1</code></p>
<p>Esse comando adiciona o arquivo <code>arq1</code> no index (ou stage). Porém, logo em seguida, o desenvolvedor modificou de novo o arquivo:</p>
<pre><code>// arq1
x = 20; // novo valor de x</code></pre>
<p>Feito isso, ele executou:</p>
<p><code>git commit -m "Alterando o valor de x"</code></p>
<p>A opção <code>-m</code> informa a mensagem que descreve o commit. Porém, o ponto que queremos ressaltar com esse exemplo é o seguinte: como o usuário não executou um novo <code>add</code> após mudar o valor de <code>x</code> para 20, a versão mais recente do arquivo não será salva pelo commit. Em vez disso, a versão de <code>arq1</code> que será versionada é aquela em que <code>x</code> tem o valor 10, pois ela é a versão que consta do index.</p>
<p>Para evitar o problema descrito nesse exemplo, é comum usar um <code>commit</code> da seguinte forma:</p>
<p><code>git commit -a -m "Alterando valor de x"</code></p>
<p>A opção <code>-a</code> indica que antes de executar o commit queremos adicionar no index todos os arquivos rastreados (<em>tracked</em>) que tenham sido modificados desde o último commit. Portanto, a opção <code>-a</code> não elimina a necessidade de usar <code>add</code>. O uso desse comando continua sendo necessário, pelo menos uma vez, para indicar ao git que desejamos tornar um determinado arquivo rastreável.</p>
<p>Da mesma forma que existe um <code>add</code>, também existe uma operação para remover um arquivo de um repositório git. Um exemplo é dado a seguir:</p>
<pre><code>git rm arq1.txt
git commit -m &quot;Removendo arq1.txt&quot;</code></pre>
<p>Além de remover do repositório git local, o comando <code>rm</code> também remove o arquivo do diretório de trabalho.</p>
<h2 data-number="1.4" id="status-diff-log" data-number="1.4"><span class="header-section-number">1.4</span> Status, Diff &amp; Log</h2>
<p> O comando <strong>status</strong> é um dos comandos git mais usados. Dentre outras informações, ele mostra o estado do diretório de trabalho e do index. Por exemplo, pode-se usar esse comando para obter informações sobre:</p>
<ul>
<li><p>Arquivos do diretório de trabalho que foram alterados pelo desenvolvedor, mas que ele ainda não adicionou no index.</p></li>
<li><p>Arquivos do diretório de trabalho que não são rastreados pelo git, ou seja, eles ainda não foram objetos de um <code>add</code>.</p></li>
<li><p>Arquivos que encontram-se no index, aguardando um <code>commit</code>.</p></li>
</ul>
<p>O comando <code>git diff</code>  é muito usado para destacar as modificações realizados nos arquivos do diretório de trabalho e que ainda não foram movidas para o index (ou stage). Para cada arquivo modificado, ele mostra as linhas que foram adicionadas (+) e removidas (-). Muitas vezes, usamos um <code>git diff</code> antes de um <code>add</code>/<code>commit</code> para ter certeza das mudanças que iremos <q>perpetuar</q>, em seguida, no sistema de controle de versões.</p>
<p> Já o comando <code>git log</code> lista informações sobre os últimos commits, como data, autor, hora e descrição do commit.</p>
<h2 data-number="1.5" id="push-pull" data-number="1.5"><span class="header-section-number">1.5</span> Push &amp; Pull</h2>
<p>  O comando <strong>push</strong> copia os commits mais recentes do repositório local para o repositório remoto. Portanto, ele é uma operação mais lenta, pois envolve comunicação pela rede. Um <code>push</code> deve ser usado quando o desenvolvedor deseja tornar uma modificação visível para os demais desenvolvedores. Para atualizar seu repositório local, os outros desenvolvedores do time devem executar um comando <strong>pull</strong>. Esse comando realiza duas operações principais:</p>
<ul>
<li><p>Primeiro, um <code>pull</code> copia os commits mais recentes do repositório central para o repositório local do desenvolvedor. Essa operação inicial é chamada de <strong>fetch</strong>.</p></li>
<li><p>Em seguida, o comando <code>pull</code> atualiza os arquivos do diretório de trabalho. Essa operação é chamada de <strong>merge</strong>.</p></li>
</ul>
<p>A próxima figura ilustra o funcionamento dos comandos <code>push</code> e <code>pull</code>.</p>
<figure>
<img src="figs/capAp/push-pull.svg" style="width:55.0%" alt="" /><figcaption>Comandos <code>push</code> e <code>pull</code></figcaption>
</figure>
<p><strong>Exemplo</strong>: Suponha que no repositório git central de um projeto exista o seguinte arquivo:</p>
<pre><code>void f() {
  ... 
}</code></pre>
<p>Suponha que dois desenvolvedores, chamados Bob e Alice, realizaram um <code>pull</code> e, portanto, copiaram esse arquivo para o repositório local e para o diretório de trabalho de suas máquinas. A sintaxe desse comando é a seguinte:</p>
<p><code>git pull</code></p>
<p>No mesmo dia, Bob implementou uma segunda função <code>g</code> no arquivo:</p>
<pre><code>void f() {   // antiga
  ... 
}

void g() {   // implementada por Bob
  ... 
}</code></pre>
<p>Em seguida, Bob realizou um <code>add</code>, um <code>commit</code> e um <code>push</code>. Esse último comando tem a seguinte sintaxe:</p>
<p><code>git push origin master</code></p>
<p>O parâmetro <code>origin</code> é um valor default, usado pelo git, para indicar o repositório remoto, por exemplo, o repositório GitHub. Já o parâmetro <code>master</code> indica o branch principal. Iremos estudar mais sobre branches daqui a pouco.</p>
<p>Após executar o comando <code>push</code> acima, a nova versão do arquivo estará salva também no repositório remoto. Alguns dias depois, Alice decidiu que precisa alterar esse mesmo arquivo. Como ela ficou um tempo sem trabalhar no sistema, o recomendado é que ela execute primeiro um <code>pull</code>, para atualizar seu repositório local e seu diretório de trabalho com as mudanças ocorridas nesse período, como aquela realizada por Bob. Assim, após esse <code>pull</code>, o arquivo em questão será atualizado na máquina da Alice, para incluir a função <code>g</code> implementada por Bob.</p>
<h2 data-number="1.6" id="conflitos-de-merge" data-number="1.6"><span class="header-section-number">1.6</span> Conflitos de Merge</h2>
<p> </p>
<p>Conflitos de merge acontecem quando dois desenvolvedores alteram o mesmo trecho de código ao mesmo tempo. Para entender melhor essa situação, nada melhor do que usar um exemplo.</p>
<p><strong>Exemplo</strong>: Suponha que Bob implementou o seguinte programa:</p>
<pre><code>main() {
  print(&quot;Helo, world!&quot;);
}</code></pre>
<p>Concluída a implementação, Bob realizou um <code>add</code>, seguido de um <code>commit</code> e um <code>push</code>.</p>
<p>Em seguida, Alice realizou um <code>pull</code> e obteve a versão do arquivo implementada por Bob. Então, Alice resolveu traduzir a mensagem do programa para Português:</p>
<pre><code>main() {
  print(&quot;Olá, mundo!&quot;);
}</code></pre>
<p>Enquanto Alice fazia a tradução, Bob percebeu que escreveu Hello de forma errada, com apenas uma letra l. Porém, Alice foi mais rápida e realizou a trinca de comandos <code>add</code>, <code>commit</code> e <code>push</code>.</p>
<p>Bob, após corrigir o erro de ortografia, salvou o arquivo e também executou um <code>add</code>, seguido de um <code>commit</code>. Por fim, ele executou <code>push</code>, mas o comando falhou com a seguinte mensagem de erro:</p>
<div class="line-block">Updates were rejected because the remote contains work that you do<br />
not have locally. This is usually caused by another repository<br />
pushing to the same ref. You may want to first integrate the<br />
remote changes (e.g., git pull …) before pushing again.</div>
<p>A mensagem é bem clara: Bob não pode executar um <code>push</code>, pois o repositório remoto possui conteúdo novo, no caso, gerado por Alice. Antes de executar um <code>push</code>, Bob precisa executar um <code>pull</code>. Porém, ao fazer isso, ele recebe uma nova mensagem de erro:</p>
<div class="line-block">CONFLICT (content): Merge conflict in arq2<br />
Automatic merge failed; fix conflicts and then commit the result.</div>
<p>Essa nova mensagem é também clara: existe um conflito de merge no arquivo <code>arq2</code>. Ao editar esse arquivo, Bob vai perceber que ele foi modificado pelo git, para destacar as linhas que geraram o conflito:</p>
<pre><code>main() {                                                
 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD                                     
 print(&quot;Hello, world!&quot;);                               
 =======                                                 
 print(&quot;Olá, mundo!&quot;);                                 
 &gt;&gt;&gt;&gt;&gt;&gt;&gt; f25bce8fea85a625b891c890a8eca003b723f21b 
 }                                                       </code></pre>
<p>As linhas inseridas pelo git devem ser entendidas da seguinte forma:</p>
<ul>
<li><p>Entre <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> e <code>=======</code> temos o código modificado por Bob, isto é, pelo desenvolvedor que não conseguiu dar um <code>push</code> e teve que dar um <code>pull</code>. <code>HEAD</code> designa que o código foi modificado no último commit realizado por Bob.</p></li>
<li><p>Entre <code>=======</code> e <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; f25bce8 ...</code> temos o código modificado por Alice, isto é, pela desenvolvedora que executou com sucesso seu <code>push</code>. <code>f225bce8...</code> é o ID do commit no qual Alice modificou essa parte do código.</p></li>
</ul>
<p>Cabe então a Bob resolver o conflito, o que é sempre uma tarefa manual. Para isso, ele tem que escolher o trecho de código que vai prevalecer — o seu código ou o da Alice — e editar o arquivo de acordo com tal escolha, para remover os delimitadores inseridos pelo git.</p>
<p>Vamos supor que Bob decida que o código de Alice é o certo, pois agora o sistema está usando mensagens em Português. Logo, ele deve editar o arquivo, de forma que fique assim:</p>
<pre><code>main() {                
  print(&quot;Olá, mundo!&quot;);                      
}                       </code></pre>
<p>Veja que Bob removeu os delimitadores inseridos pelo git (<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;  HEAD</code> , <code>=======</code> e <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; f25bce8...</code>). E também o comando <code>print</code> com a mensagem em inglês. Após deixar o código da forma correta, Bob deve executar novamente os comandos <code>add</code>, <code>commit</code> e <code>push</code>, que agora serão bem sucedidos.</p>
<p>Nesse exemplo, mostramos um conflito simples, que ficou restrito a única linha de um único arquivo. No entanto, um <code>pull</code> pode dar origem a conflitos mais complexos. Por exemplo, um mesmo arquivo pode apresentar vários conflitos. E também podemos ter conflitos em mais de um arquivo.</p>
<h2 data-number="1.7" id="branches" data-number="1.7"><span class="header-section-number">1.7</span> Branches</h2>
<p>   </p>
<p>O git organiza o diretório de trabalho em <q>diretórios virtuais</q>, chamados de <strong>branches</strong>. Até agora, não precisamos comentar sobre branches porque todo repositório possui um branch default, chamado de <strong>master</strong>, criado pelo comando <code>init</code>. Se não nos preocuparmos com branches, todo o desenvolvimento ocorrerá no master. Porém, em alguns casos, é interessante criar outros branches para melhor organizar o desenvolvimento. Para descrever o conceito de branches, vamos de novo usar um exemplo.</p>
<p><strong>Exemplo</strong>: Suponha que Bob é responsável por manter uma determinada funcionalidade de um sistema. Para simplificar, vamos assumir que essa funcionalidade é implementada em uma única função <code>f</code>. Bob teve a ideia de mudar completamente a implementação de <code>f</code>, de forma que ela passe a usar algoritmos e estruturas de dados mais eficientes. Para isso, Bob vai precisar de algumas semanas. No entanto, apesar de estar otimista, Bob não tem certeza de que a nova implementação vai proporcionar os ganhos que ele imagina. Por fim, mas não menos importante, durante a implementação do novo código, Bob pode precisar do código original de <code>f</code>, para, por exemplo, corrigir bugs reportados pelos usuários.</p>
<p>Esse é um cenário interessante para Bob criar um branch para implementar e testar — de forma isolada — essa nova versão de <code>f</code>. Para isso, ele deve usar o comando:</p>
<p><code>git branch f-novo</code></p>
<p>Esse comando cria um novo branch, chamado <code>f-novo</code>, supondo que esse branch ainda não existe.</p>
<p>Para mudar do branch corrente para um novo branch, deve-se usar <code>git checkout [nome-branch]</code>. Para descobrir qual o nome do branch corrente, basta usar <code>git branch</code>. Na verdade, esse comando lista todos os branches e indica qual deles é o corrente.</p>
<p>Branches podem ser entendidos como "sub-diretórios virtuais" do diretório de trabalho. A principal diferença é que branches são gerenciados pelo git e não pelo sistema operacional. Por isso, optamos por chamá-los de virtuais. Explorando mais essa comparação, podemos pensar que o comando <code>git branch [nome]</code> equivale ao comando <code>mkdir [nome]</code>, com a diferença que o git não apenas cria um branch mas copia para ele todos os arquivos do branch pai. Por outro lado, diretórios são criados vazios pelo sistema operacional. Já o comando <code>git checkout [nome]</code> lembra o comando <code>cd [nome]</code>. E <code>git status</code> lembra um misto de comandos <code>ls</code> e <code>pwd</code>. Também para reforçar essa comparação, existem certos comandos que permitem adicionar ao prompt do sistema operacional não apenas o nome do diretório corrente mas também o nome do branch corrente. Assim, o prompt pode ser exibido como <code>~/projetos/sistema/master&gt;</code>.</p>
<p>Por outro lado, existe também uma diferença importante entre branches e diretórios. Um desenvolvedor somente pode alterar o branch corrente de A para B se as modificações que ele fez em A estiverem salvas. Isto é, se ele tiver realizado antes um <code>add</code> e <code>commit</code>. Caso ele tenha esquecido de chamar esses comandos, um comando git checkout B irá falhar com a seguinte mensagem de erro:</p>
<div class="line-block">Your local changes to the following files would be overwritten by checkout:<br />
[list of files]<br />
Please commit your changes or stash them before you switch branches.</div>
<p>Voltando ao exemplo, após Bob ter criado o seu branch, ele deve proceder do seguinte modo. Quando ele quiser trabalhar na nova implementação de <code>f</code>, ele deve primeiro mudar o branch corrente para <code>f-novo</code>. Por outro lado, quando ele precisar modificar o código original de <code>f</code> — aquele que está em produção — ele deve se certificar de que o branch corrente é o <code>master</code>. Independentemente do branch em que estiver, Bob deve usar <code>add</code> e <code>commit</code> para salvar o estado do seu trabalho.</p>
<p> Bob vai continuar nesse fluxo, alternando entre os branches <code>f-novo</code> e <code>master</code>, até que a nova implementação de <code>f</code> esteja concluída. Quando isso acontecer, Bob vai precisar copiar o novo código de <code>f</code> para o código original. No entanto, como está usando branches, ele não precisa realizar essa operação de forma manual. O git oferece uma operação, chamada <strong>merge</strong>, que realiza exatamente essa cópia. A sintaxe é a seguinte:</p>
<p><code>git merge f-novo</code></p>
<p>Esse comando deve ser chamado no branch que irá receber as modificações realizadas em <code>f-novo</code>. No nosso caso, no branch master.</p>
<p>Como o leitor já deve estar pensando, um merge pode gerar conflitos, chamados também de <strong>conflitos de integração</strong>. No caso específico de merge de branches, esses conflitos vão ocorrer quando tanto o branch que está recebendo as modificações (<code>master</code>, no nosso exemplo) como o branch que está sendo integrado (<code>f-novo</code>, no exemplo) tiverem alterado os mesmos trechos de código. Conforme discutido na Seção A.6, o git irá delimitar os trechos com conflitos e caberá ao desenvolvedor que chamou o <code>merge</code> resolvê-los. Isto é, escolher o código que deve prevalecer.</p>
<p>Por fim, após realizar o merge, Bob pode remover o branch <code>f-novo</code>, caso não seja importante manter o histórico dos commits realizados para implementar a nova versão de <code>f</code>. Para deletar <code>f-novo</code>, ele deve executar o seguinte comando no master:</p>
<p><code>git branch -d f-novo</code></p>
<h3 data-number="1.7.1" id="grafo-de-commits" data-number="1.7.1"><span class="header-section-number">1.7.1</span> Grafo de Commits</h3>
<p> </p>
<p>Commits podem possuir zero, um ou mais pais (ou antecessores). Como ilustra a próxima figura, o primeiro commit de um repositório não possui pai. Já um commit de merge possui dois ou mais pais, que representam os branches que foram unidos. Os demais commits possuem exatamente um nodo pai.</p>
<p><img src="figs/capAp/branches.svg" style="width:60.0%" /></p>
<p> Um branch nada mais é do que uma variável interna do git que contém o identificador do último commit realizado no branch. Existe ainda uma variável chamada <code>HEAD</code>, que aponta para a variável do branch atual. Ou seja, <code>HEAD</code> contém o nome da variável que contém o identificador do último commit do branch atual. Um exemplo é mostrado a seguir:</p>
<p><img src="figs/capAp/head1.svg" style="width:65.0%" /></p>
<p> Nesse exemplo, existem dois branches, representados pelas variáveis <code>MASTER</code> e <code>ISSUE-45</code>. Cada uma delas aponta para o último commit de seu respectivo branch. A variável <code>HEAD</code> aponta para a variável <code>MASTER</code>. Isso significa que o branch atual é o <code>MASTER</code>. Se realizarmos um commit, a configuração mudará para:</p>
<p><img src="figs/capAp/head2.svg" style="width:65.0%" /></p>
<p>O novo commit tem identificador 7. Ele foi realizado no <code>MASTER</code>, já que HEAD apontava para a variável desse branch. O pai do novo commit pai é o antigo <code>HEAD</code>, no caso o commit 3. A variável <code>MASTER</code> avançou e passou a apontar para o novo commit. Isso significa que, se não mudarmos de branch, o pai do próximo commit será o commit 7.</p>
<p>Porém, se mudarmos para o branch <code>ISSUE-45</code>, a configuração será aquela mostrada na próxima figura. A única mudança é que a variável <code>HEAD</code> passou a apontar para a variável do novo branch, isto é, para a variável <code>ISSUE-45</code>. Isso é suficiente para fazer com que o próximo commit seja realizado nesse branch, isto é, que ela tenha o commit 6 como pai.</p>
<p><img src="figs/capAp/head3.svg" style="width:65.0%" /></p>
<h2 data-number="1.8" id="branches-remotos" data-number="1.8"><span class="header-section-number">1.8</span> Branches Remotos</h2>
<p></p>
<p>Até esse momento, trabalhamos com branches localmente, isto é, os branches que discutimos existem apenas no repositório local. No entanto, é possível realizar o <code>push</code> de um branch local para um repositório remoto. Para ilustrar esse recurso, vamos usar um exemplo semelhante ao da seção anterior.</p>
<p><strong>Exemplo:</strong> Suponha que Bob criou um branch, chamado g-novo, para implementar uma nova funcionalidade. Ele realizou alguns commits nesse branch e agora gostaria de compartilhá-lo com Alice, para que ela implemente parte da nova funcionalidade. Para isso, Bob deve usar o seguinte <code>push</code>:</p>
<p><code>git push -u origin g-novo</code></p>
<p>Esse comando realiza o <code>push</code> do branch corrente (<code>g-novo</code>) para o repositório remoto, chamado pelo git de <code>origin</code>. O repositório remoto pode, por exemplo, ser um repositório do GitHub. O parâmetro <code>-u</code> indica que, no futuro, vamos querer sincronizar os dois repositórios por meio de um <code>pull</code> (a letra do parâmetro vem da palavra <em>upstream</em>). Essa sintaxe vale apenas para o primeiro <code>push</code> de um branch remoto. Nos comandos seguintes, pode-se omitir o <code>-u</code>, isto é, usar apenas <code>git  push origin g-novo</code>.</p>
<p>No repositório remoto, será criado um branch <code>g-novo</code>. Para trabalhar nesse branch, Alice deve primeiro criá-lo na sua máquina local, mas associado ao branch remoto, por meio dos seguintes comandos, que devem ser executados no master:</p>
<p><code>git pull</code></p>
<p><code>git checkout -t origin/g-novo</code></p>
<p>O primeiro comando é necessário para tornar o branch remoto visível na máquina local. Já o segundo comando cria um branch local, chamado <code>g-novo</code>, que Alice vai usar para rastrear mudanças no branch remoto <code>origin/g-novo</code>, conforme indica o parâmetro <code>-t</code>, que vem da palavra <em>tracking</em>. Em seguida, Alice pode realizar commits nesse branch. Por fim, quando estiver pronta para publicar suas mudanças, ela deve executar um <code>push</code>, com a sintaxe normal, isto é, sem o parâmetro <code>-u</code>.</p>
<p>Agora, Bob pode realizar um <code>pull</code>, concluir que a implementação da nova funcionalidade está finalizada e, portanto, pode ser integrada no master, por meio de um merge. Bob pode também deletar os branches local e remoto, usando os comandos:</p>
<p><code>git branch -d g-novo</code></p>
<p><code>git push origin --delete g-novo</code></p>
<p>E Alice também pode deletar seu branch local, chamando apenas:</p>
<p><code>git branch -d g-novo</code></p>
<h2 data-number="1.9" id="pull-requests" data-number="1.9"><span class="header-section-number">1.9</span> Pull Requests</h2>
<p>  </p>
<p>Pull requests é um mecanismo que viabiliza que um branch seja revisado e discutido antes de ser integrado no branch principal. Quando se usa pull requests, um desenvolvedor sempre implementa novas funcionalidades em um branch separado. Concluída a implementação, ele não integra imediatamente o novo código no branch principal. Antes que isso ocorra, ele abre uma solicitação para que seu branch seja revisado e aprovado por um segundo desenvolvedor. Essa solicitação para revisão e integração de código é chamada de pull request. Trata-se de um mecanismo mais comum no GitHub, mas que possui equivalente em outros sistemas de controle de versões.</p>
<p>Modernamente, o processo de revisão e integração do código de um pull request ocorre via interface Web, provida, por exemplo, pelo GitHub. Porém, se essa interface não existisse, o revisor teria que começar o seu trabalho realizando um <code>pull</code> do branch para sua máquina local. Daí então a origem do nome, isto é, pull request é uma solicitação (<em>request</em>) para que um segundo desenvolvedor revise e integre um determinado branch. Para atender a essa solicitação, ele deve começar realizando um <code>pull</code> do branch.</p>
<p>A seguir, vamos detalhar o processo de submissão e revisão de pull requests por meio de um exemplo.</p>
<p><strong>Exemplo</strong>: Suponha que Bob e Alice são membros de uma organização que mantém um repositório chamado awesome-git, com uma lista de links interessantes sobre git. Os links ficam armazenados no arquivo README.md desse repositório, isto é, na sua página principal, cujo endereço é <code>github.com/aserg-ufmg/awesome-git</code>. Qualquer membro da organização pode sugerir a adição de links nessa página. Mas veja que estamos usando a palavra sugerir. Isto é, eles não podem fazer um <code>push</code> diretamente no branch master. Em vez disso, a sugestão de link precisa ser revisada e aprovada por um outro membro do time.</p>
<p>Bob resolveu então sugerir a adição, nessa página, de um link para o presente apêndice do livro Engenharia de Software Moderna. Para isso, ele primeiro clonou o repositório e criou um branch, chamado <code>livro-esm</code>, por meio dos seguintes comandos:</p>
<p><code>git clone https://github.com/aserg-ufmg/awesome-git.git</code><br />
<code>git checkout livro-esm</code></p>
<p>Em seguida, Bob editou o arquivo README.md, adicionando a URL do apêndice. Por fim, ele realizou um <code>add</code>, um <code>commit</code> e fez um <code>push</code> do branch para o GitHub:</p>
<p><code>git add README.md</code><br />
<code>git commit -m "Livro ESM"</code><br />
<code>git push -u origin livro-esm</code></p>
<p>Na verdade, esses passos não são novidade em relação ao que vimos na seção anterior. No entanto, as diferenças começam agora. Primeiro, Bob deve ir na página do GitHub e selecionar o branch <code>livro-esm</code>. Feito isso, o GitHub mostrará um botão para criação de pull requests. Bob deve clicar nesse botão e descrever o seu pull request, como mostra a próxima figura.</p>
<figure>
<img src="figs/capAp/pull-request.png" style="width:75.0%" alt="" /><figcaption>Exemplo de pull request</figcaption>
</figure>
<p>Um pull request é uma solicitação para que um outro desenvolvedor revise e, se for o caso, realize o merge de um branch que você criou. Consequentemente, pull requests são um recurso para que uma organização passe a adotar <strong>revisões de código</strong>. Ou seja, desenvolvedores não integram diretamente o seu código no master do repositório remoto. Em vez disso, eles solicitam, via pull requests, que outros desenvolvedores revisem primeiro esse código e então façam o merge.</p>
<p>Na página do GitHub para criação de pull requests, Bob pode informar que deseja que seu código seja revisado pela Alice. Ela será então notificada que existe um pull request esperando sua revisão. Também via interface do GitHub, Alice pode revisar os commits do pull request criado por Bob, inclusive por meio de um diff entre o código novo e o código antigo. Se for o caso, Alice pode trocar mensagens com Bob, para esclarecer dúvidas sobre o novo código. Mais ainda, ela pode solicitar mudanças no código. Nesse caso, Bob deve providenciar as mudanças e realizar um novo <code>add</code>, <code>commit</code> e <code>push</code>. Então, os novos commit serão automaticamente anexados ao pull request, para que Alice possa conferir se o seu pedido foi atendido. Estando a modificação aprovada, Alice pode integrar o código no master, bastando para isso clicar em um dos botões da página de revisão de pull requests.</p>
<h2 data-number="1.10" id="squash" data-number="1.10"><span class="header-section-number">1.10</span> Squash</h2>
<p></p>
<p>Squash é um comando que permite unir diversos commits em um único commit. É uma operação recomendada, por exemplo, antes de submeter pull requests.</p>
<p><strong>Exemplo</strong>: No exemplo anterior, suponha que o pull request criado por Bob tivesse cinco commits. Mais especificamente, ele está sugerindo o acréscimo de cinco novos links no repositório awesome-git, os quais foram coletados por ele ao longo de algumas semanas. Após a descoberta de cada link, Bob executou um commit na sua máquina local. E deixou para realizar o pull request apenas após acumular cinco commits.</p>
<p>Para facilitar a revisão de seu pull request por parte de Alice, Bob pretende unir esses cinco commits em um único commit. Assim, em vez de analisar cinco commits, Alice vai ter que analisar apenas um. Porém, a modificação submetida será exatamente a mesma, isto é, ela consiste na inclusão de cinco novos links na página. Porém, em vez de a solicitação estar distribuída em cinco commits (cada commit, adicionando um único link), ela estará concentrada em apenas um commit (adicionando cinco links).</p>
<p>Para realizar um squash, Bob deve chamar:</p>
<p><code>git rebase -i HEAD~5</code></p>
<p>O número 5 significa que pretende-se unir os cinco últimos commits do branch atual. Um editor de textos será aberto com uma lista contendo o ID e a descrição de cada um, como mostrado a seguir:</p>
<pre><code>pick 16b5fcc Incluindo link 1
pick c964dea Incluindo link 2
pick 06cf8ee Incluindo link 3
pick 396b4a3 Incluindo link 4
pick 9be7fdb Incluindo link 5</code></pre>
<p>Bob deve então usar o próprio editor para substituir a palavra pick por squash, exceto aquela da primeira linha. O arquivo ficará então assim:</p>
<pre><code>pick 16b5fcc Incluindo link 1
squash c964dea Incluindo link 2
squash 06cf8ee Incluindo link 3
squash 396b4a3 Incluindo link 4
squash 9be7fdb Incluindo link 5</code></pre>
<p>Bob deve então salvar o arquivo. Automaticamente, um novo editor será aberto, para ele informar a mensagem do novo commit — isto é, do commit que junta os cinco commits listados. Uma vez informada a mensagem, Bob deve salvar o arquivo e, então, o squash estará finalizado.</p>
<h2 data-number="1.11" id="forks" data-number="1.11"><span class="header-section-number">1.11</span> Forks</h2>
<p>  </p>
<p>Fork é o mecanismo que o GitHub oferece para clonar repositórios remotos, isto é, repositórios armazenados pelo próprio GitHub. Um fork é realizado via interface do GitHub. Na página de qualquer repositório, existe um botão para realizar essa operação. Se fizermos um fork do repositório torvalds/linux será criado uma cópia desse repositório na nossa conta do GitHub, chamado, por exemplo, mtov/linux.</p>
<p>Como fazemos sempre, vamos usar um exemplo para explicar essa operação.</p>
<p><strong>Exemplo</strong>: Suponha o repositório <code>github.com/aserg-ufmg/awesome-git</code>, usado no exemplo sobre pull requests. Suponha ainda uma terceira desenvolvedora, chamada Carol. Porém, como Carol não é membro da organização ASERG/UFMG, ela não tem permissão para realizar <code>push</code> nesse repositório, como fez Bob no exemplo anterior. Apesar disso, Carol acha que na lista atual falta um link importante e interessante, cuja inclusão ela gostaria de sugerir. Mas relembrando: Carol não pode seguir os mesmos passos usados por Bob no exemplo anterior, pois ela não tem permissão para dar <code>push</code> no repositório em questão.</p>
<p>Para resolver esse problema, Carol deve começar criando um fork do repositório. Para isso, basta clicar no botão fork, que existe na página de qualquer repositório no GitHub. Assim, Carol terá na sua conta do GitHub um novo repositório, cujo endereço será o seguinte: github.com/carol/awesome-git. Ela poderá clonar esse repositório para sua máquina local, criar um branch, adicionar o link que deseja na lista de links e realizar <code>add</code>, <code>commit</code> e <code>push</code>. Essa última operação será realizada no repositório resultante do fork. Por último, Carol deve ir na página do seu fork no GitHub e solicitar a criação de um pull request. Como o repositório é um fork, ela terá agora uma opção extra: destinar o pull request para o repositório original. Assim, caberá aos desenvolvedores do repositório original, como Bob e Alice, revisar e, se for o caso, aceitar o pull request.</p>
<p>Portanto, fork é um mecanismo que, quando combinado com pull requests, viabiliza que um projeto de código aberto receba contribuições de outros desenvolvedores. Explicando um pouco melhor, um projeto de código aberto pode receber contribuições — mais especificamente, commits — não apenas de seu time de desenvolvedores (Bob e Alice, no nosso exemplo), mas de um outro desenvolvedor com conta no GitHub (como é o caso de Carol).</p>
<h2 class="unnumbered" data-number="" id="bibliografia" class="unnumbered" data-number="">Bibliografia</h2>
<ul>
<li><p>Scott Chacon; Ben Straub. Pro Git. 2a edição, Apress, 2014.</p></li>
<li><p>Rachel M. Carmena. How to teach Git. Blog post <a href="https://rachelcarmena.github.io/2018/12/12/how-to-teach-git.html">(link)</a>.</p></li>
</ul>
<h2 class="unnumbered" data-number="" id="exercícios-de-fixação" class="unnumbered" data-number="">Exercícios de Fixação</h2>
<p>Neste apêndice, mostramos diversos exemplos. Tente reproduzir cada um deles. Nos exemplos que envolvem repositórios remotos, a sugestão é usar um repositório do GitHub. Nos exemplos que envolvem dois usuários (Alice e Bob, por exemplo), a sugestão é criar dois diretórios locais e usá-los para reproduzir os comandos de cada usuário.</p>
<p>Este livro foi formato pelo autor usando o sistemas Pandoc, para conversão de Markdown para LaTeX e, em seguida, geração de um arquivo PDF. A fonte usada é Computer Modern, 11pt. A partir dos mesmos arquivos Markdown são geradas as versões MOBI (Kindle) e HTML.</p>
</div>
</div>
</div>

<footer>
Direitos autorais reservados. Versão para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formulário</a>.
</footer>
</body>
</html>
