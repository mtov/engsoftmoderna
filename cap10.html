<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-8249107-3', 'auto');
     ga('send', 'pageview');
  </script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.1/mini-default.min.css">

  <style>
  body {
    background-color: #FCFCFC;
    foreground-color: black;
  }
  </style>
</head>
<body>
<div class="container">
<div class="row cols-sm-12 cols-md-10">
<div class="col-md-offset-1">
<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 id="cap.-10---devops-em-andamento">Cap. 10 - DevOps (em andamento)</h1>
<blockquote>
<p><em>Imagine a world where product owners, development, QA, IT Operations, and Infosec work together, not only to help each other, but also to ensure that the overall organization succeeds. ‚Äì G. Kim, J. Humble, P. Debois, J. Willes</em></p>
</blockquote>
<h2 id="introdu√ß√£o">10.1 Introdu√ß√£o</h2>
<p>At√© agora, neste livro, estudamos um conjunto de pr√°ticas para desenvolvimento de software com qualidade e agilidade. Por meio de m√©todos √°geis ‚Äî como Scrum, XP ou Kanban ‚Äî, vimos que o cliente deve participar desde o primeiro dia da constru√ß√£o de um sistema. Tamb√©m estudamos pr√°ticas importantes para produ√ß√£o de software com qualidade, como testes de unidade e refactoring. Estudamos ainda princ√≠pios e padr√µes de projeto e tamb√©m padr√µes arquiteturais.</p>
<p>Logo, ap√≥s aplicar o que vimos, o sistema ‚Äî ou um incremento dele, resultante de um sprint ‚Äî est√° pronto para entrar em produ√ß√£o. Essa tarefa √© conhecida pelos nomes de <strong>implanta√ß√£o (deploy)</strong>, <strong>libera√ß√£o (release)</strong> ou <strong>entrega(delivery)</strong> do sistema. Independentemente do nome, ela n√£o √© t√£o simples e r√°pida como pode parecer.</p>
<p>Historicamente, em organiza√ß√µes tradicionais, a √°rea de Tecnologia da Informa√ß√£o costumava ser dividida em dois departamentos:</p>
<ul>
<li><p>Departamento de Sistemas (ou Desenvolvimento), formado por desenvolvedores, programadores, analistas, arquitetos, etc.</p></li>
<li><p>Departamento de Suporte (ou Opera√ß√µes), no qual ficavam alocados os administradores de rede, administradores de bancos de dados, t√©cnicos de suporte, etc.</p></li>
</ul>
<p>Hoje em dia, √© f√°cil imaginar os problemas causados por essa divis√£o. Na maioria das vezes, a √°rea de suporte tomava conhecimento de um sistema na v√©spera da sua implanta√ß√£o. Consequentemente, a implanta√ß√£o poderia atrasar por meses, devido a uma variedade de problemas que n√£o foram identificados. Dentre eles, podemos citar a falta de hardware para executar o novo sistema ou a nova funcionalidade, problemas de desempenho, incompatibilidades com o banco de dados de produ√ß√£o, vulnerabilidades de seguran√ßa, etc. No limite, esses problemas poderiam resultar no cancelamento da implanta√ß√£o e no abandono do sistema.</p>
<p>Resumindo, nesse modelo tradicional, existia um stakeholder importante ‚Äî os administradores de sistemas ou <em>sysadmins</em> ‚Äî que tomava conhecimento das caracter√≠sticas e requisitos n√£o-funcionais de um novo software na v√©spera da implanta√ß√£o. Esse problema era agravado pelo fato de os sistemas serem grandes monolitos, cuja implanta√ß√£o gerava todo tipo de preocupa√ß√£o, como mencionado no final do par√°grafo anterior.</p>
<p>Ent√£o, para facilitar a implanta√ß√£o e entrega de sistemas, foi proposto o conceito de <strong>DevOps</strong>. Por ser um termo recente, ele ainda n√£o possui uma defini√ß√£o consolidada. Mas seus proponentes gostam de descrever DevOps como um movimento que visa unificar as culturas de desenvolvimento (Dev) e de opera√ß√£o (Ops), visando permitir a implanta√ß√£o mais r√°pida e √°gil de um sistema. Esse objetivo est√° refletido na frase que abre esse cap√≠tulo, de autoria de Gene Kim, Jez Humble, Patrick Debois e John Willes, todos eles membros de um grupo de desenvolvedores que ajudou a difundir os princ√≠pios de DevOps. Segundo eles, DevOps implica na seguinte disrup√ß√£o na cultura tradicional de implanta√ß√£o de sistemas (<a href="https://dl.acm.org/doi/book/10.5555/3044729">link</a>):</p>
<blockquote>
<p>Em vez de iniciar as implanta√ß√µes √† meia-noite de sexta-feira e passar todo o fim de semana trabalhando para conclu√≠-las, as implanta√ß√µes ocorrem em qualquer dia √∫til, quando todos est√£o na empresa e sem que os clientes percebam ‚Äî exceto quando encontram novas funcionalidades e corre√ß√µes de bugs.</p>
</blockquote>
<p>No entanto, DevOps n√£o advoga a cria√ß√£o de um profissional novo, que fique respons√°vel tanto pelo desenvolvimento como pela implanta√ß√£o de sistemas. Em vez disso, defende-se uma aproxima√ß√£o entre o pessoal de desenvolvimento e o pessoal de opera√ß√µes e vice-versa, visando fazer com que a implanta√ß√£o de sistemas seja mais √°gil e menos traum√°tica. Tentando explicar com outras palavras, a ideia √© evitar dois silos independentes: desenvolvedores e operadores, com pouca ou nenhuma itera√ß√£o eles, como ilustrado na figura a seguir.</p>
<figure>
<img src="figs/cap10/no-devops.svg" style="width:35.0%" alt="" /><figcaption>Organiza√ß√£o que <strong>n√£o</strong> √© baseada em DevOps. Existe pouca comunica√ß√£o entre Dev e Ops.</figcaption>
</figure>
<p>Em vez disso, defende-se que esses profissionais atuem em conjunto desde os primeiros sprints de um projeto, como na figura a seguir. Para o cliente final, o benef√≠cio deve ser a entrada em produ√ß√£o mais cedo do sistema que ele contratou.</p>
<figure>
<img src="figs/cap10/devops.svg" style="width:35.0%" alt="" /><figcaption>Organiza√ß√£o baseada em DevOps. Frequentemente, alguns Dev e alguns Ops sentam juntos para discutir quest√µes sobre a entrega do sistema.</figcaption>
</figure>
<p>Quando migra-se para uma cultura de DevOps, os times √°geis podem incluir um profissional de opera√ß√µes, que participe dos trabalhos do time em tempo parcial ou mesmo em tempo integral. Sempre em fun√ß√£o da demanda, esse profissional pode tamb√©m participar de mais de um time. A ideia √© que ele antecipe problemas de desempenho, seguran√ßa, incompatibilidades com outros sistemas, etc. Ele pode tamb√©m, enquanto o c√≥digo est√° sendo implementado, come√ßar a trabalhar nos scripts de instala√ß√£o, administra√ß√£o e monitoramento do sistema em produ√ß√£o.</p>
<p>De forma n√£o menos importante, DevOps advoga ainda a automatiza√ß√£o de todos os passos necess√°rios para colocar um sistema em produ√ß√£o e monitorar o seu correto funcionamento. Isso implica na ado√ß√£o de pr√°ticas que j√° vimos neste livro, notadamente testes automatizados. Mas tamb√©m implica no emprego de novas pr√°ticas e ferramentas, tais como Integra√ß√£o Cont√≠nua (<em>Continuous Integration</em>) e Entrega Cont√≠nua (<em>Continuous Deployment</em>), que iremos estudar neste cap√≠tulo.</p>
<p>Para finalizar, vamos discutir um conjunto de princ√≠pios para entrega de software, enunciados por Jez Humble e David Harley (<a href="https://dl.acm.org/doi/book/10.5555/1869904">link</a>). Apesar de propostos antes da ideia de DevOps ganhar tra√ß√£o, eles s√£o completamente alinhados com essa ideia. Alguns desses princ√≠pios s√£o os seguintes:</p>
<ul>
<li><p><strong>Crie um processo repet√≠vel e confi√°vel para entrega de software</strong>. Esse princ√≠pio √© o mais importante deles. A ideia √© que a entrega de software n√£o pode ser um evento traum√°tico, com passos manuais e sujeitos a surpresas. Em vez disso, colocar um software em produ√ß√£o deve ser t√£o simples como apertar um bot√£o.</p></li>
<li><p><strong>Automatize tudo que for poss√≠vel</strong>. Na verdade, esse princ√≠pio √© um pr√©-requisito indispens√°vel para atender ao princ√≠pio anterior. Advoga-se que todos os passos para entrega de um software devem ser autom√°ticos, incluindo seu <em>build</em>, a execu√ß√£o dos testes, a configura√ß√£o e ativa√ß√£o dos servidores e da rede, a carga do banco de dados, etc. De novo, idealmente, queremos apertar um bot√£o e, em seguida, ver o sistema em produ√ß√£o.</p></li>
<li><p><strong>Mantenha tudo em um sistema de controle de vers√µes</strong>. ‚ÄúTudo‚Äù no enunciado do princ√≠pio refere-se n√£o apenas a todo o c√≥digo fonte, mas tamb√©m arquivos e scripts de administra√ß√£o do sistema, documenta√ß√£o, p√°ginas Web, arquivos de dados, etc. Consequentemente, deve ser simples restaurar e voltar o sistema para um estado anterior. Neste cap√≠tulo, iniciaremos estudando alguns conceitos b√°sicos de <strong>controle de vers√µes</strong>, na Se√ß√£o 10.2. Al√©m disso, no Ap√™ndice A apresentamos e ilustramos o uso dos principais comandos do sistema Git, que √© o sistema de controle de vers√µes mais usado atualmente.</p></li>
<li><p><strong>Se um passo causa dor, execute-o com mais frequ√™ncia e o quanto antes</strong>. Esse princ√≠pio n√£o tem uma inspira√ß√£o masoquista. Em vez disso, a ideia √© antecipar os problemas, antes que eles se acumulem e as solu√ß√µes fiquem complicadas. O exemplo cl√°ssico √© o de <strong>integra√ß√£o cont√≠nua</strong>. Se um desenvolvedor passa muito tempo trabalhando de forma isolada, ele e o seu time podem depois ter uma grande dor de cabe√ßa para integrar o c√≥digo. Logo, como integra√ß√£o pode causar dor, a recomenda√ß√£o consiste em integrar c√≥digo novo com mais frequ√™ncia e o quanto antes, se poss√≠vel, diariamente. Iremos estudar mais sobre integra√ß√£o cont√≠nua na Se√ß√£o 10.3.</p></li>
<li><p><strong>‚ÄúConclu√≠do‚Äù significa pronto para entrega</strong>. Com frequ√™ncia, desenvolvedores dizem que uma nova hist√≥ria est√° pronta (<em>done</em>). Por√©m, ao serem questionados se ela pode entrar em produ√ß√£o, come√ßam a surgir ‚Äúpequenas‚Äù pend√™ncias, tais como: a implementa√ß√£o ainda n√£o foi testada com dados reais, ela ainda n√£o foi documentada, ela ainda n√£o foi integrada com o sistema X, etc. Esse princ√≠pio defende ent√£o que ‚Äúconclu√≠do‚Äù, em projetos de software, deve ter uma sem√¢ntica clara, isto √©: 100% pronto para entrar em produ√ß√£o.</p></li>
<li><p><strong>Todos s√£o respons√°veis pela entrega do software</strong>. Esse √∫ltimo princ√≠pio alinha-se perfeitamente com a cultura de DevOps que discutimos no in√≠cio desta Introdu√ß√£o. Ou seja, n√£o admite-se mais que os times de desenvolvimento e opera√ß√£o trabalham em silos independentes e troquem informa√ß√µes apenas na v√©spera de uma implanta√ß√£o.</p></li>
</ul>
<p>üåé <strong>Mundo Real</strong>: O termo DevOps come√ßou a ser usado no final dos anos 2000 por desenvolvedores frustrados com os atritos constantes entre as equipes de desenvolvimento e opera√ß√µes. Ent√£o, eles convenceram-se de que uma solu√ß√£o seria a ado√ß√£o de princ√≠pios √°geis n√£o apenas na fase de desenvolvimento, mas tamb√©m de implanta√ß√£o. Para citar uma data precisa, em Novembro de 2009 foi realizada, na B√©lgica, a primeira confer√™ncia da ind√∫stria sobre o tema, chamada DevOpsDay. Considera-se que foi nesta confer√™ncia, organizada por Patrick Dubois, que a palavra DevOps foi cunhada (<a href="https://dl.acm.org/doi/book/10.5555/3044729">link</a>).</p>
<h2 id="controle-de-vers√µes">10.2 Controle de Vers√µes</h2>
<p>Como mencionamos algumas vezes neste livro, software √© desenvolvido em equipe. Por isso, precisamos de um servidor para armazenar o c√≥digo fonte do sistema que est√° sendo implementado por um grupo de desenvolvedores. A exist√™ncia desse servidor √© fundamental para que esses desenvolvedores possam colaborar e para que os operadores saibam precisamente qual vers√£o do sistema deve ser colocada em produ√ß√£o. Al√©m disso, sempre √© √∫til manter o hist√≥rico das vers√µes mais importantes de cada arquivo. Isso permite, se necess√°rio, realizar uma esp√©cie de "undo" no tempo, isto √©, recuperar o c√≥digo de um arquivo como ele estava h√° anos atr√°s, por exemplo.</p>
<p>Um <strong>sistema de controle de vers√µes</strong> (VCS, na sigla em ingl√™s) oferece os dois servi√ßos mencionados no par√°grafo anterior. Primeiro, ele oferece um <strong>reposit√≥rio</strong> para armazenar a vers√£o mais recente do c√≥digo fonte de um sistema, bem como de arquivos relacionados, como arquivos de documenta√ß√£o, configura√ß√£o, p√°ginas Web, manuais, etc. segundo lugar, ele permite que se recupere vers√µes mais antigas de qualquer arquivo, caso isso seja necess√°rio. Como enunciamos na Introdu√ß√£o, modernamente √© inconceb√≠vel desenvolver qualquer sistema, mesmo que simples, sem um VCS.</p>
<p>Os primeiros sistemas de controle de vers√µes surgiram no in√≠cio da d√©cada de 70, como o sistema SCCS, desenvolvido para o sistema operacional Unix. Em seguida, surgiram outros sistemas, como o CVS, em meados da d√©cada de 80, e depois o sistema Subversion, tamb√©m conhecido pela sigla svn, no in√≠cio dos anos 2000. Todos s√£o sistemas centralizados e baseados em uma arquitetura cliente/servidor (veja figura a seguir). Nessa arquitetura, existe um √∫nico servidor, que armazena o reposit√≥rio e o sistema de controle de vers√µes. Os clientes acessam esse servidor para obter a vers√£o mais recente de um arquivo. Feito isso, eles podem modificar o arquivo, por exemplo, para corrigir um bug ou implementar uma nova funcionalidade. Por fim, eles atualizam o arquivo no servidor, realizando uma opera√ß√£o chamada <strong>commit</strong>, a qual torna o arquivo vis√≠vel para os outros desenvolvedores.</p>
<figure>
<img src="figs/cap10/vcs.svg" style="width:35.0%" alt="" /><figcaption>VCS Centralizado. Existe um √∫nico reposit√≥rio, no nodo servidor</figcaption>
</figure>
<p>No in√≠cio dos anos 2000, come√ßaram a surgir <strong>sistemas de controle de vers√µes distribu√≠dos</strong> (DVCS). Dentre eles, podemos citar o sistema BitKeeper, cujo primeiro release √© de 2000, e os sistemas Mercurial e git, ambos lan√ßados em 2005. Em vez de uma arquitetura cliente/servidor, um DVCS adota uma arquitetura peer-to-peer. Na pr√°tica, isso significa que cada desenvolvedor possui em sua m√°quina um servidor completo de controle de vers√µes, que pode se comunicar com os servidores de outras m√°quinas, como ilustrado na pr√≥xima figura.</p>
<figure>
<img src="figs/cap10/dvcs.svg" style="width:35.0%" alt="" /><figcaption>VCS Distribu√≠do (DVCS). Cada cliente possui um servidor. Logo, a arquitetura √© peer-to-peer.</figcaption>
</figure>
<p>Apesar de todos os clientes serem funcionalmente equivalentes, na pr√°tica, quando se usa um DVCS, existe uma m√°quina principal, que armazena a vers√£o de refer√™ncia do c√≥digo fonte. Na nossa figura, chamamos esse reposit√≥rio de <strong>reposit√≥rio central</strong>. Cada desenvolvedor pode trabalhar de forma independente e at√© mesmo offline em sua m√°quina cliente, realizando commits no seu reposit√≥rio. De tempos em tempos, ele deve sincronizar esse reposit√≥rio com o central, por meio de duas opera√ß√µes: <strong>pull</strong> e <strong>push</strong>. Um pull atualiza o reposit√≥rio local com novos commits dispon√≠veis no reposit√≥rio central. Por sua vez, um push faz a opera√ß√£o contr√°ria, isto √©, envia para o reposit√≥rio central os commits mais recentes realizados pelo desenvolvedor em seu reposit√≥rio local. Quando comparado com um VCS centralizado, um DVCS tem as seguintes vantagens:</p>
<ul>
<li><p>Pode-se trabalhar e gerenciar vers√µes de forma offline, sem estar conectado a uma rede, pois os commits s√£o realizados primeiro no reposit√≥rio local.</p></li>
<li><p>Pode-se realizar commits com mais frequ√™ncia, incluindo commits com implementa√ß√µes parciais, pois eles n√£o v√£o chegar imediatamente at√© o reposit√≥rio central.</p></li>
<li><p>Commits s√£o executados em menos tempo, isto √©, s√£o opera√ß√µes mais r√°pidas e leves. O motivo √© que eles s√£o realizados no reposit√≥rio local de cada m√°quina.</p></li>
<li><p>A sincroniza√ß√£o n√£o precisa ser sempre com o reposit√≥rio central. Em vez disso, dois nodos podem tamb√©m sincronizar os seus reposit√≥rios. Por exemplo, pode-se ter uma estrutura hier√°rquica dos reposit√≥rios. Nesses casos, os commits "nascem" nos reposit√≥rios que representam as folhas da hierarquia e v√£o subindo at√© chegar ao reposit√≥rio central.</p></li>
</ul>
<p><strong>Git</strong> √© um sistema de controle de vers√µes distribu√≠do cujo desenvolvimento foi liderado por Linus Torvalds, tamb√©m respons√°vel pela cria√ß√£o do sistema operacional Linux. Nos anos iniciais, o desenvolvimento do kernel do Linux usava um sistema de controle de vers√µes comercial, chamado BitKeeper, que tamb√©m possui uma arquitetura distribu√≠da. No entanto, em 2005, a empresa propriet√°ria do BitKeeper resolveu revogar as licen√ßas gratuitas que eram usadas no desenvolvimento do Linux. Os desenvolvedores do sistema operacional, liderados por Torvalds, decidiram ent√£o iniciar a implementa√ß√£o de um DVCS pr√≥prio, ao qual deram o nome de Git. Assim como o Linux, o Git √© um sistema de c√≥digo aberto, que pode ser gratuitamente instalado em qualquer m√°quina. O Git √© ainda um sistema de linha de comando. Por√©m, existem tamb√©m algumas interfaces gr√°ficas, produzidas por outras empresas, que permitem usar o sistema sem ter que digitar comandos.</p>
<p><strong>GitHub</strong> √© um servi√ßo de hospedagem de c√≥digo que usa o sistema git para prover controle de vers√µes. O GitHub oferece reposit√≥rios p√∫blicos e gratuitos, para projetos de c√≥digo aberto, e reposit√≥rios fechados e pagos, para uso por empresas. Assim, em vez de manter internamente um DVCS, uma empresa desenvolvedora de software pode alugar esse servi√ßo do GitHub. Uma compara√ß√£o pode ser feita com servi√ßos de mail. Em vez de instalar um servidor de mail em uma m√°quina pr√≥pria, uma empresa pode contratar esse servi√ßo de terceiros, como do Google, via GMail. Apesar de o GitHub ser o mais popular, existem servi√ßos semelhantes providos por outras empresas, como GitLab e BitBucket.</p>
<p>No Ap√™ndice A, apresentamos e ilustramos os principais comandos do sistema Git. S√£o explicados tamb√©m os conceitos de forks e pull requests, os quais s√£o espec√≠ficos do GitHub.</p>
<h2 id="integra√ß√£o-cont√≠nua">10.3 Integra√ß√£o Cont√≠nua</h2>
<h3 id="motiva√ß√£o">Motiva√ß√£o</h3>
<p>Antes de definir o que √© integra√ß√£o cont√≠nua, vamos descrever o problema que levou √† proposta dessa pr√°tica de integra√ß√£o de c√≥digo. Tradicionalmente, era comum o uso de branches durante a implementa√ß√£o de novas funcionalidades. Branches podem ser entendidos como um sub-diret√≥rio interno e virtual, gerenciado pelo sistema de controle de vers√µes. Nesses sistemas, existe um branch principal, conhecido pelo nome de <strong>master</strong> (quando usa-se Git) ou <strong>trunk</strong> (quando usa-se outros sistemas, como svn). Al√©m do branch principal, os usu√°rios podem criar seus pr√≥prios branches.</p>
<p>Por exemplo, antes de implementar uma nova funcionalidade, era comum criar um branch apenas para conter o seu c√≥digo. Tais branches s√£o chamados de <strong>branches de funcionalidades (feature branches)</strong> e, dependendo da complexidade da funcionalidade, eles podiam levar meses para serem integrados de volta √† linha principal de desenvolvimento. Logo, era comum em sistemas maiores e mais complexos existirem dezenas de branches ativos.</p>
<p>Quando a implementa√ß√£o da nova funcionalidade terminava, o c√≥digo do branch era ‚Äúcopiado‚Äù de volta para o master, por meio de um comando do sistema de controle de vers√µes chamado <strong>merge</strong>. Nesse momento, uma variedade de conflitos poderia ocorrer, os quais s√£o conhecidos como <strong>conflitos de integra√ß√£o</strong> ou <strong>conflitos de merge</strong>.</p>
<p>Para ilustrar esses conflitos, suponha que Alice criou um branch para implementar uma nova funcionalidade X em seu sistema. Como essa funcionalidade era complexa, Alice trabalhou de forma isolada no seu branch por 40 dias, conforme ilustra a figura a seguir (cada nodo desse grafo √© um commit). Observe que enquanto Alice trabalhava ‚Äî realizando commits em seu branch ‚Äî tamb√©m ocorriam commits no branch principal.</p>
<figure>
<img src="figs/cap10/branch-funcional.svg" style="width:55.0%" alt="" /><figcaption>Desenvolvimento usando branches de funcionalidades.</figcaption>
</figure>
<p>Ent√£o, ap√≥s 40 dias, quando Alice integrou seu c√≥digo no master, surgiram diversos conflitos. Alguns deles s√£o descritos a seguir:</p>
<ul>
<li><p>Para implementar a funcionalidade X, o novo c√≥digo desenvolvido por Alice chamava uma fun√ß√£o <code>f1</code>, que existia no master no momento da cria√ß√£o do branch. Por√©m, no intervalo de 40 dias, a assinatura dessa fun√ß√£o foi modificada no master por outros desenvolvedores. Por exemplo, a fun√ß√£o pode ter sido renomeada ou ter ganho um novo par√¢metro. Ou ainda, em um cen√°rio mais radical, <code>f1</code> pode ter sido removida da linha principal de desenvolvimento.</p></li>
<li><p>Para implementar a funcionalidade X, Alice mudou o comportamento de uma fun√ß√£o <code>f2</code> do master. Por exemplo, <code>f2</code> retornava seu resultado em milhas e Alice alterou o seu c√≥digo para que o resultado fosse retornado em quil√¥metros. Evidentemente, Alice atualizou todo o c√≥digo que chamava <code>f2</code> no seu branch, para considerar resultados em quil√¥metros. Por√©m, no per√≠odo de 40 dias, surgiram novas chamadas de <code>f2</code>, que foram integradas no master, mas supondo um resultado ainda em milhas.</p></li>
</ul>
<p>Em sistemas grandes, com milhares de arquivos, dezenas de desenvolvedores e de branches funcionais, os problemas causados por conflitos podem assumir propor√ß√µes consider√°veis e atrasar a entrada em produ√ß√£o de novas funcionalidades. Veja que a resolu√ß√£o de conflitos √© uma tarefa manual, que requer an√°lise e consenso entre os desenvolvedores envolvidos. Por isso, o termo <strong>integration hell</strong> √© frequentemente usado para descrever os problemas que ocorrem durante a integra√ß√£o de branches de funcionalidades.</p>
<p>Adicionalmente, branches de funcionalidades, principalmente aqueles com dura√ß√£o longa, ajudam a criar silos de conhecimento. Isto √©, cada nova funcionalidade passa a ter um dono, pois um desenvolvedor ficou dedicado a ela por semanas. Assim, esse desenvolvedor pode sentir-se mais confort√°vel para adotar padr√µes diferentes do restante do time, incluindo padr√µes para leiaute do c√≥digo, para organiza√ß√£o de interfaces e telas, para acesso a dados, etc.</p>
<h3 id="o-que-√©-integra√ß√£o-cont√≠nua">O que √© Integra√ß√£o Cont√≠nua?</h3>
<p>Integra√ß√£o cont√≠nua (<em>continuous integration</em> ou CI) √© uma pr√°tica de desenvolvimento proposta por Extreme Programing (XP), conforme estudamos no Cap√≠tulo 2. O princ√≠pio motivador da pr√°tica j√° foi enunciado na Introdu√ß√£o deste cap√≠tulo: se uma tarefa causa ‚Äúdor‚Äù, n√£o podemos deixar que ela acumule. Em vez disso, devemos quebr√°-la em subtarefas que possam ser realizadas de forma frequente. Como essas subtarefas ser√£o pequenas e simples, a ‚Äúdor‚Äù decorrente da sua realiza√ß√£o ser√° menor.</p>
<p>Adaptando para o contexto de integra√ß√£o de c√≥digo, sabemos que grandes integra√ß√µes s√£o uma fonte de ‚Äúdor‚Äù para os desenvolvedores, pois eles t√™m que resolver de forma manual diversos conflitos. Assim, CI recomenda integrar o c√≥digo de forma frequente, isto √©, cont√≠nua. Como isso, as integra√ß√µes ser√£o pequenas e ir√£o gerar menos conflitos.</p>
<p>Kent Beck, em seu livro de XP, defende o uso de CI da seguinte forma (<a href="https://dl.acm.org/doi/book/10.5555/1076267">link</a>):</p>
<blockquote>
<p>Voc√™ deve integrar e testar o seu c√≥digo em intervalos menores do que algumas horas. Programa√ß√£o em times n√£o √© um problema do tipo dividir-e-conquistar. Na verdade, √© um problema que requer dividir, conquistar e integrar. A dura√ß√£o de uma tarefa de integra√ß√£o √© algo imprevis√≠vel e pode facilmente levar mais tempo do que a tarefa original de codifica√ß√£o. Assim, quanto mais tempo voc√™ levar para integrar, maiores e mais imprevis√≠veis ser√£o os custos.</p>
</blockquote>
<p>Nessa cita√ß√£o, Beck defende v√°rias integra√ß√µes ao longo de um dia de trabalho de um desenvolvedor. No entanto, essa recomenda√ß√£o n√£o √© consensual. Outros autores, como Fowler, mencionam pelo menos uma integra√ß√£o por dia por desenvolvedor (<a href="https://martinfowler.com/articles/continuousIntegration.html">link</a>), o que parece ser um limite m√≠nimo para um time argumentar que est√° usando CI.</p>
<h3 id="boas-pr√°ticas-para-uso-de-ci">Boas Pr√°ticas para Uso de CI</h3>
<p>Quando se usa CI, o master √© constantemente atualizado com c√≥digo novo. Para garantir que ele n√£o seja quebrado ‚Äî isto √©, deixe de compilar ou possua bugs ‚Äî, algumas pr√°ticas s√£o importantes quando se usa CI. Vamos discutir algumas delas a seguir.</p>
<h4 id="build-automatizado">Build Automatizado</h4>
<p>Quando se usa CI, deve ser poss√≠vel realizar uma compila√ß√£o completa do sistema e gerar uma vers√£o execut√°vel de forma automatizada, isto √©, sem interven√ß√£o manual. Al√©m disso, √© importante que o processo de build seja o mais r√°pido poss√≠vel, pois com integra√ß√£o cont√≠nua ele ser√° sempre executado.</p>
<h4 id="testes-automatizados">Testes Automatizados</h4>
<p>Al√©m de garantir que o sistema compila sem erros ap√≥s um novo commit, √© importante garantir tamb√©m que ele continua com o comportamento esperado. Por isso, ao usar CI, deve-se ter uma boa cobertura de testes, principalmente testes de unidade. Neste livro, testes de unidade j√° foram estudados no Cap√≠tulo 8.</p>
<h4 id="servidores-de-integra√ß√£o-cont√≠nua">Servidores de Integra√ß√£o Cont√≠nua</h4>
<p>Por fim, n√£o basta ter builds e testes automatizados. √â importante que eles sejam executados com frequ√™ncia, se poss√≠vel ap√≥s cada novo commit realizado no master. Para isso, existem Servidores de CI, que funcionam da seguinte forma (acompanhe tamb√©m pela pr√≥xima figura):</p>
<ul>
<li><p>Ap√≥s um novo commit, o sistema de controle de vers√µes avisa o servidor de CI, que executa ent√£o um build completo do sistema, bem como roda todos os testes.</p></li>
<li><p>Se ambos terminarem com sucesso, o servidor de integra√ß√£o notifica o controle de vers√µes, que integra o c√≥digo no master.</p></li>
<li><p>Por√©m, caso o build ou algum teste falhem, o servidor de CI notifica o desenvolvedor respons√°vel pelo commit que ele deve antes corrigir o seu c√≥digo.</p></li>
</ul>
<figure>
<img src="figs/cap10/ci-server.svg" style="width:50.0%" alt="" /><figcaption>Servidor de Integra√ß√£o Cont√≠nua</figcaption>
</figure>
<p>Existem diversos servidores de integra√ß√£o cont√≠nua no mercado. Alguns deles s√£o oferecidos como um servi√ßo independente, normalmente gratuito para reposit√≥rios de c√≥digo aberto, mas pago para reposit√≥rios privados de empresas. Assim, se voc√™ possui um reposit√≥rio aberto no GitHub, existe mais de uma op√ß√£o gratuita para ativar um servi√ßo de CI no mesmo.</p>
<p>Uma d√∫vida comum √© se CI √© compat√≠vel com o uso de branches. De forma coerente com a defini√ß√£o de CI, a melhor resposta √© a seguinte: sim, desde que os branches sejam integrados de forma frequente no master, via de regra, todo dia. Dizendo de outra forma, CI n√£o √© incompat√≠vel com branches, mas apenas com com branches com um tempo de vida elevado. Ainda nessa linha, Martin Fowler tem a seguinte observa√ß√£o sobre o uso de branches, especificamente branches de funcionalidades, junto com CI (<a href="https://martinfowler.com/bliki/FeatureBranch.html">link</a>):</p>
<blockquote>
<p>Na maioria das vezes, branches de funcionalidades constituem uma abordagem incompat√≠vel com CI. Um dos princ√≠pios de CI √© que todos devem enviar commits para a linha de desenvolvimento principal diariamente. Ent√£o, a n√£o ser que os branches de funcionalidades durem menos do que um dia, eles s√£o um ‚Äúanimal‚Äù diferente de CI. √â comum ouvir desenvolvedores dizendo que eles est√£o usando CI porque eles rodam builds autom√°ticos, talvez usando um servidor de CI, ap√≥s cada commit. Isso pode ser chamado de building cont√≠nuo e pode ser uma coisa boa‚Ä¶ Por√©m, como n√£o h√° integra√ß√£o, n√£o podemos chamar essa pr√°tica de CI.</p>
</blockquote>
<!---
O termo **Teatro de CI (CI Theater)** designa os cen√°rios nos quais uma organiza√ß√£o apenas instala uma servidor de CI. No entanto, os desenvolvedores n√£o integram seu c√≥digo diariamente e continuam trabalhando em branches de longa dura√ß√£o.
-->
<h4 id="desenvolvimento-baseado-no-trunk">Desenvolvimento Baseado no Trunk</h4>
<p>Como vimos, ao adotar CI, os branches devem durar no m√°ximo um dia de trabalho. Logo, o custo/benef√≠cio de cri√°-los pode n√£o compensar. Por isso, quando migram para CI, √© comum que as organiza√ß√µes usem tamb√©m <strong>desenvolvimento baseado no trunk</strong> (<em>trunk based development</em> ou TBD). Quando isso ocorre, n√£o existem mais branches para implementa√ß√£o de novas funcionalidades ou para corre√ß√£o de bugs. Em vez disso, todo desenvolvimento ocorre no branch principal, isto √©, no trunk ou master.</p>
<p>üåé <strong>Mundo Real</strong>: TBD √© usado por grandes empresas desenvolvedoras de software, incluindo Google e Facebook:</p>
<ul>
<li><p>No Google, "quase todo desenvolvimento ocorre no HEAD do reposit√≥rio [isto √©, no master]. Isso ajuda a identificar problemas de integra√ß√£o mais cedo e minimiza o esfor√ßo para realiza√ß√£o de merges. (<a href="https://arxiv.org/abs/1702.01715">link</a>)</p></li>
<li><p>No Facebook, ‚Äútodos engenheiros de front-end trabalham em um √∫nico branch que √© mantido sempre est√°vel, o que tamb√©m torna o desenvolvimento mais r√°pido, pois n√£o dispende-se esfor√ßo na integra√ß√£o de branches de longa dura√ß√£o no trunk.‚Äù (<a href="https://doi.org/10.1109/MIC.2013.25">link</a>)</p></li>
</ul>
<h2 id="entrega-cont√≠nua">10.5 Entrega Cont√≠nua</h2>
<h3 id="feature-flags">Feature Flags</h3>
<h2 id="infraestrutura-como-c√≥digo">10.6 Infraestrutura como C√≥digo</h2>
<h2 id="engenharia-de-releases">10.7 Engenharia de Releases</h2>
<h2 id="bibliografia">Bibliografia</h2>
<ul>
<li><p>Gene Kim, Jez Humble, John Willis, Patrick Debois. Manual de Devops. Como Obter Agilidade, Confiabilidade e Seguran√ßa em Organiza√ß√µes Tecnol√≥gicas. Alta Books, 2018.</p></li>
<li><p>Jez Humble, David Farley. Entrega Cont√≠nua: Como Entregar Software de Forma R√°pida e Confi√°vel. Bookman, 2014.</p></li>
<li><p>Steve Matyas, Andrew Glover, Paul M. Duvall. Continuous Integration: Improving Software Quality and Reducing Risk. Addison-Wesley, 2007.</p></li>
</ul>
<h2 id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o</h2>
<ol type="1">
<li>Pesquise na Internet o significado da express√£o Teatro de CI (<em>CI Theater</em>) e ent√£o descreva esse significado com suas pr√≥prias palavras.</li>
</ol>
</div>
</div>
</div>

<footer>
ASERG/DCC/UFMG. Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formul√°rio</a>.
</footer>
</body>
</html>
