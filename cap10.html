<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 10: DevOps ‚Äì Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-8249107-3"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-8249107-3', {'anonymize_ip': true});
  </script>

  <script>
  var trackOutboundLink = function(url, action, category) {
      gtag('event', action, {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': function(){document.location = url;}
      });
  }
  </script>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-8 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">
<img src="https://engsoftmoderna.info/figs/capa/capa-3d.jpg"></a>
</p>

<p>
<a href="https://engsoftmoderna.info">P√°gina principal do livro</a>
</p>

<p>Compre na

<a href="https://www.amazon.com.br/gp/product/6500019504">Amazon</a>, 

<a href="https://www.submarino.com.br/produto/1768283036/engenharia-de-software-moderna">
      Submarino</a> ou 

<a href="https://produto.mercadolivre.com.br/MLB-1552071489-engenharia-de-software-moderna-_JM">
      Mercado Livre</a>.
</p>

<p>
Veja tamb√©m nossos cursos de extens√£o a dist√¢ncia: 
<a href="http://www.engsoftmoderna.dcc.ufmg.br">Engenharia de Software Moderna</a> (48 horas) e
<a href="http://www.testesoft.dcc.ufmg.br">Teste de Software</a> (20 horas).</p>

<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<section id="devops" data-number="1">
<h1 data-number="10"><span class="header-section-number">10</span>
DevOps <a href="#devops" class="anchor-link"
aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>Imagine a world where product owners, development, QA, IT
Operations, and Infosec work together, not only to help each other, but
also to ensure that the overall organization succeeds.</em> ‚Äì Gene Kim,
Jez Humble, Patrick Debois, John Willis</p>
</blockquote>
<p>Este cap√≠tulo inicia discutindo o conceito de DevOps e seus
benef√≠cios (Se√ß√£o 10.1). Apesar de ser um termo novo, existe uma
tend√™ncia em ver DevOps como um movimento que visa introduzir pr√°ticas
√°geis <q>na √∫ltima milha</q> de um projeto de software, isto √©, quando o
sistema vai entrar em produ√ß√£o. Al√©m de discutir o conceito, tratamos de
tr√™s pr√°ticas importantes quando se adota DevOps. S√£o elas: Controle de
Vers√µes (Se√ß√£o 10.2), Integra√ß√£o Cont√≠nua (Se√ß√£o 10.3) e Deployment
Cont√≠nuo (Se√ß√£o 10.4).</p>
<section id="introdu√ß√£o" data-number="1.1">
<h2 data-number="10.1"><span class="header-section-number">10.1</span>
Introdu√ß√£o <a href="#introdu√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p>At√© agora, neste livro, estudamos um conjunto de pr√°ticas para
desenvolvimento de software com qualidade e agilidade. Por meio de
m√©todos √°geis ‚Äî como Scrum, XP ou Kanban ‚Äî, vimos que o cliente deve
participar desde o primeiro dia da constru√ß√£o de um sistema. Tamb√©m
estudamos pr√°ticas importantes para produ√ß√£o de software com qualidade,
como testes de unidade e refactoring. Estudamos ainda princ√≠pios e
padr√µes de projeto e tamb√©m padr√µes arquiteturais.</p>
<p>Logo, ap√≥s aplicar o que vimos, o sistema ‚Äî ou um incremento dele,
resultante de um sprint ‚Äî est√° pronto para entrar em produ√ß√£o. Essa
tarefa √© conhecida pelos nomes de <strong>implanta√ß√£o (deploy)</strong>,
<strong>libera√ß√£o (release)</strong> ou <strong>entrega
(delivery)</strong> do sistema. Independentemente do nome, ela n√£o √© t√£o
simples e r√°pida como pode parecer.</p>
<p>Historicamente, em organiza√ß√µes tradicionais, a √°rea de Tecnologia da
Informa√ß√£o era dividida em dois departamentos:</p>
<ul>
<li><p>Departamento de Sistemas (ou Desenvolvimento), formado por
desenvolvedores, programadores, analistas, arquitetos, etc.</p></li>
<li><p>Departamento de Suporte (ou Opera√ß√µes), no qual ficavam alocados
os administradores de rede, administradores de bancos de dados, t√©cnicos
de suporte, t√©cnicos de infraestrutura, etc.</p></li>
</ul>
<p>Hoje em dia, √© f√°cil imaginar os problemas causados por essa divis√£o.
Na maioria das vezes, a √°rea de suporte tomava conhecimento de um
sistema na v√©spera da sua implanta√ß√£o. Consequentemente, a implanta√ß√£o
poderia atrasar por meses, devido a uma variedade de problemas que n√£o
tinham sido identificados. Dentre eles, podemos citar a falta de
hardware para executar o novo sistema ou a nova funcionalidade,
problemas de desempenho, incompatibilidades com o banco de dados de
produ√ß√£o, vulnerabilidades de seguran√ßa, etc. No limite, esses problemas
poderiam resultar no cancelamento da implanta√ß√£o e no abandono do
sistema.</p>
<p> Resumindo, nesse modelo tradicional, existia um stakeholder
importante ‚Äî os administradores de sistemas ou <em>sysadmins</em> ‚Äî que
tomava conhecimento das caracter√≠sticas e requisitos n√£o-funcionais de
um novo software na v√©spera da implanta√ß√£o. Esse problema era agravado
pelo fato de os sistemas serem monolitos, cuja implanta√ß√£o gerava todo
tipo de preocupa√ß√£o, como mencionado no final do par√°grafo anterior.</p>
<p>Ent√£o, para facilitar a implanta√ß√£o e entrega de sistemas, foi
proposto o conceito de <strong>DevOps</strong>. Por ser um termo
recente, ele ainda n√£o possui uma defini√ß√£o consolidada. Mas seus
proponentes gostam de descrever DevOps como um movimento que visa
unificar as culturas de desenvolvimento (Dev) e de opera√ß√£o (Ops),
visando permitir a implanta√ß√£o mais r√°pida e √°gil de um sistema. Esse
objetivo est√° refletido na frase que abre esse cap√≠tulo, de autoria de
Gene Kim, Jez Humble, Patrick Debois e John Willes, todos eles membros
de um grupo de desenvolvedores que ajudou a difundir os princ√≠pios de
DevOps. Segundo eles, DevOps representa uma disrup√ß√£o na cultura
tradicional de implanta√ß√£o de sistemas (<a
href="https://dl.acm.org/doi/book/10.5555/3044729">link</a>):</p>
<blockquote>
<p><q>Em vez de iniciar as implanta√ß√µes √† meia-noite de sexta-feira e
passar o fim de semana trabalhando para conclu√≠-las, as implanta√ß√µes
ocorrem em qualquer dia √∫til, quando todos est√£o na empresa e sem que os
clientes percebam ‚Äî exceto quando encontram novas funcionalidades e
corre√ß√µes de bugs.</q></p>
</blockquote>
<p>No entanto, DevOps n√£o advoga a cria√ß√£o de um profissional novo, que
fique respons√°vel tanto pelo desenvolvimento como pela implanta√ß√£o de
sistemas. Em vez disso, defende-se uma aproxima√ß√£o entre o pessoal de
desenvolvimento e o pessoal de opera√ß√µes e vice-versa, visando fazer com
que a implanta√ß√£o de sistemas seja mais √°gil e menos traum√°tica.
Tentando explicar com outras palavras, a ideia √© evitar dois silos
independentes: desenvolvedores e operadores, com pouca ou nenhuma
intera√ß√£o entre eles, como ilustrado na figura a seguir.</p>
<figure>
<img src="figs/cap10/no-devops.svg" style="width:35.0%"
alt="Organiza√ß√£o que n√£o √© baseada em DevOps, pois existe pouca comunica√ß√£o entre Dev e Ops." />
<figcaption aria-hidden="true">Organiza√ß√£o que <strong>n√£o</strong> √©
baseada em DevOps, pois existe pouca comunica√ß√£o entre Dev e
Ops.</figcaption>
</figure>
<p>Em vez disso, defende-se que esses profissionais atuem em conjunto
desde os primeiros sprints de um projeto, como ilustrado na figura a
seguir. Para o cliente, o benef√≠cio deve ser a entrada em produ√ß√£o mais
cedo do sistema que ele contratou.</p>
<figure>
<img src="figs/cap10/devops.svg" style="width:35.0%"
alt="Organiza√ß√£o baseada em DevOps. Frequentemente, Devs e Ops sentam juntos para discutir quest√µes sobre a entrega do sistema." />
<figcaption aria-hidden="true">Organiza√ß√£o baseada em DevOps.
Frequentemente, Devs e Ops sentam juntos para discutir quest√µes sobre a
entrega do sistema.</figcaption>
</figure>
<p>Quando migra-se para uma cultura de DevOps, os times √°geis podem
incluir um profissional de opera√ß√µes, que participar√° dos trabalhos em
tempo parcial ou mesmo em tempo integral. Sempre em fun√ß√£o da demanda,
esse profissional pode tamb√©m participar de mais de um time. A ideia √©
que ele antecipe problemas de desempenho, seguran√ßa, incompatibilidades
com outros sistemas, etc. Ele pode tamb√©m, enquanto o c√≥digo est√° sendo
implementado, come√ßar a trabalhar nos scripts de instala√ß√£o,
administra√ß√£o e monitoramento do sistema em produ√ß√£o.</p>
<p>De forma n√£o menos importante, DevOps advoga a automatiza√ß√£o de todos
os passos necess√°rios para colocar um sistema em produ√ß√£o e monitorar o
seu correto funcionamento. Isso requer a ado√ß√£o de pr√°ticas que j√° vimos
neste livro, notadamente testes automatizados. Mas tamb√©m requer o
emprego de novas pr√°ticas e ferramentas, tais como Integra√ß√£o Cont√≠nua
(<em>Continuous Integration</em>) e Deployment Cont√≠nuo (<em>Continuous
Deployment</em>), que iremos estudar no presente cap√≠tulo.</p>
<p></p>
<p><strong>Mundo Real</strong>: O termo DevOps come√ßou a ser usado no
final dos anos 2000 por profissionais frustrados com os atritos
constantes entre as equipes de desenvolvimento e de opera√ß√µes. Ent√£o,
eles convenceram-se de que uma solu√ß√£o seria a ado√ß√£o de princ√≠pios
√°geis n√£o apenas na fase de desenvolvimento, mas tamb√©m na fase de
implanta√ß√£o de sistemas. Para citar uma data precisa, em Novembro de
2009 foi realizada, na B√©lgica, a primeira confer√™ncia da ind√∫stria
sobre o tema, chamada DevOpsDay. Considera-se que foi nesta confer√™ncia,
organizada por Patrick Dubois, que a palavra DevOps foi cunhada (<a
href="https://dl.acm.org/doi/book/10.5555/3044729">link</a>).</p>
<p> Para finalizar, vamos discutir um conjunto de princ√≠pios para
entrega de software, enunciados por Jez Humble e David Harley (<a
href="https://dl.acm.org/doi/book/10.5555/1869904">link</a>). Apesar de
propostos antes da ideia de DevOps ganhar tra√ß√£o, eles est√£o
completamente alinhados com essa ideia. Alguns desses princ√≠pios s√£o os
seguintes:</p>
<ul>
<li><p><strong>Crie um processo repet√≠vel e confi√°vel para entrega de
software</strong>. Esse princ√≠pio √© o mais importante deles. A ideia √©
que a entrega de software n√£o pode ser um evento traum√°tico, com passos
manuais e sujeitos a surpresas. Em vez disso, colocar um software em
produ√ß√£o deve ser t√£o simples como apertar um bot√£o.</p></li>
<li><p><strong>Automatize tudo que for poss√≠vel</strong>. Na verdade,
esse princ√≠pio √© um pr√©-requisito do princ√≠pio anterior. Advoga-se que
todos os passos para entrega de um software devem ser autom√°ticos,
incluindo seu <em>build</em>, a execu√ß√£o dos testes, a configura√ß√£o e
ativa√ß√£o dos servidores e da rede, a carga do banco de dados, etc. De
novo, idealmente, queremos apertar um bot√£o e, em seguida, ver o sistema
em produ√ß√£o.</p></li>
<li><p><strong>Mantenha tudo em um sistema de controle de
vers√µes</strong>. <q>Tudo</q> no enunciado do princ√≠pio refere-se n√£o
apenas a todo o c√≥digo fonte, mas tamb√©m arquivos e scripts de
administra√ß√£o do sistema, documenta√ß√£o, p√°ginas Web, arquivos de dados,
etc. Consequentemente, deve ser simples restaurar e voltar o sistema
para um estado anterior. Neste cap√≠tulo, iniciaremos estudando alguns
conceitos b√°sicos de <strong>Controle de Vers√µes</strong>, na Se√ß√£o
10.2. Al√©m disso, no Ap√™ndice A apresentamos o uso dos principais
comandos do sistema Git, que √© o sistema de controle de vers√µes mais
usado atualmente.</p></li>
<li><p><strong>Se um passo causa dor, execute-o com mais frequ√™ncia e o
quanto antes</strong>. Esse princ√≠pio n√£o tem uma inspira√ß√£o masoquista.
Em vez disso, a ideia √© antecipar os problemas, antes que eles se
acumulem e as solu√ß√µes fiquem complicadas. O exemplo cl√°ssico √© o de
<strong>Integra√ß√£o Cont√≠nua</strong>. Se um desenvolvedor passa muito
tempo trabalhando de forma isolada, ele e o seu time podem depois ter
uma grande dor de cabe√ßa para integrar o c√≥digo. Logo, como integra√ß√£o
pode causar dor, a recomenda√ß√£o consiste em integrar c√≥digo novo com
mais frequ√™ncia e o quanto antes, se poss√≠vel, diariamente. Iremos
estudar mais sobre integra√ß√£o cont√≠nua na Se√ß√£o 10.3.</p></li>
<li><p><strong><q>Conclu√≠do</q> significa pronto para entrega</strong>.
Com frequ√™ncia, desenvolvedores dizem que uma nova hist√≥ria est√° pronta
(<em>done</em>). Por√©m, ao serem questionados se ela pode entrar em
produ√ß√£o, come√ßam a surgir <q>pequenas</q> pend√™ncias, tais como: a
implementa√ß√£o ainda n√£o foi testada com dados reais, ela ainda n√£o foi
documentada, ela ainda n√£o foi integrada com o sistema X, etc. Esse
princ√≠pio defende ent√£o que <q>conclu√≠do</q>, em projetos de software,
deve ter uma sem√¢ntica clara, isto √©: 100% pronto para entrar em
produ√ß√£o.</p></li>
<li><p><strong>Todos s√£o respons√°veis pela entrega do software</strong>.
Esse √∫ltimo princ√≠pio alinha-se perfeitamente com a cultura de DevOps,
que discutimos no in√≠cio desta Introdu√ß√£o. Ou seja, n√£o admite-se mais
que os times de desenvolvimento e de opera√ß√µes trabalham em silos
independentes e troquem informa√ß√µes apenas na v√©spera de uma
implanta√ß√£o.</p></li>
</ul>
</section>
<section id="controle-de-vers√µes" data-number="1.2">
<h2 data-number="10.2"><span class="header-section-number">10.2</span>
Controle de Vers√µes <a href="#controle-de-vers√µes" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p>Como mencionamos algumas vezes neste livro, software √© desenvolvido
em equipe. Por isso, precisamos de um servidor para armazenar o c√≥digo
fonte do sistema que est√° sendo implementado por um grupo de
desenvolvedores. A exist√™ncia desse servidor √© fundamental para que
esses desenvolvedores possam colaborar e para que os operadores saibam
precisamente qual vers√£o do sistema deve ser colocada em produ√ß√£o. Al√©m
disso, sempre √© √∫til manter o hist√≥rico das vers√µes mais importantes de
cada arquivo. Isso permite, se necess√°rio, realizar uma esp√©cie de
<q>undo</q> no tempo, isto √©, recuperar o c√≥digo de um arquivo como ele
estava h√° anos atr√°s, por exemplo.</p>
<p> Um <strong>Sistema de Controle de Vers√µes</strong> (VCS, na sigla em
ingl√™s) oferece os dois servi√ßos mencionados no par√°grafo anterior.
Primeiro, ele oferece um <strong>reposit√≥rio</strong> para armazenar a
vers√£o mais recente do c√≥digo fonte de um sistema, bem como de arquivos
relacionados, como arquivos de documenta√ß√£o, configura√ß√£o, p√°ginas Web,
manuais, etc. Em segundo lugar, ele permite que se recupere vers√µes mais
antigas de qualquer arquivo, caso seja necess√°rio. Como enunciamos na
Introdu√ß√£o, modernamente √© inconceb√≠vel desenvolver qualquer sistema,
mesmo que simples, sem um VCS.</p>
<p> Os primeiros sistemas de controle de vers√µes surgiram no in√≠cio da
d√©cada de 70, como o sistema SCCS, desenvolvido para o sistema
operacional Unix. Em seguida, surgiram outros sistemas, como o CVS, em
meados da d√©cada de 80, e depois o sistema Subversion, tamb√©m conhecido
pela sigla svn, no in√≠cio dos anos 2000. Todos s√£o sistemas
centralizados e baseados em uma arquitetura cliente/servidor (veja
figura na pr√≥xima p√°gina). Nessa arquitetura, existe um √∫nico servidor,
que armazena o reposit√≥rio e o sistema de controle de vers√µes. Os
clientes acessam esse servidor para obter a vers√£o mais recente de um
arquivo. Feito isso, eles podem modificar o arquivo, por exemplo, para
corrigir um bug ou implementar uma nova funcionalidade. Por fim, eles
atualizam o arquivo no servidor, realizando uma opera√ß√£o chamada
<strong>commit</strong>, que torna o arquivo vis√≠vel para outros
desenvolvedores.</p>
<figure>
<img src="figs/cap10/vcs.svg" style="width:50.0%"
alt="VCS Centralizado. Existe um √∫nico reposit√≥rio, no nodo servidor." />
<figcaption aria-hidden="true">VCS Centralizado. Existe um √∫nico
reposit√≥rio, no nodo servidor.</figcaption>
</figure>
<p> No in√≠cio dos anos 2000, come√ßaram a surgir <strong>Sistemas de
Controle de Vers√µes Distribu√≠dos</strong> (DVCS). Dentre eles, podemos
citar o sistema BitKeeper, cujo primeiro release √© de 2000, e os
sistemas Mercurial e git, ambos lan√ßados em 2005. Em vez de uma
arquitetura cliente/servidor, um DVCS adota uma arquitetura
peer-to-peer. Na pr√°tica, isso significa que cada desenvolvedor possui
em sua m√°quina um servidor completo de controle de vers√µes, que pode se
comunicar com os servidores de outras m√°quinas, como ilustrado na
pr√≥xima figura.</p>
<figure>
<img src="figs/cap10/dvcs.svg" style="width:50.0%"
alt="VCS Distribu√≠do (DVCS). Cada cliente possui um servidor. Logo, a arquitetura √© peer-to-peer." />
<figcaption aria-hidden="true">VCS Distribu√≠do (DVCS). Cada cliente
possui um servidor. Logo, a arquitetura √© peer-to-peer.</figcaption>
</figure>
<p>Em teoria, quando se usa um DVCS, os clientes (ou <em>peers</em>) s√£o
funcionalmente equivalentes. Por√©m, na pr√°tica, costuma existir uma
m√°quina principal, que armazena a vers√£o de refer√™ncia do c√≥digo fonte.
Na nossa figura, chamamos esse reposit√≥rio de <strong>reposit√≥rio
central</strong>. Cada desenvolvedor pode trabalhar de forma
independente e at√© mesmo offline em sua m√°quina cliente, realizando
commits no seu reposit√≥rio. De tempos em tempos, ele deve sincronizar
esse reposit√≥rio com o central, por meio de duas opera√ß√µes:
<strong>pull</strong> e <strong>push</strong>. Um pull atualiza o
reposit√≥rio local com novos commits dispon√≠veis no reposit√≥rio central.
Por sua vez, um push faz a opera√ß√£o contr√°ria, isto √©, ele envia para o
reposit√≥rio central os commits mais recentes realizados pelo
desenvolvedor em seu reposit√≥rio local.</p>
<p>Quando comparado com VCS centralizados, um DVCS tem as seguintes
vantagens:</p>
<ul>
<li><p>Pode-se trabalhar e gerenciar vers√µes de forma offline, sem estar
conectado a uma rede, pois os commits s√£o realizados primeiro no
reposit√≥rio instalado localmente na m√°quina do desenvolvedor.</p></li>
<li><p>Pode-se realizar commits com mais frequ√™ncia, incluindo commits
com implementa√ß√µes parciais, pois eles n√£o v√£o chegar imediatamente at√©
o reposit√≥rio central.</p></li>
<li><p>Commits s√£o executados em menos tempo, isto √©, eles s√£o opera√ß√µes
mais r√°pidas e leves. O motivo √© que eles s√£o realizados no reposit√≥rio
local de cada m√°quina.</p></li>
<li><p>A sincroniza√ß√£o n√£o precisa ser sempre com o reposit√≥rio central.
Em vez disso, dois nodos podem tamb√©m sincronizar os seus reposit√≥rios.
Por exemplo, pode-se ter uma estrutura hier√°rquica dos reposit√≥rios.
Nesses casos, os commits <q>nascem</q> nos reposit√≥rios que representam
as folhas da hierarquia e v√£o subindo at√© chegar ao reposit√≥rio
central.</p></li>
</ul>
<p> <strong>Git</strong> √© um sistema de controle de vers√µes distribu√≠do
cujo desenvolvimento foi liderado por Linus Torvalds, tamb√©m respons√°vel
pela cria√ß√£o do sistema operacional Linux. Nos anos iniciais, o
desenvolvimento do kernel do Linux usava um sistema de controle de
vers√µes comercial, chamado BitKeeper, que tamb√©m possui uma arquitetura
distribu√≠da. No entanto, em 2005, a empresa propriet√°ria do BitKeeper
resolveu revogar as licen√ßas gratuitas que eram usadas no
desenvolvimento do Linux. Os desenvolvedores do sistema operacional,
liderados por Torvalds, decidiram ent√£o iniciar a implementa√ß√£o de um
DVCS pr√≥prio, ao qual deram o nome de Git. Assim como o Linux, o Git √©
um sistema de c√≥digo aberto, que pode ser gratuitamente instalado em
qualquer m√°quina. O Git √© tamb√©m um sistema de linha de comando. Por√©m,
existem clientes com interfaces gr√°ficas, desenvolvidos por terceiros,
que permitem usar o sistema sem ter que digitar comandos.</p>
<p> <strong>GitHub</strong> √© um servi√ßo de hospedagem de c√≥digo que usa
o sistema Git para prover controle de vers√µes. O GitHub oferece
reposit√≥rios p√∫blicos e gratuitos, para projetos de c√≥digo aberto, e
reposit√≥rios fechados e pagos, para uso por empresas. Assim, em vez de
manter internamente um DVCS, uma empresa desenvolvedora de software pode
alugar esse servi√ßo do GitHub. Uma compara√ß√£o pode ser feita com
servi√ßos de mail. Em vez de instalar um servidor de mail em uma m√°quina
pr√≥pria, uma empresa pode contratar esse servi√ßo de terceiros, como do
Google, via GMail. Apesar de o GitHub ser o mais popular, existem
servi√ßos semelhantes providos por outras empresas, como GitLab e
BitBucket.</p>
<p>No Ap√™ndice A, apresentamos e ilustramos os principais comandos do
sistema Git. S√£o explicados tamb√©m os conceitos de forks e pull
requests, os quais s√£o espec√≠ficos do GitHub.</p>
<section id="multirepos-vs-monorepos" data-number="1.2.1">
<h3 data-number="10.2.1"><span
class="header-section-number">10.2.1</span> Multirepos vs Monorepos <a
href="#multirepos-vs-monorepos" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Um VCS gerencia reposit√≥rios. Assim, uma organiza√ß√£o precisa decidir
os reposit√≥rios que vai criar em seu VCS. Uma decis√£o tradicional
consiste em criar um reposit√≥rio para cada projeto ou sistema da
organiza√ß√£o. Por√©m, solu√ß√µes baseadas em um √∫nico reposit√≥rio est√£o
sendo adotadas com mais frequ√™ncia, principalmente por grandes empresas,
como Google, Facebook e Microsoft. Essas duas alternativas ‚Äî chamadas,
respectivamente, de <strong>multirepos</strong> e
<strong>monorepos</strong> ‚Äî s√£o ilustradas nas pr√≥ximas duas
figuras.</p>
<figure>
<img src="figs/cap10/multirepos.svg" style="width:40.0%"
alt="Multirepos: um VCS gerencia v√°rios reposit√≥rios. Normalmente, um reposit√≥rio por projeto ou sistema." />
<figcaption aria-hidden="true">Multirepos: um VCS gerencia v√°rios
reposit√≥rios. Normalmente, um reposit√≥rio por projeto ou
sistema.</figcaption>
</figure>
<figure>
<img src="figs/cap10/monorepo.svg" style="width:40.0%"
alt="Monorepos: VCS gerencia um √∫nico reposit√≥rio. Projetos s√£o diret√≥rios desse reposit√≥rio." />
<figcaption aria-hidden="true">Monorepos: VCS gerencia um √∫nico
reposit√≥rio. Projetos s√£o diret√≥rios desse reposit√≥rio.</figcaption>
</figure>
<p>Se pensarmos em contas do GitHub, podemos exemplificar da seguinte
forma:</p>
<ul>
<li><p>Se optar por multirepos, uma organiza√ß√£o ter√° v√°rios
reposit√≥rios, tais como <code>aserg-ufmg/sistema1</code>,
<code>aserg-ufmg/sistema2</code>, <code>aserg-ufmg/sistema3</code>,
etc.</p></li>
<li><p>Se optar por monorepos, ela ter√° um √∫nico reposit√≥rio ‚Äî digamos,
<code>aserg-ufmg/aserg-ufmg</code>. No diret√≥rio raiz desse reposit√≥rio,
teremos os subdiret√≥rios <code>sistema1</code>, <code>sistema2</code>,
<code>sistema3</code>, etc.</p></li>
</ul>
<p>Dentre as vantagens de monorepos podemos citar:</p>
<ul>
<li><p>Como existe um √∫nico reposit√≥rio, n√£o h√° d√∫vida sobre qual
reposit√≥rio possui a vers√£o mais atualizada de um arquivo. Isto √©, com
monorepos, existe uma √∫nica fonte de <q>verdade</q> sobre vers√µes do
c√≥digo fonte.</p></li>
<li><p>Monorepos incentivam o re√∫so e compartilhamento de c√≥digo, pois
os desenvolvedores t√™m acesso mais r√°pido a qualquer arquivo, de
qualquer sistema.</p></li>
<li><p>Mudan√ßas s√£o sempre at√¥micas. Com multirepos, dois commits podem
ser necess√°rios para implementar uma √∫nica mudan√ßa, caso ela afete dois
sistemas. Com monorepos, a mesma mudan√ßa pode ser realizada por meio de
um √∫nico commit.</p></li>
<li><p>Facilita a execu√ß√£o de refactorings em larga escala. Por exemplo,
suponha a renomea√ß√£o de uma fun√ß√£o utilit√°ria que √© usada em todos os
sistemas da organiza√ß√£o. Com monorepos, essa renomea√ß√£o pode ser
realizada com um √∫nico commit.</p></li>
</ul>
<p> Por outro lado, monorepos requerem ferramentas para navegar em
grandes bases de c√≥digo. O motivo √© que cada desenvolvedor ter√° em seu
reposit√≥rio local todos os arquivos de todos os sistemas da organiza√ß√£o.
Por isso, os respons√°veis pelo monorepo do Google comentam que foram
obrigados a implementar internamente um plug-in para a IDE Eclipse, que
facilita o trabalho com uma base de c√≥digo muito grande, como a que eles
possuem na empresa (<a
href="https://doi.org/10.1145/2854146">link</a>).</p>
</section>
</section>
<section id="integra√ß√£o-cont√≠nua" data-number="1.3">
<h2 data-number="10.3"><span class="header-section-number">10.3</span>
Integra√ß√£o Cont√≠nua <a href="#integra√ß√£o-cont√≠nua" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Para explicar o conceito de Integra√ß√£o Cont√≠nua (CI), iniciamos com
uma subse√ß√£o de motiva√ß√£o. Em seguida, apresentamos o conceito
propriamente dito. Feito isso, discutimos outras pr√°ticas que uma
organiza√ß√£o deve adotar junto com CI. Terminamos com uma breve discuss√£o
sobre cen√°rios que podem desmotivar o emprego de CI em uma
organiza√ß√£o.</p>
<section id="motiva√ß√£o" data-number="1.3.1">
<h3 data-number="10.3.1"><span
class="header-section-number">10.3.1</span> Motiva√ß√£o <a
href="#motiva√ß√£o" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p>Antes de definir o que √© integra√ß√£o cont√≠nua, vamos descrever o
problema que levou √† proposta dessa pr√°tica de integra√ß√£o de c√≥digo.
Tradicionalmente, era comum o uso de branches durante a implementa√ß√£o de
novas funcionalidades. Branches podem ser entendidos como um
sub-diret√≥rio interno e virtual, gerenciado pelo sistema de controle de
vers√µes. Nesses sistemas, existe um branch principal, conhecido pelo
nome de <strong>master</strong> (quando usa-se Git) ou
<strong>trunk</strong> (quando usa-se outros sistemas, como svn). Al√©m
do branch principal, os usu√°rios podem criar seus pr√≥prios branches.</p>
<p>Por exemplo, antes de implementar uma nova funcionalidade, pode ser
comum criar um branch para conter o seu c√≥digo. Tais branches s√£o
chamados de <strong>branches de funcionalidades (feature
branches)</strong> e, dependendo da complexidade da funcionalidade, eles
podem levar meses para serem integrados de volta √† linha principal de
desenvolvimento. Logo, em sistemas maiores e mais complexos podem
existir dezenas de branches ativos.</p>
<p> Quando a implementa√ß√£o da nova funcionalidade terminar, o c√≥digo do
branch deve ser <q>copiado</q> de volta para o master, por meio de um
comando do sistema de controle de vers√µes chamado
<strong>merge</strong>. Nesse momento, uma variedade de conflitos pode
ocorrer, os quais s√£o conhecidos como <strong>conflitos de
integra√ß√£o</strong> ou <strong>conflitos de merge</strong>.</p>
<p>Para ilustrar esse cen√°rio, suponha que Alice criou um branch para
implementar uma nova funcionalidade X em seu sistema. Como essa
funcionalidade era complexa, Alice trabalhou de forma isolada no seu
branch por 40 dias, conforme ilustrado na figura da pr√≥xima p√°gina (cada
nodo desse grafo √© um commit). Observe que enquanto Alice trabalhava ‚Äî
realizando commits em seu branch ‚Äî tamb√©m ocorriam commits no branch
principal.</p>
<figure>
<img src="figs/cap10/branch-funcional.svg" style="width:75.0%"
alt="Desenvolvimento usando branches de funcionalidades." />
<figcaption aria-hidden="true">Desenvolvimento usando branches de
funcionalidades.</figcaption>
</figure>
<p>Ent√£o, ap√≥s 40 dias, quando Alice integrou seu c√≥digo no master,
surgiram diversos conflitos. Alguns deles s√£o descritos a seguir:</p>
<ul>
<li><p>Para implementar a funcionalidade X, o c√≥digo desenvolvido por
Alice chamava uma fun√ß√£o <code>f1</code>, que existia no master no
momento da cria√ß√£o do branch. Por√©m, no intervalo de 40 dias, a
assinatura dessa fun√ß√£o foi modificada no master por outros
desenvolvedores. Por exemplo, a fun√ß√£o pode ter sido renomeada ou ter
ganho um novo par√¢metro. Ou ainda, em um cen√°rio mais radical,
<code>f1</code> pode ter sido removida da linha principal de
desenvolvimento.</p></li>
<li><p>Para implementar a funcionalidade X, Alice mudou o comportamento
de uma fun√ß√£o <code>f2</code> do master. Por exemplo, <code>f2</code>
retornava seu resultado em milhas e Alice alterou o seu c√≥digo para que
o resultado fosse retornado em quil√¥metros. Evidentemente, Alice
atualizou todo o c√≥digo que chamava <code>f2</code> no seu branch, para
considerar resultados em quil√¥metros. Por√©m, no per√≠odo de 40 dias,
surgiram novas chamadas de <code>f2</code>, que foram integradas no
master, mas supondo um resultado ainda em milhas.</p></li>
</ul>
<p> Em sistemas grandes, com milhares de arquivos, dezenas de
desenvolvedores e de branches de funcionalidades, os problemas causados
por conflitos podem assumir propor√ß√µes consider√°veis e atrasar a entrada
em produ√ß√£o de novas funcionalidades. Veja que a resolu√ß√£o de conflitos
√© uma tarefa manual, que requer an√°lise e consenso entre os
desenvolvedores envolvidos. Por isso, os termos <strong>integration
hell</strong> ou <strong>merge hell</strong> s√£o usados para descrever
os problemas que ocorrem durante a integra√ß√£o de branches de
funcionalidades.</p>
<p>Adicionalmente, branches de funcionalidades, principalmente aqueles
com dura√ß√£o longa, ajudam a criar silos de conhecimento. Isto √©, cada
nova funcionalidade passa a ter um dono, pois um desenvolvedor ficou
dedicado a ela por semanas. Por isso, esse desenvolvedor pode sentir-se
confort√°vel para adotar padr√µes diferentes do restante do time,
incluindo padr√µes para leiaute do c√≥digo, para organiza√ß√£o de janelas e
telas, para acesso a bancos de dados, etc.</p>
</section>
<section id="o-que-√©-integra√ß√£o-cont√≠nua" data-number="1.3.2">
<h3 data-number="10.3.2"><span
class="header-section-number">10.3.2</span> O que √© Integra√ß√£o Cont√≠nua?
<a href="#o-que-√©-integra√ß√£o-cont√≠nua" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p><strong>Integra√ß√£o Cont√≠nua</strong> (<em>Continuous Integration</em>
ou CI) √© uma pr√°tica de desenvolvimento proposta por Extreme Programming
(XP). O princ√≠pio motivador da pr√°tica j√° foi comentado na Introdu√ß√£o do
presente cap√≠tulo: se uma tarefa causa <q>dor</q>, n√£o podemos deixar
que ela acumule. Em vez disso, devemos quebr√°-la em subtarefas que
possam ser realizadas de forma frequente. Como essas subtarefas s√£o
pequenas e simples, a <q>dor</q> decorrente da sua realiza√ß√£o ser√°
menor.</p>
<p>Adaptando para o contexto de integra√ß√£o de c√≥digo, sabemos que
grandes integra√ß√µes s√£o uma fonte de <q>dor</q> para os desenvolvedores,
pois eles t√™m que resolver de forma manual diversos conflitos. Assim, CI
recomenda integrar o c√≥digo de forma frequente, isto √©, cont√≠nua. Com
isso, as integra√ß√µes ser√£o pequenas e ir√£o gerar menos conflitos.</p>
<p> Kent Beck, em seu livro de XP, defende o uso de CI da seguinte forma
(<a href="https://dl.acm.org/doi/book/10.5555/1076267">link</a>):</p>
<blockquote>
<p><q>Voc√™ deve integrar e testar o seu c√≥digo em intervalos menores do
que algumas horas. Programa√ß√£o em times n√£o √© um problema do tipo
dividir-e-conquistar. Na verdade, √© um problema que requer dividir,
conquistar e integrar. A dura√ß√£o de uma tarefa de integra√ß√£o √©
imprevis√≠vel e pode facilmente levar mais tempo do que a tarefa original
de codifica√ß√£o. Assim, quanto mais tempo voc√™ demorar para integrar,
maiores e mais imprevis√≠veis ser√£o os custos.</q></p>
</blockquote>
<p> Nessa cita√ß√£o, Beck defende v√°rias integra√ß√µes ao longo de um dia de
trabalho de um desenvolvedor. No entanto, essa recomenda√ß√£o n√£o √©
consensual. Outros autores, como Martin Fowler, mencionam pelo menos uma
integra√ß√£o por dia por desenvolvedor (<a
href="https://martinfowler.com/articles/continuousIntegration.html">link</a>),
o que parece ser um limite m√≠nimo para um time argumentar que est√°
usando CI.</p>
</section>
<section id="boas-pr√°ticas-para-uso-de-ci" data-number="1.3.3">
<h3 data-number="10.3.3"><span
class="header-section-number">10.3.3</span> Boas Pr√°ticas para Uso de CI
<a href="#boas-pr√°ticas-para-uso-de-ci" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Quando usa-se CI, o master √© constantemente atualizado com c√≥digo
novo. Para garantir que ele n√£o seja quebrado ‚Äî isto √©, deixe de
compilar ou possua bugs ‚Äî, recomenda-se o uso de algumas pr√°ticas em
conjunto com CI, as quais vamos discutir a seguir.</p>
<h4 class="unnumbered" id="build-automatizado">Build Automatizado <a
href="#build-automatizado" class="anchor-link"
aria-hidden="true">üîó</a></h4>
<p>Build √© o nome usado para designar a compila√ß√£o de todos os arquivos
de um sistema, at√© a gera√ß√£o de uma vers√£o execut√°vel. Quando se usa CI,
o build deve ser automatizado, isto √©, n√£o incluir nenhum passo manual.
Al√©m disso, √© importante que ele seja o mais r√°pido poss√≠vel, pois com
integra√ß√£o cont√≠nua ele ser√° sempre executado. Alguns autores, por
exemplo, chegam a recomendar um limite de 10 minutos para execu√ß√£o de um
build (<a
href="https://dl.acm.org/doi/book/10.5555/318762">link</a>).</p>
<h4 class="unnumbered" id="testes-automatizados">Testes Automatizados <a
href="#testes-automatizados" class="anchor-link"
aria-hidden="true">üîó</a></h4>
<p>Al√©m de garantir que o sistema compila sem erros ap√≥s cada novo
commit, √© importante garantir tamb√©m que ele continua com o
comportamento esperado. Por isso, ao usar CI, deve-se ter uma boa
cobertura de testes, principalmente testes de unidade, conforme
estudamos no Cap√≠tulo 8.</p>
<h4 class="unnumbered" id="servidores-de-integra√ß√£o-cont√≠nua">Servidores
de Integra√ß√£o Cont√≠nua <a href="#servidores-de-integra√ß√£o-cont√≠nua"
class="anchor-link" aria-hidden="true">üîó</a></h4>
<p> </p>
<p>Por fim, os builds e testes automatizados devem ser executados com
frequ√™ncia, se poss√≠vel ap√≥s cada novo commit realizado no master. Para
isso, existem <strong>Servidores de CI</strong>, que funcionam da
seguinte forma (acompanhe tamb√©m pela pr√≥xima figura):</p>
<ul>
<li><p>Ap√≥s um novo commit, o sistema de controle de vers√µes avisa o
servidor de CI, que clona o reposit√≥rio e executa um build completo do
sistema, bem como roda todos os testes.</p></li>
<li><p>Ap√≥s a execu√ß√£o do build e dos testes, o servidor notifica o
usu√°rio.</p></li>
</ul>
<figure>
<img src="figs/cap10/ci-server.svg" style="width:80.0%"
alt="Servidor de Integra√ß√£o Cont√≠nua" />
<figcaption aria-hidden="true">Servidor de Integra√ß√£o
Cont√≠nua</figcaption>
</figure>
<p>O objetivo principal de um servidor de integra√ß√£o cont√≠nua √© evitar a
integra√ß√£o de c√≥digo com problemas, sejam eles de build ou de
comportamento. Quando o build falha, costuma-se dizer que ele
<q>quebrou</q>. Com frequ√™ncia, o build na m√°quina do desenvolvedor pode
ter sido conclu√≠do com sucesso. Mas ao ser executado no servidor de CI,
ele pode falhar. Isso ocorre, por exemplo, quando o desenvolvedor
esquece de realizar o commit de algum arquivo. Depend√™ncias incorretas
s√£o um outro motivo para quebra de builds. Por exemplo, o c√≥digo pode
ter sido compilado e testado na m√°quina do desenvolvedor usando a vers√£o
2.0 de uma determinada biblioteca, mas o servidor de CI realiza o build
usando a vers√£o 1.0.</p>
<p>Se o servidor de CI notificar o desenvolvedor de que seu c√≥digo n√£o
passou nos testes ou quebrou o build, ele deve parar tudo o que est√°
fazendo e providenciar a corre√ß√£o. Isso √© importante porque um build
quebrado impacta o trabalho dos outros desenvolvedores, pois eles n√£o
v√£o conseguir mais compilar ou executar o sistema. Costuma-se dizer que
nada em uma empresa de software tem maior prioridade do que a corre√ß√£o
de um build quebrado. No entanto, a solu√ß√£o pode ser simplesmente
reverter o c√≥digo para a vers√£o anterior ao commit com problemas.</p>
<p>Ainda nesta linha de racioc√≠nio, um desenvolvedor somente deve
avan√ßar para uma pr√≥xima tarefa de programa√ß√£o ap√≥s receber o resultado
do servidor de CI. Por exemplo, ele n√£o deve come√ßar a escrever c√≥digo
novo antes de ter certeza de que seu √∫ltimo commit passou pelo servi√ßo
de CI. Ele tamb√©m n√£o deve iniciar outras tarefas importantes, como
entrar em uma reuni√£o, sair para almo√ßar ou ir para a casa, antes do
resultado desse servidor.</p>
<p>Existem diversos servidores de integra√ß√£o cont√≠nua no mercado. Alguns
deles s√£o oferecidos como um servi√ßo independente, normalmente gratuito
para reposit√≥rios de c√≥digo aberto, mas pago para reposit√≥rios privados
de empresas. Assim, se voc√™ possui um reposit√≥rio aberto no GitHub,
existe mais de uma op√ß√£o gratuita para ativar um servi√ßo de CI no
mesmo.</p>
<p>Uma d√∫vida comum √© se CI √© compat√≠vel com o uso de branches. Mantendo
coer√™ncia com a defini√ß√£o de CI, a melhor resposta √© a seguinte: sim,
desde que os branches sejam integrados de forma frequente no master, via
de regra, todo dia. Dizendo de outra forma, CI n√£o √© incompat√≠vel com
branches, mas apenas com branches com um tempo de vida elevado. Por
exemplo, Martin Fowler tem a seguinte observa√ß√£o sobre o uso de
branches, especificamente branches de funcionalidades, junto com CI (<a
href="https://martinfowler.com/bliki/FeatureBranch.html">link</a>):</p>
<p></p>
<blockquote>
<p><q>Na maioria das vezes, branches de funcionalidades constituem uma
abordagem incompat√≠vel com CI. Um dos princ√≠pios de CI √© que todos devem
enviar commits para a linha de desenvolvimento principal diariamente.
Ent√£o, a n√£o ser que os branches de funcionalidades durem menos do que
um dia, eles s√£o um animal diferente de CI. √â comum ouvir
desenvolvedores dizendo que eles est√£o usando CI porque eles rodam
builds autom√°ticos, talvez usando um servidor de CI, ap√≥s cada commit.
Isso pode ser chamado de building cont√≠nuo e pode ser uma coisa boa.
Por√©m, como n√£o h√° integra√ß√£o, n√£o podemos chamar essa pr√°tica de
CI.</q></p>
</blockquote>
<h4 class="unnumbered"
id="desenvolvimento-baseado-no-trunk">Desenvolvimento Baseado no Trunk
<a href="#desenvolvimento-baseado-no-trunk" class="anchor-link"
aria-hidden="true">üîó</a></h4>
<p> </p>
<p>Como vimos, ao adotar CI, branches devem durar no m√°ximo um dia de
trabalho. Logo, o custo/benef√≠cio de cri√°-los pode n√£o compensar. Por
isso, quando migram para CI, √© comum que as organiza√ß√µes usem tamb√©m
<strong>desenvolvimento baseado no trunk</strong> (<em>trunk based
development</em> ou TBD). Com TBD, n√£o existem mais branches para
implementa√ß√£o de novas funcionalidades ou para corre√ß√£o de bugs. Em vez
disso, todo desenvolvimento ocorre no branch principal, tamb√©m conhecido
com trunk ou master.</p>
<p><strong>Mundo Real</strong>: TBD √© usado por grandes empresas
desenvolvedoras de software, incluindo Google e Facebook:</p>
<ul>
<li><p>No Google, <q>quase todo desenvolvimento ocorre no HEAD do
reposit√≥rio [isto √©, no master]. Isso ajuda a identificar problemas de
integra√ß√£o mais cedo e minimiza o esfor√ßo para realiza√ß√£o de merges.</q>
(<a href="https://arxiv.org/abs/1702.01715">link</a>)</p></li>
<li><p>No Facebook, <q>todos engenheiros de front-end trabalham em um
√∫nico branch que √© mantido sempre est√°vel, o que tamb√©m torna o
desenvolvimento mais r√°pido, pois n√£o dispende-se esfor√ßo na integra√ß√£o
de branches de longa dura√ß√£o no trunk.</q> (<a
href="https://doi.org/10.1109/MIC.2013.25">link</a>)</p></li>
</ul>
<h4 class="unnumbered" id="programa√ß√£o-em-pares">Programa√ß√£o em Pares <a
href="#programa√ß√£o-em-pares" class="anchor-link"
aria-hidden="true">üîó</a></h4>
<p>Programa√ß√£o em Pares (<em>Pair Programming</em>) pode ser considerada
uma forma cont√≠nua de revis√£o de c√≥digo. Quando se adota essa pr√°tica,
qualquer novo trecho de c√≥digo √© revisado por um outro desenvolvedor,
que encontra-se sentado ao lado do desenvolvedor l√≠der da sess√£o de
programa√ß√£o. Portanto, assim como builds e testes cont√≠nuos,
recomenda-se usar programa√ß√£o em pares com CI. Por√©m, esse uso tamb√©m
n√£o √© obrigat√≥rio. Por exemplo, o c√≥digo pode ser revisado ap√≥s o commit
ser realizado no master. No entanto, nesse caso, como o c√≥digo j√° foi
integrado, os custos de aplicar a revis√£o podem ser maiores.</p>
</section>
<section id="quando-n√£o-usar-ci" data-number="1.3.4">
<h3 data-number="10.3.4"><span
class="header-section-number">10.3.4</span> Quando n√£o usar CI? <a
href="#quando-n√£o-usar-ci" class="anchor-link"
aria-hidden="true">üîó</a></h3>
<p></p>
<p>Os proponentes de CI definem um limite r√≠gido para integra√ß√µes no
master: pelo menos uma integra√ß√£o por dia por desenvolvedor. No entanto,
dependendo da organiza√ß√£o, do dom√≠nio do sistema (que pode ser um
sistema cr√≠tico) e do perfil dos desenvolvedores (que podem ser
iniciantes), pode ser dif√≠cil seguir esse limite.</p>
<p>Por outro lado, √© bom lembrar que esse limite n√£o √© uma lei da
natureza. Por exemplo, talvez seja mais fact√≠vel realizar uma integra√ß√£o
a cada dois ou tr√™s dias. Na verdade, qualquer pr√°tica de Engenharia de
Software ‚Äî incluindo integra√ß√£o cont√≠nua ‚Äî n√£o deve ser considerada ao
p√© da letra, isto √©, exatamente como est√° descrita no manual ou neste
livro-texto. Adapta√ß√µes justificadas pelo contexto da organiza√ß√£o s√£o
poss√≠veis e devem ser consideradas. Experimenta√ß√£o com diferentes
intervalos de integra√ß√£o pode tamb√©m ajudar a definir a melhor
configura√ß√£o para uma organiza√ß√£o.</p>
<p>CI tamb√©m n√£o √© compat√≠vel com projetos de c√≥digo livre. Na maioria
das vezes, os desenvolvedores desses projetos s√£o volunt√°rios e n√£o t√™m
disponibilidade para trabalhar diariamente no seu c√≥digo. Nesses casos,
um modelo baseado em Pull Requests e Forks, conforme usado pelo GitHub,
√© mais adequado.</p>
</section>
</section>
<section id="deployment-cont√≠nuo" data-number="1.4">
<h2 data-number="10.4"><span class="header-section-number">10.4</span>
Deployment Cont√≠nuo <a href="#deployment-cont√≠nuo" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p></p>
<p>Com integra√ß√£o cont√≠nua, c√≥digo novo √© frequentemente integrado no
branch principal. No entanto, esse c√≥digo n√£o precisa estar pronto para
entrar em produ√ß√£o. Ou seja, ele pode ser uma vers√£o preliminar, que foi
integrado para que os outros desenvolvedores tomem ci√™ncia da sua
exist√™ncia e, consequentemente, evitem conflitos de integra√ß√£o futuros.
Por exemplo, voc√™ pode integrar uma vers√£o preliminar de uma tela, com
uma interface ainda ruim. Ou ent√£o, uma vers√£o de uma fun√ß√£o com
problemas de desempenho.</p>
<p>Por√©m, existe mais um passo da cadeia de automa√ß√£o proposta por
DevOps, chamado de <strong>Deployment Cont√≠nuo (Continuous Deployment ou
CD)</strong>. A diferen√ßa entre CI e CD √© simples, mas seus impactos s√£o
profundos: quando usa-se CD, todo novo commit que chega no master entra
rapidamente em produ√ß√£o, em quest√µes de horas, por exemplo. O fluxo de
trabalho quando se usa CD √© o seguinte:</p>
<ul>
<li><p>O desenvolvedor desenvolve e testa na sua m√°quina local.</p></li>
<li><p>Ele realiza um commit e o servidor de CI executa novamente um
build e os testes de unidade.</p></li>
<li><p>Algumas vezes no dia, o servidor de CI realiza testes mais
exaustivos com os novos commits que ainda n√£o entraram em produ√ß√£o.
Esses testes incluem, por exemplo, testes de integra√ß√£o, testes de
interface e testes de desempenho.</p></li>
<li><p>Se todos os testes passarem, os commits entram imediatamente em
produ√ß√£o. E os usu√°rios j√° v√£o interagir com a nova vers√£o do
c√≥digo.</p></li>
</ul>
<p>Dentre as vantagens de CD, podemos citar:</p>
<ul>
<li><p>CD reduz o tempo de entrega de novas funcionalidades. Por
exemplo, suponha que as funcionalidades F1, F2,‚Ä¶, Fn est√£o previstas
para uma nova release de um sistema. No modo tradicional, todas elas
devem ser implementadas e testadas, antes da libera√ß√£o da nova release.
Por outro lado, com CD, as funcionalidades s√£o liberadas assim que ficam
prontas. Ou seja, CD diminui o intervalo entre releases. Passa-se a ter
mais releases, mas com um menor n√∫mero de funcionalidades.</p></li>
<li><p>CD torna novas releases (ou implanta√ß√µes) um <q>n√£o-evento</q>.
Explicando melhor, n√£o existe mais um dia D ou um deadline para entrega
de novas releases. Deadlines s√£o uma fonte de stress para
desenvolvedores e operadores de sistemas de software. A perda de um
deadline, por exemplo, pode fazer com que uma funcionalidade somente
entre em produ√ß√£o meses depois.</p></li>
<li><p>Al√©m de reduzir o stress causado por deadlines, CD ajuda a manter
os desenvolvedores motivados, pois eles n√£o ficam meses trabalhando sem
receber feedback. Em vez disso, os desenvolvedores rapidamente recebem
retorno ‚Äî vindo de usu√°rios reais ‚Äî sobre o sucesso ou n√£o de suas
tarefas.</p></li>
<li><p>Em linha com o item anterior, CD favorece experimenta√ß√£o e um
estilo de desenvolvimento orientado por dados e feedback dos usu√°rios.
Novas funcionalidades entram rapidamente em produ√ß√£o. Com isso,
recebe-se retorno dos usu√°rios, que podem recomendar mudan√ßas na
implementa√ß√£o ou, no limite, o cancelamento de alguma
funcionalidade.</p></li>
</ul>
<p></p>
<p><strong>Mundo Real</strong>: Diversas empresas que desenvolvem
sistemas Web usam CD. Por exemplo, Savor e colegas reportam que no
Facebook cada desenvolvedor coloca em produ√ß√£o, na m√©dia, 3.5
atualiza√ß√µes de software por semana (<a
href="https://doi.org/10.1145/2889160.2889223">link</a>). Em cada
atualiza√ß√£o, na m√©dia, 92 linhas de c√≥digo s√£o adicionadas ou
modificadas. Esses n√∫meros revelam que, para funcionar bem, CD requer
que as atualiza√ß√µes de c√≥digo sejam pequenas. Portanto, os
desenvolvedores t√™m que desenvolver a habilidade de quebrar qualquer
tarefa de programa√ß√£o (por exemplo, uma nova funcionalidade, mesmo que
complexa) em partes pequenas, que possam ser implementadas, testadas,
integradas e entregues rapidamente.</p>
<section id="entrega-cont√≠nua-continuous-delivery" data-number="1.4.1">
<h3 data-number="10.4.1"><span
class="header-section-number">10.4.1</span> Entrega Cont√≠nua (Continuous
Delivery) <a href="#entrega-cont√≠nua-continuous-delivery"
class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Deployment Cont√≠nuo (CD) n√£o √© recomend√°vel para certos tipos de
sistemas, incluindo sistemas desktop (como uma IDE ou um navegador Web),
aplica√ß√µes m√≥veis e aplica√ß√µes embutidas em hardware. Provavelmente,
voc√™ n√£o gostaria de ser notificado diariamente de que existe uma nova
vers√£o do navegador que usa em seu desktop, ou do sistema de rede social
que usa em seu celular ou ainda de que um novo driver est√° dispon√≠vel
para sua impressora. Esses sistemas demandam um processo de instala√ß√£o
que n√£o √© transparente para seus usu√°rios, como √© a atualiza√ß√£o de um
sistema Web.</p>
<p>No entanto, mesmo nos sistemas mencionados no par√°grafo anterior,
pode-se usar um vers√£o mais <em>fraca</em> de CD, chamada de
<strong>Entrega Cont√≠nua (Continuous Delivery)</strong>. A ideia √©
simples: quando se usa entrega cont√≠nua, todo commit <em>pode</em>
entrar em produ√ß√£o imediatamente. Ou seja, os desenvolvedores devem
programar como se isso fosse acontecer. No entanto, existe uma
autoridade externa ‚Äî um gerente de projetos ou de releases, por exemplo
‚Äî que toma a decis√£o sobre quando os commits, de fato, ser√£o liberados
para os usu√°rios finais. Inclusive for√ßas de mercado ou de estrat√©gia da
empresa podem influenciar nessa decis√£o. Uma outra maneira de explicar
esses conceitos √© por meio da seguinte diferen√ßa:</p>
<ul>
<li><p><strong>Deployment</strong> √© o processo de liberar uma nova
vers√£o de um sistema para seus usu√°rios.</p></li>
<li><p><strong>Delivery</strong> √© o processo de liberar uma nova vers√£o
de um sistema para ser objeto de deployment.</p></li>
</ul>
<p>Quando adota-se Deployment Cont√≠nuo, ambos os processos s√£o
autom√°ticos e cont√≠nuos. Por√©m, com Entrega Cont√≠nua, a entrega √©
realizada com frequ√™ncia, mas o deployment depende de uma autoriza√ß√£o
manual.</p>
<p> </p>
<p><strong>Mundo Real:</strong> Vamos citar alguns dados sobre a
frequ√™ncia de deployments em sistemas n√£o-Web. Por exemplo, o Google
libera novas releases do navegador Chrome para o p√∫blico a cada seis
semanas. At√© 2019, a IDE Eclipse tinha uma √∫nica nova release por ano. A
partir de 2019, o sistema passou a ter uma nova release a cada 13
semanas. Um dos motivos foi <q>permitir que os desenvolvedores liberem
novas funcionalidades de forma r√°pida</q>. Como um terceiro exemplo, a
vers√£o para Android do Facebook sofria uma atualiza√ß√£o a cada oito
semanas. Mais recentemente, o Facebook encurtou esse tempo para uma
semana (<a href="https://doi.org/10.1145/2950290.2994157">link</a>). Ou
seja, as empresas est√£o lan√ßando releases de forma mais r√°pida, para
agradar os usu√°rios, receber feedback, manter os desenvolvedores
motivados e continuarem competitivas no mercado.</p>
</section>
<section id="feature-flags" data-number="1.4.2">
<h3 data-number="10.4.2"><span
class="header-section-number">10.4.2</span> Feature Flags <a
href="#feature-flags" class="anchor-link" aria-hidden="true">üîó</a></h3>
<p> </p>
<p>Nem sempre todo commit estar√° pronto para entrar imediatamente em
produ√ß√£o. Por exemplo, um desenvolvedor pode estar trabalhando em uma
nova funcionalidade X, mas ainda falta implementar parte de seus
requisitos. Portanto, esse desenvolvedor pode se perguntar:</p>
<blockquote>
<p>Se novas releases s√£o liberadas quase todo dia, como evitar que
minhas implementa√ß√µes parciais, que ainda n√£o foram devidamente testadas
ou que t√™m problemas de desempenho, cheguem at√© os usu√°rios finais?</p>
</blockquote>
<p>Uma solu√ß√£o seria n√£o integr√°-las no branch principal de
desenvolvimento. Por√©m, n√£o queremos mais usar essa pr√°tica, pois ela
leva ao que chamamos de <em>integration (ou merge) hell</em>. Dizendo de
outro modo, n√£o queremos abrir m√£o de Integra√ß√£o Cont√≠nua e
Desenvolvimento Baseado no Trunk.</p>
<p>Uma solu√ß√£o para esse problema √© a seguinte: integre continuamente o
c√≥digo parcial da funcionalidade X, mas com ela desabilitada, isto √©,
qualquer c√≥digo relativo a X estar√° <q>guardado</q> por uma vari√°vel
booleana (um <em>flag</em>) que, enquanto a implementa√ß√£o de X n√£o
estiver conclu√≠da, vai avaliar como falso. Um exemplo hipot√©tico √©
mostrado a seguir:</p>
<pre><code>featureX = false;
...
if (featureX) 
   &quot;aqui tem c√≥digo incompleto de X&quot;
...
if (featureX)
   &quot;mais c√≥digo incompleto de X&quot;</code></pre>
<p>No contexto de deployment cont√≠nuo, vari√°veis usadas para evitar a
entrada em produ√ß√£o de implementa√ß√µes parciais de funcionalidades s√£o
chamadas de <strong>Feature Flags</strong> ou <strong>Feature
Toggles</strong>.</p>
<p>Para mostrar um segundo exemplo, suponha que voc√™ est√° trabalhando em
uma nova p√°gina de um certo sistema. Ent√£o, voc√™ pode declarar um
feature flag para desabilitar o carregamento da nova p√°gina, como
mostrado a seguir:</p>
<pre><code>nova_pag = false;
...
if (nova_pag) 
   &quot;carregue nova p√°gina&quot;
else
   &quot;carregue p√°gina antiga&quot;</code></pre>
<p>Esse √© o c√≥digo que vai para produ√ß√£o enquanto a nova p√°gina n√£o
estiver pronta. Por√©m, durante a implementa√ß√£o, localmente, na sua
m√°quina, voc√™ pode habilitar a nova p√°gina, fazendo o flag
<code>nova_pag</code> receber <code>true</code>. Observe ainda que
durante um certo intervalo de tempo vai existir duplica√ß√£o de c√≥digo
entre as duas p√°ginas. Por√©m, ap√≥s a nova p√°gina ser aprovada, entrar em
produ√ß√£o e receber feedback positivo dos clientes, o c√≥digo da p√°gina
antiga e o feature flag (<code>nova_pag</code>) podem ser removidos. Ou
seja, a duplica√ß√£o de c√≥digo foi tempor√°ria.</p>
<p></p>
<p><strong>Mundo Real:</strong> Pesquisadores de duas universidades
canadenses, liderados pelos professores Peter Rigby e Bram Adams,
realizaram um estudo sobre o uso de feature flags ao longo de 39
releases do navegador Chrome, relativas a cinco anos de desenvolvimento
(<a href="https://doi.org/10.1145/2901739.2901745">link</a>). Nesse
per√≠odo, eles encontraram mais de 2.400 feature flags distintos no
c√≥digo do navegador. Na primeira vers√£o analisada, eles catalogaram 263
flags; na √∫ltima vers√£o, o n√∫mero aumentou para 2.409 flags. Na m√©dia,
uma nova release adicionava 73 novos flags e removia 43 flags. Por isso,
o crescimento observado no estudo.</p>
<p>No entanto, alguns feature flags podem ser mantidos no c√≥digo durante
o processo de release do software. Isso pode ocorrer por dois motivos,
conforme descrito a seguir.</p>
<p> Primeiro, feature flags ajudam a implementar o que chama-se de
<strong>release can√°rio</strong>. Nessa modalidade de release, uma nova
funcionalidade ‚Äî guardada por um feature flag ‚Äî √© disponibilizada
inicialmente para um grupo pequeno de usu√°rios. Por exemplo, para apenas
5% dos usu√°rios. Com isso, os preju√≠zos causados por eventuais bugs n√£o
detectados nos testes da nova funcionalidade ser√£o minimizados. Em
seguida, caso a implanta√ß√£o seja bem sucedida, pode-se ampliar a base de
usu√°rios que ter√° acesso √† nova funcionalidade de forma gradativa, at√©
alcan√ßar todos os usu√°rios do sistema. O nome release can√°rio √© uma
refer√™ncia a uma pr√°tica comum na explora√ß√£o de novas minas de carv√£o.
Os mineiros costumavam adentrar essas minas com um can√°rio em uma
gaiola. Caso a mina possu√≠sse algum g√°s t√≥xico, ele mataria primeiro o
can√°rio e, ent√£o, os mineiros poderiam recuar e evitar uma
intoxica√ß√£o.</p>
<p> Adicionalmente, feature flags ajudam a viabilizar <strong>Testes
A/B</strong>, tal como estudamos no Cap√≠tulo 3. Apenas para relembrar,
nesses testes, libera-se simultaneamente duas vers√µes de uma
funcionalidade (antiga e nova, por exemplo) para grupos distintos de
usu√°rios, com o objetivo de verificar se a nova funcionalidade de fato
agrega valor ao sistema.</p>
<p>Para facilitar a execu√ß√£o de releases can√°rios e testes A/B, pode-se
usar uma estrutura de dados para armazenar os flags e seu estado (ligado
ou desligado). Um exemplo √© mostrado a seguir:</p>
<pre><code>FeatureFlagsTable fft = new FeatureFlagsTable();
fft.addFeature(&quot;novo-carrinho-compras&quot;, false);
...
if (fft.IsEnabled(&quot;novo-carrinho-compras&quot;))
   // processa compra usando novo carrinho
else 
   // processa compra usando carrinho atual
...      </code></pre>
<p>Existem bibliotecas dedicadas a gerenciar feature flags, as quais
disponibilizam classes semelhantes a <code>FeatureFlagsTable</code> do
c√≥digo acima. A vantagem nesse caso √© que os flags podem ser setados
externamente ao c√≥digo, por exemplo, em um arquivo de configura√ß√£o. Por
outro lado, quando o flag √© uma vari√°vel booleana, para alterar seu
valor precisa-se editar e recompilar o c√≥digo.</p>
<p><strong>Aprofundamento</strong>: Nesta se√ß√£o, nosso foco foi no uso
de feature flags para evitar a entrada em produ√ß√£o de um determinado
trecho de c√≥digo, em um cen√°rio de deployment cont√≠nuo. Feature flags
com esse prop√≥sito s√£o chamados tamb√©m de <strong>release
flags</strong>. No entanto, feature flags podem ser usados com outros
prop√≥sitos. Um deles √© gerar diferentes vers√µes de um mesmo sistema de
software. Por exemplo, suponha um sistema que tenha uma vers√£o gratuita
e uma vers√£o paga. Os clientes da vers√£o paga t√™m acesso a mais
funcionalidades, cujo c√≥digo √© delimitado por feature flags. Nesse caso
espec√≠fico, os flags s√£o chamadas de <strong>flags de neg√≥cio</strong>
(<strong>business flags</strong>).</p>
</section>
</section>
<h2 class="unnumbered" id="bibliografia">Bibliografia <a
href="#bibliografia" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Gene Kim, Jez Humble, John Willis, Patrick Debois. Manual de DevOps.
Como Obter Agilidade, Confiabilidade e Seguran√ßa em Organiza√ß√µes
Tecnol√≥gicas. Alta Books, 2018.</p>
<p>Jez Humble, David Farley. Entrega Cont√≠nua: Como Entregar Software de
Forma R√°pida e Confi√°vel. Bookman, 2014.</p>
<p>Steve Matyas, Andrew Glover, Paul Duvall. Continuous Integration:
Improving Software Quality and Reducing Risk. Addison-Wesley, 2007.</p>
<h2 class="unnumbered" id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o
<a href="#exerc√≠cios-de-fixa√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>1. Defina e descreva os objetivos de DevOps.</p>
<p>2. Em sites de oferta de empregos na √°rea de TI, √© comum encontrar
vagas para <q>Engenheiro DevOps</q>, requerendo habilidades como as
seguintes:</p>
<ul>
<li>Ferramentas de controle de vers√£o (Git, Bitbucket, SVN, etc.)</li>
<li>Gerenciadores de depend√™ncia e build (Maven, Gradle, etc.)</li>
<li>Ferramentas de integra√ß√£o cont√≠nua (Jenkins, Bamboo, VSTS)</li>
<li>Administra√ß√£o de servidores em Cloud (AWS e Azure)</li>
<li>Sistemas Operacionais (Ubuntu, CentOS e Red Hat)</li>
<li>Banco de dados (DynamoDB, Aurora Mysql)</li>
<li>Docker e orquestra√ß√£o de Docker (Kubernetes, Mesos, Swarm)</li>
<li>Desenvolvimento com APIs REST, Java</li>
</ul>
<p>Considerando a defini√ß√£o de DevOps que usou como resposta no
exerc√≠cio anterior, voc√™ considera adequado que a fun√ß√£o de um
funcion√°rio seja <q>Engenheiro DevOps</q>? Justifique a sua
resposta.</p>
<p>3. Descreva duas vantagens de um Sistema de Controle de Vers√µes
Distribu√≠do (DVCS), como o git.</p>
<p>4. Descreva uma desvantagem relacionada com o uso de
mono-reposit√≥rios.</p>
<p>5. Defina (e diferencie) os seguintes termos: integra√ß√£o cont√≠nua
(<em>continuous integration</em>); entrega cont√≠nua (<em>continuous
delivery</em>) e deployment cont√≠nuo (<em>continuous
deployment</em>).</p>
<p>6. Por que integra√ß√£o cont√≠nua, entrega cont√≠nua e deployment
cont√≠nuo s√£o pr√°ticas importantes em DevOps? Na sua resposta, considere
a defini√ß√£o de DevOps que usou no primeiro exerc√≠cio desta lista.</p>
<p>7. Pesquise o significado da express√£o <q>Teatro de CI</q> (<em>CI
Theater</em>) e ent√£o descreva-o com suas pr√≥prias palavras.</p>
<p>8. Suponha que voc√™ foi contratado por uma empresa que fabrica
impressoras. E que voc√™ ficou respons√°vel por definir as pr√°ticas de
DevOps que ser√£o adotadas no desenvolvimento dos <em>drivers</em>
(software) dessas impressoras. Qual das seguintes pr√°ticas voc√™ adotaria
nesse desenvolvimento: deployment cont√≠nuo ou delivery cont√≠nuo?
Justifique sua resposta.</p>
<p>9. Descreva um problema (ou dificuldade) que surge quando decide-se
usar feature flags para delimitar c√≥digo que ainda n√£o est√° pronto para
entrar em produ√ß√£o.</p>
<p>10. Linguagens como C possuem suporte a diretivas de compila√ß√£o
condicional do tipo <code>#ifdef</code> e <code>#endif</code>. Pesquise
o funcionamento e o uso dessas diretivas. Qual a diferen√ßa entre elas e
feature flags?</p>
<p>11. Qual tipo de feature flags possui maior tempo de vida (isto √©,
permanece no c√≥digo por mais tempo): <em>release flags</em> ou
<em>business flags</em>? Justifique sua resposta.</p>
<p>12. Quando uma empresa migra para CI, normalmente ela n√£o usa mais
branches de funcionalidades (<em>feature branches</em>). Em vez disso,
ela tem um √∫nico branch, que √© compartilhado por todos os
desenvolvedores. Essa pr√°tica √© chamada Desenvolvimento Baseado no Trunk
(ou TBD), conforme estudamos neste cap√≠tulo. No entanto, TBD n√£o
significa que branches n√£o s√£o mais usados nessas empresas. Descreva
ent√£o um outro uso para branches, que n√£o seja como <em>feature
branches</em>.</p>
<p>13. Leia o seguinte <a
href="https://gmail.googleblog.com/2011/12/developing-gmails-new-look.html">artigo</a>
do blog oficial do GMail, que descreve uma grande atualiza√ß√£o realizada
na interface do sistema, em 2011. O artigo chega a comparar os desafios
dessa migra√ß√£o com aqueles de <q>trocar os pneus de um carro com ele em
movimento</q>. Sobre esse artigo, responda ent√£o:</p>
<ol type="a">
<li><p>Qual tecnologia ‚Äî que estudamos neste cap√≠tulo ‚Äî foi fundamental
para viabilizar essa atualiza√ß√£o na interface do GMail? Qual nome o
artigo d√° para essa tecnologia?</p></li>
<li><p>E qual nome usamos no cap√≠tulo para referenci√°-la?</p></li>
</ol>
</section>
</div>
</div>
</div>

<footer>
Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formul√°rio</a>.
</footer>
</body>
</html>
