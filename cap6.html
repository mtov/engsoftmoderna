<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 6: Padr√µes de Projeto ‚Äì Engenharia de Software Moderna</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "‚Äú" "‚Äù" "‚Äò" "‚Äô"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">
<img src="https://engsoftmoderna.info/figs/capa/capa-3d.jpg"></a>
</p>

<p>
<a href="https://engsoftmoderna.info">P√°gina principal do livro</a>
</p>

<p>Compre na

<a href="https://www.amazon.com.br/gp/product/6500019504">Amazon</a> ou
<a href="https://loja.umlivro.com.br/engenharia-de-software-moderna-4778188/p">
      UmLivro</a>
<!--
<a href="https://www.submarino.com.br/produto/1768283036/engenharia-de-software-moderna">
      Submarino</a> ou 

<a href="https://www.casasbahia.com.br/livros/InformaticaCertificacao/livrosdeinformatica/engenharia-de-software-moderna-1513074930.html">Casas Bahia</a>
</p>
-->

<!--
<p>
Veja tamb√©m nosso  
<a href="https://www.engsoftmoderna.dcc.ufmg.br">curso de extens√£o</a> a dist√¢ncia, com certificados emitidos pelo DCC/UFMG.
</p>
-->

<!---
<p>
<mark>Novo</mark> Inscri√ß√µes abertas at√© 16/02/2024 para a Turma 12 do nosso   
<a href="https://www.engsoftmoderna.dcc.ufmg.br">curso de extens√£o</a> a dist√¢ncia,
com certificados emitidos pelo DCC/UFMG.
</p>
---->

<!---
<p>
Veja tamb√©m nosso <a href="https://engsoftmoderna.info/curso">curso de extens√£o</a> a dist√¢ncia, com certificados emitidos pelo DCC/UFMG. 
</p>
--->
<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="6" id="padr√µes-de-projeto"><span
class="header-section-number">6</span> Padr√µes de Projeto <a
href="#padr√µes-de-projeto" class="anchor-link"
aria-hidden="true">üîó</a></h1>
<blockquote>
<p><em>A design that doesn‚Äôt take change into account risks major
redesign in the future.</em> ‚Äì Gang of Four</p>
</blockquote>
<p>Este cap√≠tulo inicia com uma introdu√ß√£o ao conceito e aos objetivos
de padr√µes de projeto (Se√ß√£o 6.1). Em seguida, discutimos com detalhes
dez padr√µes de projetos: F√°brica, Singleton, Proxy, Adaptador, Fachada,
Decorador, Strategy, Observador, Template Method e Visitor. Cada um
desses padr√µes √© discutido em uma se√ß√£o separada (Se√ß√µes 6.2 a 6.11). A
apresenta√ß√£o de cada padr√£o √© organizada em tr√™s partes: (1) um
contexto, isto √©, um sistema no qual o padr√£o poderia ser √∫til; (2) um
problema no projeto desse sistema; (3) uma solu√ß√£o para esse problema
por meio de padr√µes. Na Se√ß√£o 6.12, discutimos brevemente mais alguns
padr√µes. Terminamos o cap√≠tulo alertando que padr√µes de projeto n√£o s√£o
uma bala de prata, ou seja, discutimos situa√ß√µes nas quais o uso de
padr√µes de projeto n√£o √© recomendado (Se√ß√£o 6.13).</p>
<h2 data-number="6.1" id="introdu√ß√£o"><span
class="header-section-number">6.1</span> Introdu√ß√£o <a
href="#introdu√ß√£o" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p>Padr√µes de projeto s√£o inspirados em uma ideia proposta por
Cristopher Alexander, um arquiteto ‚Äî de constru√ß√µes civis e n√£o de
software ‚Äî e professor da Universidade de Berkeley. Em 1977, Alexander
lan√ßou um livro chamado <em>A Patterns Language</em>, no qual ele
documenta diversos padr√µes para constru√ß√£o de cidades e pr√©dios. Segundo
Alexander:</p>
<blockquote>
<p>Cada padr√£o descreve um problema que sempre ocorre em nosso contexto
e uma solu√ß√£o para ele, de forma que possamos us√°-la um milh√£o de
vezes.</p>
</blockquote>
<p> </p>
<p>Em 1995, Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides
lan√ßaram um livro adaptando as ideias de Alexander para o mundo de
desenvolvimento de software (<a
href="https://dl.acm.org/citation.cfm?id=186897">link</a>). Em vez de
propor um cat√°logo de solu√ß√µes para projeto de cidades e pr√©dios, eles
propuseram um cat√°logo com solu√ß√µes para resolver problemas recorrentes
em projeto de software. Eles deram o nome de <strong>Padr√µes de
Projeto</strong> √†s solu√ß√µes propostas no livro. Eles definem padr√µes de
projeto da seguinte forma:</p>
<blockquote>
<p>Padr√µes de projeto descrevem objetos e classes que se relacionam para
resolver um problema de projeto gen√©rico em um contexto particular.</p>
</blockquote>
<p> Assim, para entender os padr√µes propostos pela <em>Gang of Four</em>
‚Äî nome pelo qual ficaram conhecidos os autores e tamb√©m o livro de
padr√µes de projeto ‚Äî precisamos entender: (1) o problema que o padr√£o
pretende resolver; (2) o contexto em que esse problema ocorre; (3) a
solu√ß√£o proposta. Neste livro, vamos descrever alguns padr√µes de
projeto, sempre focando nesses elementos: contexto, problema e solu√ß√£o.
Iremos tamb√©m mostrar v√°rios exemplos de c√≥digo fonte.</p>
<p>Al√©m de oferecer solu√ß√µes prontas para problemas de projeto, padr√µes
de projeto transformaram-se em um vocabul√°rio largamente adotado por
desenvolvedores de software. Assim, √© comum ouvir desenvolvedores
dizendo que usaram uma f√°brica para resolver um certo problema, enquanto
que um segundo problema foi resolvido por meio de decoradores. Ou seja,
eles apenas mencionam o nome do padr√£o e subentendem que a solu√ß√£o
adotada j√° est√° clara. De forma semelhante, o vocabul√°rio de padr√µes de
projeto √© muito usado na documenta√ß√£o de sistemas. Por exemplo, a figura
da pr√≥xima p√°gina mostra a documenta√ß√£o de uma das classes da biblioteca
padr√£o de Java. Podemos ver que o nome da classe termina em
<code>Factory</code> ‚Äî que √© um dos padr√µes de projeto que vamos estudar
daqui a pouco. Na descri√ß√£o da classe, volta-se a mencionar que ela √©
uma f√°brica. Portanto, desenvolvedores que conhecem esse padr√£o de
projeto ter√£o mais facilidade para entender e usar a classe em
quest√£o.</p>
<figure>
<img src="figs/cap6/doc-pattern.png" style="width:55.0%"
alt="Documenta√ß√£o de uma classe Factory da API de Java" />
<figcaption aria-hidden="true">Documenta√ß√£o de uma classe
<code>Factory</code> da API de Java</figcaption>
</figure>
<p>Um desenvolvedor pode se beneficiar do dom√≠nio de padr√µes de projeto
em dois cen√°rios principais:</p>
<ul>
<li><p>Quando ele estiver implementando o seu pr√≥prio sistema. Nesse
caso, conhecer padr√µes de projeto pode ajud√°-lo a adotar, no seu
sistema, uma solu√ß√£o de projeto j√° testada e validada.</p></li>
<li><p>Quando ele estiver usando um sistema de terceiros, como o pacote
de Java que implementa a classe <code>DocumentBuilderFactory</code> da
figura. Nesse caso, conhecimento de padr√µes de projeto pode ajud√°-lo a
entender o comportamento e a estrutura da classe que ele precisa
usar.</p></li>
</ul>
<p>√â importante entender que padr√µes de projeto visam a cria√ß√£o de
projetos de software flex√≠veis e extens√≠veis. Neste livro, antes de
explicar cada um dos padr√µes, vamos apresentar um contexto e um trecho
de c√≥digo que funciona e produz um resultado. Por√©m, ele n√£o d√° origem a
um projeto flex√≠vel. Para deixar essa inflexibilidade clara,
apresentaremos um cen√°rio de extens√£o do c√≥digo mostrado, envolvendo a
implementa√ß√£o de novos requisitos. Ent√£o vamos argumentar que essa
extens√£o exigir√° algum esfor√ßo, que poder√° ser minimizado se usarmos um
padr√£o de projeto.</p>
<p> Os quatro autores do livro de padr√µes de projeto defendem que
devemos projetar um sistema pensando em mudan√ßas que inevitavelmente v√£o
ocorrer ‚Äî eles chamam essa preocupa√ß√£o de <em>design for change</em>.
Conforme afirmado por eles na frase que abre este cap√≠tulo, se design
for change n√£o for uma preocupa√ß√£o, os desenvolvedores correm o risco de
em breve ter que planejar um profundo reprojeto de seus sistemas.</p>
<p>No livro sobre padr√µes de projeto, s√£o propostos 23 padr√µes,
divididos nas seguintes tr√™s categorias (os padr√µes que estudaremos
neste cap√≠tulo est√£o em negrito, seguido do n√∫mero da se√ß√£o em que eles
s√£o apresentados):</p>
<ul>
<li><p><strong>Criacionais</strong>: padr√µes que prop√µem solu√ß√µes
flex√≠veis para cria√ß√£o de objetos. S√£o eles: <strong>Abstract Factory
(6.2)</strong>, Factory Method, <strong>Singleton (6.3)</strong>,
<strong>Builder (6.12)</strong> e Prototype.</p></li>
<li><p><strong>Estruturais</strong>: padr√µes que prop√µem solu√ß√µes
flex√≠veis para composi√ß√£o de classes e objetos. S√£o eles: <strong>Proxy
(6.4)</strong>, <strong>Adapter (6.5)</strong>, <strong>Facade
(6.6)</strong>, <strong>Decorator (6.7)</strong>, Bridge, Composite e
Flyweight.</p></li>
<li><p><strong>Comportamentais</strong>: padr√µes que prop√µem solu√ß√µes
flex√≠veis para intera√ß√£o e divis√£o de responsabilidades entre classes e
objetos. S√£o eles: <strong>Strategy (6.8)</strong>, <strong>Observer
(6.9)</strong>, <strong>Template Method (6.10)</strong>, <strong>Visitor
(6.11)</strong>, Chain of Responsibility, Command, Interpreter,
<strong>Iterator (6.12)</strong>, Mediator, Memento e State.</p></li>
</ul>
<p><strong>Tradu√ß√£o</strong>: Por ser uma tradu√ß√£o direta, vamos
traduzir os nomes dos padr√µes F√°brica Abstrata, M√©todo F√°brica,
Adaptador, Fachada, Decorador, Observador e Iterador. Os demais ser√£o
referenciados usando o nome original.</p>
<h2 data-number="6.2" id="f√°brica"><span
class="header-section-number">6.2</span> F√°brica <a href="#f√°brica"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha um sistema distribu√≠do baseado em
TCP/IP. Nesse sistema, tr√™s fun√ß√µes <code>f</code>, <code>g</code> e
<code>h</code> criam objetos do tipo <code>TCPChannel</code> para
comunica√ß√£o remota, como mostra o pr√≥ximo c√≥digo.</p>
<pre><code>void f() {
  TCPChannel c = new TCPChannel();  
  ...
}

void g() {
  TCPChannel c = new TCPChannel();
  ...
}

void h() {
  TCPChannel c = new TCPChannel();
  ...
}</code></pre>
<p><strong>Problema</strong>: Suponha que ‚Äî em determinadas
configura√ß√µes do sistema ‚Äî precisaremos usar UDP para comunica√ß√£o.
Portanto, se considerarmos esse requisito, o sistema n√£o atende ao
Princ√≠pio Aberto/Fechado, isto √©, ele n√£o est√° fechado para modifica√ß√µes
e aberto para extens√µes nos protocolos de comunica√ß√£o usados. Sendo mais
claro, gostar√≠amos de <q>parametrizar</q> o c√≥digo acima para criar
objetos dos tipos <code>TCPChannel</code> ou <code>UDPChannel</code>,
dependendo dos clientes. O problema √© que o operador <code>new</code>
deve ser seguido do nome literal de uma classe. Esse operador ‚Äî pelo
menos em linguagens como Java, C++ e C# ‚Äî n√£o permite que a classe dos
objetos que se pretende criar seja passada como um par√¢metro. Resumindo,
o problema consiste em parametrizar a instancia√ß√£o dos canais de
comunica√ß√£o no c√≥digo acima, de forma que ele consiga trabalhar com
protocolos diferentes.</p>
<p><strong>Solu√ß√£o</strong>: A solu√ß√£o que vamos descrever baseia-se no
padr√£o de projeto <strong>F√°brica</strong>. Esse padr√£o possui algumas
varia√ß√µes, mas no nosso problema vamos adotar um m√©todo est√°tico que:
(1) apenas cria e retorna objetos de uma determinada classe; (2) e
tamb√©m oculta o tipo desses objetos por tr√°s de uma interface. Um
exemplo √© mostrado a seguir:</p>
<pre><code>class ChannelFactory {
  public static Channel create() {// m√©todo f√°brica est√°tico
    return new TCPChannel();
  }
}

void f() {
  Channel c = ChannelFactory.create();
  ...
}

void g() {
  Channel c = ChannelFactory.create();
  ...
}
void h() {
  Channel c = ChannelFactory.create();
  ...
}</code></pre>
<p> Nessa nova vers√£o, as fun√ß√µes <code>f</code>, <code>g</code> e
<code>h</code> n√£o t√™m consci√™ncia do tipo de <code>Channel</code> que
v√£o criar e usar. Elas chamam um <strong>M√©todo F√°brica
Est√°tico</strong>, que instancia e retorna um objeto de uma classe
concreta ‚Äî para ser claro, essa variante do padr√£o F√°brica n√£o foi
proposta no livro da Gangue dos Quatro, mas sim alguns anos depois por
Joshua Bloch (<a
href="https://dl.acm.org/citation.cfm?id=1377533">link</a>). √â
importante tamb√©m destacar que as tr√™s fun√ß√µes usam sempre uma interface
<code>Channel</code> para manipular os objetos criados pelo m√©todo
f√°brica est√°tico. Ou seja, aplicamos o princ√≠pio <q>Prefira Interfaces a
Classes</q> (ou Invers√£o de Depend√™ncias).</p>
<p>No novo c√≥digo, o sistema continua funcionando com canais do tipo
<code>TCPChannel</code>. Por√©m, se quisermos mudar o tipo de canal,
temos agora que modificar um √∫nico elemento do c√≥digo: o m√©todo create
da classe <code>ChannelFactory</code>. Dizendo de outra forma, um m√©todo
f√°brica est√°tico funciona como um <q>aspirador</q> de m√©todos
<code>new</code>: todas as chamadas antigas de <code>new</code> migram
para uma √∫nica chamada, no m√©todo f√°brica est√°tico.</p>
<p>Existem ainda algumas varia√ß√µes do padr√£o F√°brica. Em uma delas, uma
classe abstrata √© usada para concentrar v√°rios m√©todos f√°brica. Essa
classe recebe ent√£o o nome de <strong>F√°brica Abstrata</strong>. Um
exemplo √© mostrado no c√≥digo a seguir:</p>
<pre><code>abstract class ProtocolFactory { // F√°brica Abstrata
  abstract Channel createChannel();
  abstract Port createPort();  
  ...
}

void f(ProtocolFactory pf) {
  Channel c = pf.createChannel();
  Port p = pf.createPort();
  ...
}</code></pre>
<p>No exemplo acima, omitimos as classes que estendem a classe abstrata
<code>ProtocolFactory</code> e que v√£o implementar, de fato, os m√©todos
concretos para cria√ß√£o de canais e portas de comunica√ß√£o. Podemos, por
exemplo, ter duas subclasses: <code>TCPProtocolFactory</code> e
<code>UDPProtocolFactory</code>.</p>
<h2 data-number="6.3" id="singleton"><span
class="header-section-number">6.3</span> Singleton <a href="#singleton"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha uma classe <code>Logger</code>,
usada para registrar as opera√ß√µes realizadas em um sistema. Um uso dessa
classe √© mostrado a seguir:</p>
<pre><code>void f() {
  Logger log = new Logger();
  log.println(&quot;Executando f&quot;);
  ...
}
void g() {
  Logger log = new Logger();
  log.println(&quot;Executando g&quot;);
  ...
}
void h() {
  Logger log = new Logger();
  log.println(&quot;Executando h&quot;);
  ...
}</code></pre>
<p><strong>Problema</strong>: No c√≥digo anterior, cada m√©todo que
precisa registrar eventos cria sua pr√≥pria inst√¢ncia de
<code>Logger</code>. No entanto, gostar√≠amos que todos os usos de
<code>Logger</code> tivessem como alvo a mesma inst√¢ncia da classe. Em
outras palavras, n√£o queremos uma prolifera√ß√£o de objetos
<code>Logger</code>. Em vez disso, gostar√≠amos que existisse, no m√°ximo,
uma √∫nica inst√¢ncia dessa classe e que ela fosse usada em todas as
partes do sistema que precisam registrar algum evento. Isso √©
importante, por exemplo, caso o registro de eventos seja feito em
arquivos. Se for poss√≠vel a cria√ß√£o de v√°rios objetos
<code>Logger</code>, todo novo objeto instanciado vai apagar o arquivo
anterior, criado por outros objetos do tipo <code>Logger</code>.</p>
<p><strong>Solu√ß√£o</strong>: A solu√ß√£o para esse problema consiste em
transformar a classe <code>Logger</code> em um
<strong>Singleton</strong>. Esse padr√£o de projeto define como
implementar classes que ter√£o, como o pr√≥prio nome indica, no m√°ximo uma
inst√¢ncia. Mostramos a seguir a vers√£o de <code>Logger</code> que
funciona como um Singleton:</p>
<pre><code>class Logger {

  private Logger() {} // pro√≠be clientes chamar new Logger()

  private static Logger instance; // inst√¢ncia √∫nica

  public static Logger getInstance() {
    if (instance == null) // 1a vez que chama-se getInstance
      instance = new Logger();
    return instance;
  }

  public void println(String msg) {
    // registra msg no console, mas poderia ser em arquivo
    System.out.println(msg);
  }
}</code></pre>
<p>Primeiro, essa classe tem um construtor <em>default</em> privado. Com
isso, um erro de compila√ß√£o ocorrer√° quando qualquer c√≥digo fora da
classe tentar chamar <code>new Logger()</code>. Al√©m disso, um atributo
est√°tico armazena a inst√¢ncia √∫nica da classe. Quando precisarmos dessa
inst√¢ncia, devemos chamar o m√©todo p√∫blico e est√°tico
<code>getInstance()</code>. Um exemplo √© mostrado a seguir:</p>
<pre><code>void f() {
  Logger log = Logger.getInstance();
  log.println(&quot;Executando f&quot;);
  ...
}

void g() {
  Logger log = Logger.getInstance();
  log.println(&quot;Executando g&quot;);
  ...
}

void h() {
  Logger log = Logger.getInstance();
  log.println(&quot;Executando h&quot;);
  ...
}</code></pre>
<p>Nesse novo c√≥digo, temos certeza de que as tr√™s chamadas de
<code>getInstance</code> retornam a mesma inst√¢ncia de
<code>Logger</code>. Todas as mensagens ser√£o ent√£o registradas
usando-se essa inst√¢ncia.</p>
<p>Dentre os padr√µes de projeto propostos no livro da <q>Gangue dos
Quatro</q>, Singleton √© o mais pol√™mico e criticado. O motivo √© que ele
pode ser usado para camuflar a cria√ß√£o de vari√°veis e estruturas de
dados globais. No nosso caso, a inst√¢ncia √∫nica de <code>Logger</code>
√©, na pr√°tica, uma vari√°vel global que pode ser lida e alterada em
qualquer parte do programa. Para isso, basta chamar
<code>Logger.getInstance()</code>. Como vimos no Cap√≠tulo 5, vari√°veis
globais representam uma forma de acoplamento ruim (ou forte) entre
classes, isto √©, uma forma de acoplamento que n√£o √© mediada por meio de
interfaces est√°veis. Por√©m, no caso de <code>Logger</code>, o uso de
Singleton n√£o gera preocupa√ß√µes, pois ele √© exatamente aquele
recomendado pelo padr√£o: temos um recurso que √© √∫nico ‚Äî um arquivo de
log, no caso ‚Äî e queremos refletir essa caracter√≠stica no projeto,
garantindo que ele seja manipulado por meio de uma classe que, por
constru√ß√£o, possuir√° no m√°ximo uma inst√¢ncia.</p>
<p>Em resumo: Singleton deve ser usado para modelar recursos que,
conceitualmente, devem possuir no m√°ximo uma inst√¢ncia durante a
execu√ß√£o de um programa. Por outro lado, um uso abusivo do padr√£o ocorre
quando ele √© adotado como um artif√≠cio para cria√ß√£o de vari√°veis
globais.</p>
<p>Por fim, existe mais uma cr√≠tica ao uso de Singletons: eles tornam o
teste autom√°tico de m√©todos mais complicado. O motivo √© que o resultado
da execu√ß√£o de um m√©todo pode agora depender de um <q>estado global</q>
armazenado em um Singleton. Por exemplo, suponha um m√©todo
<code>m</code> que retorna o valor de <code>x + y</code>, onde
<code>x</code> √© um par√¢metro de entrada e <code>y</code> √© uma vari√°vel
global, que √© parte de um Singleton. Logo, para testar esse m√©todo
precisamos fornecer o valor <code>x</code>; o que √© bastante f√°cil, pois
ele √© um par√¢metro do m√©todo. Mas tamb√©m precisamos garantir que
<code>y</code> ter√° um valor conhecido; o que pode ser mais dif√≠cil,
pois ele √© um atributo de uma outra classe.</p>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo do exemplo de Singleton usado
nesta se√ß√£o est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/704348e216e85918d7375a6b3d40dcdb">link</a>.</p>
<h2 data-number="6.4" id="proxy"><span
class="header-section-number">6.4</span> Proxy <a href="#proxy"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha uma classe
<code>BookSearch</code>, cujo principal m√©todo pesquisa por um livro,
dado o seu ISBN:</p>
<pre><code>class BookSearch {
  ...
  Book getBook(String ISBN) { ... }
  ...
}</code></pre>
<p><strong>Problema</strong>: Suponha que nosso servi√ßo de pesquisa de
livros esteja ficando popular e ganhando usu√°rios. Para melhorar seu
desempenho, pensamos em introduzir um sistema de cache: antes de
pesquisar por um livro, iremos verificar se ele est√° no cache. Se sim, o
livro ser√° imediatamente retornado. Caso contr√°rio, a pesquisa
prosseguir√° segundo a l√≥gica normal do m√©todo <code>getBook()</code>.
Por√©m, n√£o gostar√≠amos que esse novo requisito ‚Äî pesquisa em cache ‚Äî
fosse implementado na classe <code>BookSearch</code>. O motivo √© que
queremos manter a classe coesa e aderente ao Princ√≠pio da
Responsabilidade √önica. Na verdade, o cache ser√° implementado por um
desenvolvedor diferente daquele que √© respons√°vel por manter
<code>BookSearch</code>. Al√©m disso, vamos usar uma biblioteca de cache
de terceiros, com diversos recursos e customiza√ß√µes. Por isso, achamos
importante separar, em classes distintas, o interesse <q>pesquisar
livros por ISBN</q> (que √© um requisito funcional) do interesse <q>usar
um cache nas pesquisas por livros</q> (que √© um requisito
n√£o-funcional).</p>
<p><strong>Solu√ß√£o</strong>: O padr√£o de projeto <strong>Proxy</strong>
defende a inser√ß√£o de um objeto intermedi√°rio, chamado proxy, entre um
objeto base e seus clientes. Assim, os clientes n√£o ter√£o mais uma
refer√™ncia direta para o objeto base, mas sim para o proxy. Por sua vez,
o proxy possui uma refer√™ncia para o objeto base. Al√©m disso, o proxy
deve implementar as mesmas interfaces do objeto base.</p>
<p>O objetivo de um proxy √© mediar o acesso a um objeto base,
agregando-lhe funcionalidades, sem que ele tome conhecimento disso. No
nosso caso, o objeto base √© do tipo <code>BookSearch</code>; a
funcionalidade que pretendemos agregar √© um cache; e o proxy √© um objeto
da seguinte classe:</p>
<pre><code>class BookSearchProxy implements BookSearchInterface {

  private BookSearchInterface base;

  BookSearchProxy (BookSearchInterface base) {
    this.base = base;
  }

  Book getBook(String ISBN) {
    if(&quot;livro com ISBN no cache&quot;)
      return &quot;livro do cache&quot;
    else {
      Book book = base.getBook(ISBN);
      if(book != null)
        &quot;adicione book no cache&quot;
      return book;
    }
  }
  ...
}</code></pre>
<p>Deve ser criada tamb√©m uma interface
<code>BookSearchInterface</code>, n√£o mostrada no c√≥digo. Tanto a classe
base como a classe do proxy devem implementar essa interface. Isso
permitir√° que os clientes n√£o tomem conhecimento da exist√™ncia de um
proxy entre eles e o objeto base. Mais uma vez, estamos lan√ßando m√£o do
Princ√≠pio <q>Prefira Interfaces a Classes</q>.</p>
<p>O pr√≥ximo c√≥digo ilustra a instancia√ß√£o do proxy. Primeiro, mostramos
o c√≥digo antes do proxy. Nesse c√≥digo (a seguir), um objeto
<code>BookSearch</code> √© criado no programa principal e depois passado
como par√¢metro de qualquer classe ou fun√ß√£o que precise do servi√ßo de
pesquisa de livros, como a classe <code>View</code>.</p>
<pre><code>void main() {
  BookSearch bs = new BookSearch();
  ...
  View view = new View(bs);
  ...
}</code></pre>
<p>Com a decis√£o de usar um proxy, vamos ter que modificar esse c√≥digo
para instanciar o proxy (c√≥digo a seguir). Al√©m disso, <code>View</code>
passou a receber como par√¢metro de sua construtora uma refer√™ncia para o
proxy, em vez de uma refer√™ncia para o objeto base.</p>
<pre><code>void main() {
  BookSearch bs = new BookSearch();
  BookSearchProxy pbs;
  pbs = new BookSearchProxy(bs);
  ...
  View view = new View(pbs);
  ...
}</code></pre>
<p>A pr√≥xima figura ilustra os objetos e as refer√™ncias entre eles,
considerando a solu√ß√£o que usa um proxy:</p>
<figure>
<img src="figs/cap6/padrao-proxy.svg" style="width:75.0%"
alt="Padr√£o de projeto Proxy" />
<figcaption aria-hidden="true">Padr√£o de projeto Proxy</figcaption>
</figure>
<p>Al√©m de ajudar na implementa√ß√£o de caches, proxies podem ser usados
para implementar outros requisitos n√£o-funcionais. Alguns exemplos
incluem:</p>
<ul>
<li><p>Comunica√ß√£o com um cliente remoto, isto √©, pode-se usar um proxy
para encapsular protocolos e detalhes de comunica√ß√£o. Esses proxies s√£o
chamados de <strong>stubs</strong>.</p></li>
<li><p>Aloca√ß√£o de mem√≥ria por demanda para objetos que consomem muita
mem√≥ria. Por exemplo, uma classe pode manipular uma imagem em alta
resolu√ß√£o. Ent√£o, podemos usar um proxy para evitar que a imagem fique
carregada o tempo todo na mem√≥ria principal. Ela somente ser√° carregada,
possivelmente do disco, antes da execu√ß√£o de alguns m√©todos.</p></li>
<li><p>Controlar o acesso de diversos clientes a um objeto base. Por
exemplo, os clientes devem estar autenticados e ter permiss√£o para
executar certas opera√ß√µes do objeto base. Com isso, a classe do objeto
base pode se concentrar na implementa√ß√£o de requisitos
funcionais.</p></li>
</ul>
<h2 data-number="6.5" id="adaptador"><span
class="header-section-number">6.5</span> Adaptador <a href="#adaptador"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha um sistema que tenha que controlar
projetores multim√≠dia. Para isso ele deve instanciar objetos de classes
fornecidas pelos fabricantes de cada projetor, como ilustrado a
seguir:</p>
<pre><code>class ProjetorSamsung {
  public void turnOn() { ... }
  ...
}

class ProjetorLG {
  public void enable(int timer) { ... }
  ...
}</code></pre>
<p>Para simplificar, estamos mostrando apenas duas classes. Por√©m, um
cen√°rio real pode envolver classes de outros fabricantes de projetores.
Tamb√©m estamos mostrando apenas um m√©todo de cada classe, mas elas podem
conter outros m√©todos. Particularmente, o m√©todo mostrado √© respons√°vel
por ligar o projetor. No caso dos projetores da Samsung, esse m√©todo n√£o
possui par√¢metros. No caso dos projetores da LG podemos passar um
intervalo em minutos para liga√ß√£o do projetor. Se esse par√¢metro for
igual a zero, o projetor √© ligado imediatamente. Veja ainda que o nome
dos m√©todos √© diferente nas duas classes.</p>
<p><strong>Problema</strong>: No sistema de controle de projetores
multim√≠dia, queremos usar uma interface √∫nica para ligar os projetores,
independentemente de marca. O pr√≥ximo c√≥digo mostra essa interface e uma
classe cliente do sistema:</p>
<pre><code>interface Projetor {

  void liga();

}
...
class SistemaControleProjetores {

  void init(Projetor projetor) {
    projetor.liga();  // liga qualquer projetor
  }

}</code></pre>
<p>Por√©m, as classes de cada projetor ‚Äî mostradas anteriormente ‚Äî foram
implementadas pelos seus fabricantes e est√£o prontas para uso. Ou seja,
n√£o temos acesso ao c√≥digo dessas classes para fazer com que elas
implementem a interface <code>Projetor</code>.</p>
<p> <strong>Solu√ß√£o</strong>: O padr√£o de projeto
<strong>Adaptador</strong> ‚Äî tamb√©m conhecido como
<strong>Wrapper</strong> ‚Äî √© uma solu√ß√£o para o nosso problema.
Recomenda-se usar esse padr√£o quando temos que converter a interface de
uma classe para outra interface, esperada pelos seus clientes. No nosso
exemplo, ele pode ser usado para converter a interface
<code>Projetor</code> ‚Äî usada no sistema de controle de projetores ‚Äî
para as interfaces (m√©todos p√∫blicos) das classes implementadas pelos
fabricantes dos projetores.</p>
<p>Um exemplo de classe adaptadora, de <code>ProjetorSamsung</code> para
<code>Projetor</code>, √© mostrado a seguir:</p>
<pre><code>class AdaptadorProjetorSamsung implements Projetor {

  private ProjetorSamsung projetor;

  AdaptadorProjetorSamsung (ProjetorSamsung projetor) {
    this.projetor = projetor;
  }

  public void liga() {
    projetor.turnOn();
  }
}</code></pre>
<p>A classe <code>AdaptadorProjetorSamsung</code> implementa a interface
<code>Projetor</code>. Logo, objetos dessa classe podem ser passados
como par√¢metro do m√©todo <code>init()</code> do sistema para controle de
projetores. A classe <code>AdaptadorProjetorSamsung</code> tamb√©m possui
um atributo privado do tipo <code>ProjetorSamsung</code>. A sequ√™ncia de
chamadas √© ent√£o a seguinte (acompanhe tamb√©m pelo diagrama de sequ√™ncia
UML, mostrado na pr√≥xima p√°gina): primeiro, o cliente ‚Äî no nosso caso,
representado pelo m√©todo <code>init</code> ‚Äî chama <code>liga()</code>
da classe adaptadora; em seguida, a execu√ß√£o desse m√©todo chama o m√©todo
equivalente ‚Äî no caso, <code>turnOn()</code> ‚Äî do objeto que est√° sendo
<q>adaptado</q>; isto √©, um objeto que acessa projetores Samsung.</p>
<figure>
<img src="figs/cap6/padrao-adapter.svg" style="width:70.0%"
alt="Padr√£o de projeto Adaptador" />
<figcaption aria-hidden="true">Padr√£o de projeto Adaptador</figcaption>
</figure>
<p>Se quisermos manipular projetores LG, vamos ter que implementar uma
segunda classe adaptadora. No entanto, seu c√≥digo ser√° parecido com
<code>AdaptadorProjetorSamsung</code>.</p>
<h2 data-number="6.6" id="fachada"><span
class="header-section-number">6.6</span> Fachada <a href="#fachada"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha que implementamos um interpretador
para uma linguagem X. Esse interpretador permite executar programas X a
partir de uma linguagem hospedeira, no caso Java. Se quiser tornar o
exemplo mais real, imagine que X √© uma linguagem para consulta a dados,
semelhante a SQL. Para executar programas X, a partir de um c√≥digo em
Java, os seguintes passos s√£o necess√°rios:</p>
<pre><code>Scanner s = new Scanner(&quot;prog1.x&quot;);
Parser p = new Parser(s);
AST ast = p.parse();
CodeGenerator code = new CodeGenerator(ast);
code.eval();</code></pre>
<p><strong>Problema</strong>: Como a linguagem X est√° ficando popular,
os desenvolvedores est√£o reclamando da complexidade do c√≥digo acima,
pois ele requer conhecimento de classes internas do interpretador de X.
Logo, os usu√°rios frequentemente pedem uma interface mais simples para
chamar o interpretador da linguagem X.</p>
<p><strong>Solu√ß√£o</strong>: O padr√£o de projeto
<strong>Fachada</strong> √© uma solu√ß√£o para o nosso problema. Uma
Fachada √© uma classe que oferece uma interface mais simples para um
sistema. O objetivo √© evitar que os usu√°rios tenham que conhecer classes
internas desse sistema; em vez disso, eles precisam interagir apenas com
a classe de Fachada. As classes internas ficam encapsuladas por tr√°s
dessa Fachada.</p>
<p>No nosso problema, a Fachada poderia ser:</p>
<pre><code>class InterpretadorX {

  private String arq;

  InterpretadorX(arq) {
    this.arq = arq;
  }

  void eval() {
    Scanner s = new Scanner(arq);
    Parser p = new Parser(s);
    AST ast = p.parse();
    CodeGenerator code = new CodeGenerator(ast);
    code.eval();
  }
}</code></pre>
<p>Assim, os desenvolvedores que precisam executar programas X, a partir
de Java, poder√£o faz√™-lo por meio de uma √∫nica linha de c√≥digo:</p>
<pre><code> new InterpretadorX(&quot;prog1.x&quot;).eval();</code></pre>
<p>Antes de implementar a fachada, os clientes precisavam criar tr√™s
objetos de tipos internos do interpretador e chamar dois m√©todos. Agora,
basta criar um √∫nico objeto e chamar <code>eval</code>.</p>
<h2 data-number="6.7" id="decorador"><span
class="header-section-number">6.7</span> Decorador <a href="#decorador"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Vamos voltar ao sistema de comunica√ß√£o
remota usado para explicar o Padr√£o F√°brica. Suponha que as classes
<code>TCPChannel</code> e <code>UDPChannel</code> implementam uma
interface <code>Channel</code>:</p>
<pre><code>interface Channel {
  void send(String msg);
  String receive();
}

class TCPChannel implements Channel {
  ...
}

class UDPChannel implements Channel {
  ...
}</code></pre>
<p><strong>Problema</strong>: Os clientes dessas classes precisam
adicionar funcionalidades extras em canais, tais como buffers,
compacta√ß√£o das mensagens, log das mensagens trafegadas, etc. Mas essas
funcionalidades s√£o opcionais: dependendo do cliente precisamos de
apenas algumas funcionalidades ou, talvez, nenhuma delas. Uma primeira
solu√ß√£o consiste no uso de heran√ßa para criar subclasses com cada
poss√≠vel sele√ß√£o de funcionalidades. No quadro abaixo, mostramos algumas
das subclasses que ter√≠amos que criar (<code>extends</code> significa
rela√ß√£o de heran√ßa):</p>
<ul>
<li><p><code>TCPZipChannel extends TCPChannel</code></p></li>
<li><p><code>TCPBufferedChannel extends TCPChannel</code></p></li>
<li><p><code>TCPBufferedZipChannel extends TCPZipChannel extends TCPChannel</code></p></li>
<li><p><code>TCPLogChannel extends TCPChannel</code></p></li>
<li><p><code>TCPLogBufferedZipChannel extends TCPBufferedZipChannel extends</code></p>
<p><code>TCPZipChannel extends TCPChannel</code></p></li>
<li><p><code>UDPZipChannel extends UDPChannel</code></p></li>
<li><p><code>UDPBufferedChannel extends UDPChannel</code></p></li>
<li><p><code>UDPBufferedZipChannel extends UDPZipChannel extends UDPChannel</code></p></li>
<li><p><code>UDPLogChannel extends UDPChannel</code></p></li>
<li><p><code>UDPLogBufferedZipChannel extends UDPBufferedZipChannel extends</code></p>
<p><code>UDPZipChannel extends UDPChannel</code></p></li>
</ul>
<p>Nessa solu√ß√£o, usamos heran√ßa para implementar subclasses para cada
conjunto de funcionalidades. Suponha que o usu√°rio precise de um canal
UDP com buffer e compacta√ß√£o. Para isso, tivemos que implementar
<code>UDPBufferedZipChannel</code> como subclasse de
<code>UDPZipChannel</code>, que por sua vez foi implementada como
subclasse de <code>UDPChannel</code>. Como o leitor deve ter percebido,
uma solu√ß√£o via heran√ßa √© quase que invi√°vel, pois ela gera uma explos√£o
combinat√≥ria do n√∫mero de classes relacionadas com canais de
comunica√ß√£o.</p>
<p><strong>Solu√ß√£o</strong>: O Padr√£o Decorador representa uma
alternativa a heran√ßa quando se precisa adicionar novas funcionalidades
em uma classe base. Em vez de usar heran√ßa, usa-se composi√ß√£o para
adicionar tais funcionalidades dinamicamente nas classes base. Portanto,
Decorador √© um exemplo de aplica√ß√£o do princ√≠pio de projeto <q>Prefira
Composi√ß√£o a Heran√ßa</q>, que estudamos no cap√≠tulo anterior.</p>
<p>No nosso problema, ao optarmos por decoradores, o cliente poder√°
configurar um <code>Channel</code> da seguinte forma:</p>
<pre><code>channel = new ZipChannel(new TCPChannel());
// TCPChannel que compacte/descompacte dados 

channel = new BufferChannel(new TCPChannel());
// TCPChannel com um buffer associado

channel = new BufferChannel(new UDPChannel());
// UDPChannel com um buffer associado

channel= new BufferChannel(new ZipChannel(new TCPChannel()));
// TCPChannel com compacta√ß√£o e um buffer associado</code></pre>
<p>Portanto, em uma solu√ß√£o com decoradores, a configura√ß√£o de um
<code>Channel</code> √© feita no momento da sua instancia√ß√£o, por meio de
uma sequ√™ncia aninhada de operadores <code>new</code>. O
<code>new</code> mais interno sempre cria uma classe base, no nosso
exemplo <code>TCPChannel</code> ou <code>UDPChannel</code>. Feito isso,
os operadores mais externos s√£o usados para <q>decorar</q> o objeto
criado com novas funcionalidades.</p>
<p>Falta ent√£o explicar as classes que s√£o os decoradores propriamente
ditos, como <code>ZipChannel</code> e <code>BufferChannel</code>.
Primeiro, elas s√£o subclasses da seguinte classe que n√£o aparece no
exemplo, mas que √© fundamental para o funcionamento do padr√£o
Decorador:</p>
<pre><code>class ChannelDecorator implements Channel {

  private Channel channel;

  public ChannelDecorator(Channel channel) {
    this.channel = channel;
  }

  public void send(String msg) {
    channel.send(msg);
  }

  public String receive() {
    return channel.receive();
  }

}</code></pre>
<p>Essa classe tem duas caracter√≠sticas importantes:</p>
<ul>
<li><p>Ela √© uma <code>Channel</code>, isto √©, ela implementa essa
interface e, portanto, os seus dois m√©todos. Assim, sempre que for
esperado um objeto do tipo <code>Channel</code> podemos passar um objeto
do tipo <code>ChannelDecorator</code> no lugar.</p></li>
<li><p>Ela possui internamente um objeto do tipo <code>Channel</code>
para o qual delega as chamadas aos m√©todos <code>send</code> e
<code>receive</code>. Em outras palavras, um decorador, no nosso caso,
vai sempre referenciar um outro decorador. Ap√≥s implementar a
funcionalidade que lhe cabe ‚Äî um buffer, compacta√ß√£o, etc. ‚Äî ele repassa
a chamada para esse decorador.</p></li>
</ul>
<p>Por fim, chegamos aos decoradores reais. Eles s√£o subclasses de
<code>ChannelDecorator</code>, como no c√≥digo a seguir, que implementa
um decorador que compacta e descompacta as mensagens trafegadas pelo
canal:</p>
<pre><code>class ZipChannel extends ChannelDecorator {

  public ZipChannel(Channel c) {
    super(c);
  }  

  public void send(String msg) {
    &quot;compacta mensagem msg&quot;
    super.send(msg);
  }

  public String receive() {
    String msg = super.receive();
    &quot;descompacta mensagem msg&quot;
    return msg;
  }

}</code></pre>
<p>Para entender o funcionamento de <code>ZipChannel</code>, suponha o
seguinte c√≥digo:</p>
<pre><code>Channel c = new ZipChannel(new TCPChannel());
c.send(&quot;Hello, world&quot;)</code></pre>
<p>A chamada de <code>send</code> na √∫ltima linha do exemplo dispara as
seguintes execu√ß√µes de m√©todos:</p>
<ul>
<li><p>Primeiro, executa-se <code>ZipChannel.send</code>, que vai
compactar a mensagem.</p></li>
<li><p>Ap√≥s a compacta√ß√£o, <code>ZipChannel.send</code> chama
<code>super.send</code>, que vai executar
<code>ChannelDecorator.send</code>, pois <code>ChannelDecorator</code> √©
a superclasse da classe <code>ZipChannel</code>.</p></li>
<li><p><code>ChannelDecorator.send</code> apenas repassa a chamada para
o <code>Channel</code> por ele referenciado, que no caso √© um
<code>TCPChannel</code>.</p></li>
<li><p>Finalmente, chegamos a <code>TCPChannel.send</code>, que vai
transmitir a mensagem via TCP.</p></li>
</ul>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo do exemplo de Decorador usado
nesta se√ß√£o est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/c8d65378a2904af01c20c53922f5ae1d">link</a>.</p>
<h2 data-number="6.8" id="strategy"><span
class="header-section-number">6.8</span> Strategy <a href="#strategy"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha que estamos implementando um
pacote de estruturas de dados, com a seguinte classe lista:</p>
<pre><code>class MyList {

  ... // dados de uma lista
  ... // m√©todos de uma lista: add, delete, search

  public void sort() {
    ... // ordena a lista usando Quicksort
  }
}</code></pre>
<p><strong>Problema</strong>: os nossos clientes est√£o solicitando que
novos algoritmos de ordena√ß√£o possam ser usados para ordenar os
elementos da lista. Explicando melhor, eles querem ter a op√ß√£o de
alterar e definir, por conta pr√≥pria, o algoritmo de ordena√ß√£o. No
entanto, a vers√£o atual da classe sempre ordena a lista usando o
algoritmo Quicksort. Se lembrarmos dos princ√≠pios de projeto que
estudamos no cap√≠tulo anterior, podemos dizer que a classe
<code>MyList</code> n√£o segue o princ√≠pio Aberto/Fechado, considerando o
algoritmo de ordena√ß√£o.</p>
<p><strong>Solu√ß√£o</strong>: o Padr√£o <strong>Strategy</strong> √© a
solu√ß√£o para o nosso problema de <q>abrir</q> a classe
<code>MyList</code> para novos algoritmos de ordena√ß√£o, mas sem alterar
o seu c√≥digo fonte. O objetivo do padr√£o √© parametrizar os algoritmos
usados por uma classe. Ele prescreve como encapsular uma fam√≠lia de
algoritmos e como torn√°-los intercambi√°veis. Assim, seu uso √©
recomendado quando uma classe √© usu√°ria de um certo algoritmo (de
ordena√ß√£o, no nosso exemplo). Por√©m, como existem diversos algoritmos
com esse prop√≥sito, n√£o se quer antecipar uma decis√£o e implementar
apenas um deles no corpo da classe, como ocorre na primeira vers√£o de
<code>MyList</code>.</p>
<p>Mostra-se a seguir o novo c√≥digo de <code>MyList</code>, usando o
Padr√£o Strategy para configura√ß√£o do algoritmo de ordena√ß√£o:</p>
<pre><code>class MyList {

  ... // dados de uma lista
  ... // m√©todos de uma lista: add, delete, search

  private SortStrategy strategy;

  public MyList() {
    strategy = new QuickSortStrategy();
  }

  public void setSortStrategy(SortStrategy strategy) {
    this.strategy = strategy;
  }

  public void sort() {
    strategy.sort(this);
  }
}</code></pre>
<p>Nessa nova vers√£o, o algoritmo de ordena√ß√£o transformou-se em um
atributo da classe <code>MyList</code> e um m√©todo <code>set</code> foi
criado para configurar esse algoritmo. O m√©todo <code>sort</code>
repassa a tarefa de ordena√ß√£o para um m√©todo de mesmo nome do objeto com
a estrat√©gia de ordena√ß√£o. Nessa chamada, passa-se <code>this</code>
como par√¢metro, pois o algoritmo a ser executado deve ter acesso √† lista
para ordenar seus elementos.</p>
<p>Para encerrar a apresenta√ß√£o do padr√£o, mostramos o c√≥digo das
classes que implementam as estrat√©gias ‚Äî isto √©, os algoritmos ‚Äî de
ordena√ß√£o:</p>
<pre><code>abstract class SortStrategy {
  abstract void sort(MyList list);
}

class QuickSortStrategy extends SortStrategy {
  void sort(MyList list) { ... }
}

class ShellSortStrategy extends SortStrategy {
  void sort(MyList list) { ... }
}</code></pre>
<h2 data-number="6.9" id="observador"><span
class="header-section-number">6.9</span> Observador <a
href="#observador" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha que estamos implementando um
sistema para controlar uma esta√ß√£o meteorol√≥gica. Nesse sistema, temos
que manipular objetos de duas classes: <code>Temperatura</code>, que s√£o
objetos de <q>modelo</q> que armazenam as temperaturas monitoradas na
esta√ß√£o meteorol√≥gica; e <code>Termometro</code>, que √© uma classe usada
para criar objetos visuais que exibem as temperaturas sob monitoramento.
Term√¥metros devem exibir a temperatura atual que foi monitorada. Se a
temperatura mudar, os term√¥metros devem ser atualizados.</p>
<p><strong>Problema</strong>: N√£o queremos acoplar
<code>Temperatura</code> (classe de modelo) a <code>Termometro</code>
(classe de interface). O motivo √© simples: classes de interface mudam
com frequ√™ncia. Na vers√£o atual, o sistema possui uma interface textual,
que exibe temperaturas em Celsius no console do sistema operacional.
Mas, em breve, pretendemos ter interfaces Web, para celulares e para
outros sistemas. Pretendemos tamb√©m oferecer outras interfaces de
term√¥metros, tais como digital, anal√≥gico, etc. Por fim, temos mais
classes semelhantes a <code>Temperatura</code> e <code>Termometro</code>
em nosso sistema, tais como: <code>PressaoAtmosferica</code> e
<code>Barometro</code>, <code>UmidadeDoAr</code> e
<code>Higrometro</code>, <code>VelocidadeDoVento</code> e
<code>Anemometro</code>, etc. Logo, na medida do poss√≠vel, gostar√≠amos
de reusar o mecanismo de notifica√ß√£o tamb√©m nesses outros pares de
classes.</p>
<p><strong>Solu√ß√£o:</strong> O padr√£o <strong>Observador</strong> √© a
solu√ß√£o recomendada para o nosso contexto e problema. Esse padr√£o define
como implementar uma rela√ß√£o do tipo um-para-muitos entre objetos
sujeito e observadores. Quando o estado de um sujeito muda, seus
observadores devem ser notificados.</p>
<p>Primeiro, vamos mostrar um programa principal para o nosso
problema:</p>
<pre><code>void main() {
  Temperatura t = new Temperatura();
  t.addObserver(new TermometroCelsius());
  t.addObserver(new TermometroFahrenheit());
  t.setTemp(100.0);
}</code></pre>
<p>Esse programa cria um objeto do tipo <code>Temperatura</code> (um
sujeito) e ent√£o adiciona dois observadores nele: um
<code>TermometroCelsius</code> e um <code>TermometroFahrenheit</code>.
Por fim, define-se o valor da temperatura para 100 graus Celsius. A
suposi√ß√£o √© que temperaturas s√£o, por <em>default</em>, monitoradas na
escala Celsius.</p>
<p>As classes <code>Temperatura</code> e <code>TermometroCelsius</code>
s√£o mostradas a seguir:</p>
<pre><code>class Temperatura extends Subject {

  private double temp;

  public double getTemp() {
    return temp;
  }

  public void setTemp(double temp) {
    this.temp = temp;
    notifyObservers();
  }
}

class TermometroCelsius implements Observer {

  public void update(Subject s){
    double temp = ((Temperatura) s).getTemp();
    System.out.println(&quot;Temperatura Celsius: &quot; + temp);
  }
}</code></pre>
<p>Veja que <code>Temperatura</code> herda de uma classe chamada
<code>Subject</code>. Na solu√ß√£o proposta, todos os sujeitos devem
estender essa classe. Ao fazer isso, eles herdam dois m√©todos:</p>
<ul>
<li><p><code>addObserver</code>. No exemplo, esse m√©todo √© usado no
programa principal para adicionar dois term√¥metros como observadores de
uma inst√¢ncia de <code>Temperatura</code>.</p></li>
<li><p><code>notifyObservers</code>. No exemplo, esse m√©todo √© chamado
por <code>Temperatura</code> para notificar seus observadores de que o
seu valor foi alterado no m√©todo <code>setTemp</code>.</p></li>
</ul>
<p>A implementa√ß√£o de <code>notifyObservers</code> ‚Äî que √© omitida no
exemplo ‚Äî chama o m√©todo <code>update</code> dos objetos que se
registraram como observadores de uma determinada inst√¢ncia de
<code>Temperatura</code>. O m√©todo <code>update</code> faz parte da
interface <code>Observer</code>, que deve ser implementada por todo
observador, como √© o caso de <code>TermometroCelsius</code>.</p>
<p>A figura da pr√≥xima p√°gina mostra um diagrama de sequ√™ncia UML que
ilustra a comunica√ß√£o entre uma temperatura (sujeito) e tr√™s poss√≠veis
term√¥metros (observadores). Assume-se que os tr√™s term√¥metros est√£o
registrados como observadores da temperatura. A sequ√™ncia de chamadas
come√ßa com temperatura recebendo uma chamada para executar
<code>setTemp()</code>.</p>
<figure>
<img src="figs/cap6/padrao-observer.svg" style="width:90.0%"
alt="Padr√£o de projeto Observador" />
<figcaption aria-hidden="true">Padr√£o de projeto Observador</figcaption>
</figure>
<p>O padr√£o Observador possui as seguintes vantagens principais:</p>
<ul>
<li><p>Ele n√£o acopla os sujeitos a seus observadores. Na verdade, os
sujeitos ‚Äî como <code>Temperatura</code>, no exemplo ‚Äî n√£o conhecem os
seus observadores. De forma gen√©rica, os sujeitos publicam um evento
anunciando a mudan√ßa de seu estado ‚Äî chamando
<code>notifyObservers</code> ‚Äî e os observadores interessados s√£o
notificados. Esse comportamento facilita o re√∫so dos sujeitos em
diversos cen√°rios e, tamb√©m, a implementa√ß√£o de diversos tipos de
observadores para o mesmo tipo de sujeito.</p></li>
<li><p>Uma vez implementado, o padr√£o Observador disponibiliza um
mecanismo de notifica√ß√£o que pode ser reusado por diferentes pares de
sujeito-observador. Por exemplo, podemos reusar a classe
<code>Subject</code> e a interface <code>Observer</code> para
notifica√ß√µes envolvendo press√£o atmosf√©rica e bar√¥metros, umidade do ar
e higr√¥metros, velocidade do vento e anem√¥metros, etc.</p></li>
</ul>
<p><strong>C√≥digo Fonte</strong>: Se quiser conferir o c√≥digo completo
do nosso exemplo de Observador, incluindo o c√≥digo das classes
<code>Subject</code> e da interface <code>Observer</code>, acesse o
seguinte <a
href="https://gist.github.com/mtov/5fadb0e599cb84fd6bd124b2ff37c03c">link</a>.</p>
<h2 data-number="6.10" id="template-method"><span
class="header-section-number">6.10</span> Template Method <a
href="#template-method" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha que estamos desenvolvendo uma
folha de pagamento. Nela, temos uma classe <code>Funcionario</code>, com
duas subclasses: <code>FuncionarioPublico</code> e
<code>FuncionarioCLT</code>.</p>
<p><strong>Problema</strong>: Pretendemos padronizar um modelo (ou
template) para c√°lculo dos sal√°rios na classe base
<code>Funcionario</code>, que possa depois ser herdado pelas suas
subclasses. Assim, as subclasses ter√£o apenas que adaptar a rotina de
c√°lculo de sal√°rios √†s suas particularidades. Mais especificamente, as
subclasses saber√£o exatamente os m√©todos que precisam implementar para
calcular o sal√°rio de um funcion√°rio.</p>
<p><strong>Solu√ß√£o</strong>: O padr√£o de projeto <strong>Template
Method</strong> resolve o problema que enunciamos. Ele especifica como
implementar o <q>esqueleto</q> de um algoritmo em uma classe abstrata X,
mas deixando pendente alguns passos ‚Äî ou m√©todos abstratos. Esses
m√©todos ser√£o implementados nas subclasses de X. Em resumo, um Template
Method permite que subclasses customizem um algoritmo, mas sem mudar a
sua estrutura geral implementada na classe base.</p>
<p>Um exemplo de Template Method para o nosso contexto e problema √©
mostrado a seguir:</p>
<pre><code>abstract class Funcionario {

  double salario;
  ...
  abstract double calcDescontosPrevidencia();
  abstract double calcDescontosPlanoSaude();
  abstract double calcOutrosDescontos();

  public double calcSalarioLiquido() { // template method
    double prev = calcDescontosPrevidencia();
    double saude = calcDescontosPlanoSaude();
    double outros = calcOutrosDescontos();
    return salario - prev - saude - outros;
  }
}</code></pre>
<p>Nesse exemplo, <code>calcSalarioLiquido</code> √© um m√©todo template
para c√°lculo do sal√°rio de funcion√°rios. Ele padroniza que temos que
calcular tr√™s descontos: para a previd√™ncia, para o plano de sa√∫de do
funcion√°rio e outros descontos. Feito isso, o sal√°rio l√≠quido √© o
sal√°rio do funcion√°rio subtra√≠do desses tr√™s descontos. Por√©m, em
<code>Funcionario</code>, n√£o sabemos ainda como calcular os descontos,
pois eles variam conforme o tipo de funcion√°rio (p√∫blico ou CLT). Logo,
s√£o criados m√©todos abstratos para representar cada um desses passos da
rotina de c√°lculo de sal√°rios. Como eles s√£o abstratos, a classe
<code>Funcionario</code> tamb√©m foi declarada como abstrata. Como o
leitor j√° deve ter percebido, subclasses de <code>Funcionario</code> ‚Äî
como <code>FuncionarioPublico</code> e <code>FuncionarioCLT</code> ‚Äî v√£o
herdar o m√©todo <code>calcSalarioLiquido</code>, que n√£o precisar√°
sofrer nenhuma modifica√ß√£o. No entanto, caber√° √†s subclasses implementar
os tr√™s passos (m√©todos) abstratos:
<code>calcDescontosPrevidencia</code>,
<code>calcDescontosPlanoSaude</code> e
<code>calcOutrosDescontos</code>.</p>
<p> M√©todos template permitem que <q>c√≥digo antigo</q> chame <q>c√≥digo
novo</q>. No exemplo, a classe <code>Funcionario</code> provavelmente
foi implementada antes de <code>FuncionarioPublico</code> e
<code>FuncionarioCLT</code>. Logo, dizemos que <code>Funcionario</code>
√© mais antiga do que as suas subclasses. Mesmo assim,
<code>Funcionario</code> inclui um m√©todo que vai chamar <q>c√≥digo
novo</q>, implementado nas subclasses. Esse recurso de sistemas
orientados a objetos √© chamado de <strong>invers√£o de controle</strong>.
Ele √© fundamental, por exemplo, para implementa√ß√£o de
<strong>frameworks</strong>, isto √©, aplica√ß√µes semi-prontas, que antes
de serem usadas devem ser customizadas por seus clientes. Apesar de n√£o
ser o √∫nico instrumento dispon√≠vel para esse fim, m√©todos template
constituem uma alternativa interessante para que um cliente implemente o
c√≥digo faltante em um framework.</p>
<h2 data-number="6.11" id="visitor"><span
class="header-section-number">6.11</span> Visitor <a href="#visitor"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Contexto</strong>: Suponha o sistema de estacionamentos que
usamos no Cap√≠tulo 5. Suponha que nesse sistema existe uma classe
<code>Veiculo</code>, com subclasses <code>Carro</code>,
<code>Onibus</code> e <code>Motocicleta</code>. Essas classes s√£o usadas
para armazenar informa√ß√µes sobre os ve√≠culos estacionados no
estacionamento. Suponha ainda que todos esses ve√≠culos est√£o armazenados
em uma lista. Dizemos que essa lista √© uma estrutura de dados
<strong>polim√≥rfica</strong>, pois ela pode armazenar objetos de classes
diferentes, desde que eles sejam subclasses de <code>Veiculo</code>.</p>
<p><strong>Problema:</strong> Com frequ√™ncia, no sistema de
estacionamentos, temos que realizar uma opera√ß√£o em todos os ve√≠culos
estacionados. Como exemplo, podemos citar: imprimir informa√ß√µes sobre os
ve√≠culos estacionados, persistir os dados dos ve√≠culos ou enviar uma
mensagem para os donos dos ve√≠culos.</p>
<p>No entanto, o objetivo √© implementar essas opera√ß√µes fora das classes
de <code>Veiculo</code> por meio de um c√≥digo como o seguinte:</p>
<pre><code>interface Visitor {
  void visit(Carro c);
  void visit(Onibus o);
  void visit(Motocicleta m);
}  

class PrintVisitor implements Visitor {
  public void visit(Carro c) { &quot;imprime dados de carro&quot; }
  public void visit(Onibus o) { &quot;imprime dados de onibus&quot; }
  public void visit(Motocicleta m) {&quot;imprime dados de moto&quot;}
}</code></pre>
<p>Nesse c√≥digo, a classe <code>PrintVisitor</code> inclui m√©todos que
imprimem os dados de um <code>Carro</code>, <code>Onibus</code> e
<code>Motocicleta</code>. Uma vez implementada essa classe, gostar√≠amos
de usar o seguinte c√≥digo para <q>visitar</q> todos os ve√≠culos do
estacionamento::</p>
<pre><code>PrintVisitor visitor = new PrintVisitor();
foreach (Veiculo veiculo: listaDeVeiculosEstacionados) {
  visitor.visit(veiculo); // erro de compila√ß√£o
}</code></pre>
<p>No entanto, no c√≥digo mostrado, o m√©todo <code>visit</code> a ser
chamado depende do tipo din√¢mico do objeto alvo da chamada
(<code>visitor</code>) e do tipo din√¢mico de um par√¢metro
(<code>veiculo</code>). Por√©m, em linguagens como Java, C++ ou C# apenas
o tipo do objeto alvo da chamada √© considerado na escolha do m√©todo a
ser chamado. Dizendo de outro modo, em Java e em linguagens similares, o
compilador somente conhece o tipo est√°tico de <code>veiculo</code>, que
√© <code>Veiculo</code>. Por isso, ele n√£o consegue inferir qual
implementa√ß√£o de <code>visit</code> deve ser chamada.</p>
<p>Para ficar mais claro, o seguinte erro ocorre ao compilar o c√≥digo
anterior:</p>
<pre><code>visitor.visit(veiculo);  
         ^
method PrintVisitor.visit(Carro) is not applicable
  (argument mismatch; Veiculo cannot be converted to Carro)
method PrintVisitor.visit(Onibus) is not applicable
  (argument mismatch; Veiculo cannot be converted to Onibus)</code></pre>
<p> Na verdade, esse c√≥digo somente compila em linguagens que oferecem
<strong>despacho duplo</strong> de chamadas de m√©todos (<em>double
dispatch</em>). Nessas linguagens, os tipos do objeto alvo e de um dos
par√¢metros de chamada s√£o usados para escolher o m√©todo que ser√°
invocado. No entanto, despacho duplo somente est√° dispon√≠vel em
linguagens mais antigas e menos conhecidas hoje em dia, como Common
Lisp.</p>
<p>Portanto, o nosso problema √© o seguinte: como simular <em>double
dispatch</em> em uma linguagem como Java? Se conseguirmos fazer isso,
poderemos contornar o erro de compila√ß√£o que ocorre no c√≥digo que
mostramos.</p>
<p><strong>Solu√ß√£o</strong>: A solu√ß√£o para o nosso problema consiste em
usar o padr√£o de projeto <strong>Visitor</strong>. Esse padr√£o define
como <q>adicionar</q> uma opera√ß√£o em uma fam√≠lia de objetos, sem que
seja preciso modificar as classes dos mesmos. Al√©m disso, o padr√£o
Visitor deve funcionar mesmo em linguagens com <em>single
dispatching</em> de m√©todos, como Java.</p>
<p> Como primeiro passo, temos que implementar um m√©todo
<code>accept</code> em cada classe da hierarquia. Na classe raiz, ele √©
abstrato. Nas subclasses, ele recebe como par√¢metro um objeto do tipo
<code>Visitor</code>. E a sua implementa√ß√£o apenas chama o m√©todo
<code>visit</code> desse <code>Visitor</code>, passando
<code>this</code> como par√¢metro. Por√©m, como a chamada ocorre no corpo
de uma classe, o compilador conhece o tipo de <code>this</code>. Por
exemplo, na classe <code>Carro</code>, o compilador sabe que o tipo de
<code>this</code> √© <code>Carro</code>. Logo, ele sabe que deve chamar a
implementa√ß√£o de <code>visit</code> que tem <code>Carro</code> como
par√¢metro. Para ser preciso, o m√©todo exato a ser chamado depende do
tipo din√¢mico do objeto alvo da chamada (<code>v</code>). Por√©m, isso
n√£o √© um problema, pois significa que temos um caso de <em>single
dispatch</em>, que √© permitido em linguagens como Java.</p>
<pre><code>abstract class Veiculo {
  abstract public void accept(Visitor v);
}

class Carro extends Veiculo {
  ...
  public void accept(Visitor v) {
    v.visit(this);
  }
  ...
}

class Onibus extends Veiculo {
  ...
  public void accept(Visitor v) {
    v.visit(this);
  }
  ...
}

// Idem para Motocicleta</code></pre>
<p>Por √∫ltimo, temos que modificar o la√ßo que percorre a lista de
ve√≠culos estacionados. Agora, chamaremos os m√©todos <code>accept</code>
de cada ve√≠culo, passando o visitor como par√¢metro.</p>
<pre><code>PrintVisitor visitor = new PrintVisitor();
foreach (Veiculo veiculo: listaDeVeiculosEstacionados) {
  veiculo.accept(visitor);
}</code></pre>
<p>Resumindo, visitors facilitam a adi√ß√£o de um m√©todo em uma hierarquia
de classes. Um visitor congrega opera√ß√µes relacionadas ‚Äî no exemplo,
impress√£o de dados de <code>Veiculo</code> e de suas subclasses. Mas
poderia tamb√©m existir um segundo visitor, com outras opera√ß√µes ‚Äî por
exemplo, persistir os objetos em disco. Por outro lado, a adi√ß√£o de uma
nova classe na hierarquia, por exemplo, <code>Caminhao</code>, requer a
atualiza√ß√£o de todos os visitors com um novo m√©todo:
<code>visit(Caminhao)</code>.</p>
<p>Antes de concluir, √© importante mencionar que visitors possuem uma
desvantagem importante: eles podem for√ßar uma quebra no encapsulamento
das classes que ser√£o visitadas. Por exemplo, <code>Veiculo</code> pode
ter que implementar m√©todos p√∫blicos expondo seu estado interno para que
os visitors tenham acesso a eles.</p>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo do exemplo de Visitor usado
nesta se√ß√£o est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/d447fd22974c57688d0fd109cb9509ea">link</a>.</p>
<h2 data-number="6.12" id="outros-padr√µes-de-projeto"><span
class="header-section-number">6.12</span> Outros Padr√µes de Projeto <a
href="#outros-padr√µes-de-projeto" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p> </p>
<p><strong>Iterador</strong> √© um padr√£o de projeto que padroniza uma
interface para caminhar sobre uma estrutura de dados. Normalmente, essa
interface inclui m√©todos como <code>hasNext()</code> e
<code>next()</code>, como mostrado no seguinte exemplo:</p>
<pre><code>List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);
Iterator it = list.iterator();
while(it.hasNext()) {
  String s = (String) it.next();
  System.out.println(s);
}</code></pre>
<p>Um iterador permite percorrer uma estrutura de dados sem conhecer o
seu tipo concreto. Em vez disso, basta conhecer os m√©todos da interface
Iterator. Iteradores tamb√©m permitem que m√∫ltiplos caminhamentos sejam
realizadas de forma simult√¢nea em cima da mesma estrutura de dados.</p>
<p> </p>
<p><strong>Builder</strong> √© um padr√£o de projeto que facilita a
instancia√ß√£o de objetos que t√™m muitos atributos, sendo alguns deles
opcionais. Se o valor desses atributos opcionais n√£o for informado, eles
devem ser inicializados com um valor <em>default</em>. Em vez de criar
diversos m√©todos construtores, um m√©todo para cada combina√ß√£o poss√≠vel
de par√¢metros, podemos delegar o processo de inicializa√ß√£o dos campos de
um objeto para uma classe <code>Builder</code>. Um exemplo √© mostrado a
seguir, para uma classe <code>Livro</code>.</p>
<pre><code>Livro esm = new Livro.Builder().
                  setNome(&quot;Engenharia Soft Moderna&quot;).
                  setEditora(&quot;UFMG&quot;).setAno(2020).build();

Livro gof = new Livro.Builder().setName(&quot;Design Patterns&quot;).
                  setAutores(&quot;GoF&quot;).setAno(1995).build();</code></pre>
<p>Uma primeira alternativa ao uso de um Builder seria implementar a
instancia√ß√£o por meio de construtores. Por√©m, ter√≠amos que criar
diversos construtores, pois <code>Livro</code> possui diversos
atributos, nem todos obrigat√≥rios. Al√©m disso, a chamada desses
construtores poderia gerar confus√£o, pois o desenvolvedor teria que
conhecer exatamente a ordem dos diversos par√¢metros. Com o padr√£o
Builder, os m√©todos <code>set</code> deixam claro qual atributo de
<code>Livro</code> est√° sendo inicializado. Uma segunda alternativa
seria implementar os m√©todos <code>set</code> diretamente na classe
<code>Livro</code>. Por√©m, isso quebraria o princ√≠pio de ocultamento da
informa√ß√£o, pois tornaria poss√≠vel alterar, a qualquer momento, qualquer
atributo da classe. Por outro lado, com um Builder, os atributos somente
podem ser definidos em tempo de instancia√ß√£o da classe.</p>
<p>Em tempo, a vers√£o de Builder que apresentamos n√£o corresponde √†
descri√ß√£o original do padr√£o contida no livro da Gangue dos Quatro. Em
vez disso, apresentamos uma vers√£o proposta por Joshua Bloch (<a
href="https://dl.acm.org/citation.cfm?id=1377533">link</a>). Acreditamos
que essa vers√£o, hoje em dia, corresponde ao uso mais comum de Builders.
Ela √© usada, por exemplo, em classes da API de Java, como
<code>Calendar.Builder</code> (<a
href="https://docs.oracle.com/javase/9/docs/api/java/util/Calendar.Builder.html">link</a>).</p>
<p><strong>C√≥digo Fonte</strong>: O c√≥digo do exemplo de Builder ‚Äî
incluindo as classes <code>Livro</code> e <code>Livro.Builder</code> ‚Äî
est√° dispon√≠vel neste <a
href="https://gist.github.com/mtov/cb98612474f01eccc5e10fa08f82a62b">link</a>.
Ao estud√°-lo, voc√™ perceber√° que <code>Livro.Builder</code> √© uma classe
interna, p√∫blica e est√°tica de <code>Livro</code>. Por isso, √© que
podemos chamar <code>new Livro.Builder()</code> diretamente, sem
precisar de instanciar antes um objeto do tipo <code>Livro</code>.</p>
<h2 data-number="6.13" id="quando-n√£o-usar-padr√µes-de-projeto"><span
class="header-section-number">6.13</span> Quando N√£o Usar Padr√µes de
Projeto? <a href="#quando-n√£o-usar-padr√µes-de-projeto"
class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Padr√µes de projeto t√™m como objetivo tornar o projeto de um sistema
mais flex√≠vel. Por exemplo, f√°bricas facilitam trocar o tipo dos objetos
manipulados por um programa. Um decorador permite personalizar uma
classe com novas funcionalidades, tornando-a flex√≠vel a outros cen√°rios
de uso. O padr√£o Strategy permite configurar os algoritmos usados por
uma classe, apenas para citar alguns exemplos.</p>
<p>Por√©m, como quase tudo em Computa√ß√£o, o uso de padr√µes tamb√©m tem um
custo. Por exemplo, uma f√°brica requer a implementa√ß√£o de pelo menos
mais uma classe no sistema. Para citar um segundo exemplo, Strategy
requer a cria√ß√£o de uma classe abstrata e mais uma classe para cada
algoritmo. Por isso, a ado√ß√£o de padr√µes de projeto exige uma an√°lise
cuidadosa. Para ilustrar esse tipo de an√°lise, vamos continuar a usar os
exemplos de F√°brica e Strategy:</p>
<ul>
<li><p>Antes de usar uma f√°brica, devemos fazer (e responder) a seguinte
pergunta: vamos mesmo precisar criar objetos de tipos diferentes no
nosso sistema? Existem boas chances de que tais objetos sejam, de fato,
necess√°rios? Se sim, ent√£o vale a pena usar uma F√°brica para encapsular
a cria√ß√£o de tais objetos. Caso contr√°rio, √© melhor criar os objetos
usando o operador <code>new</code>, que √© a solu√ß√£o nativa para cria√ß√£o
de objetos em linguagens como Java.</p></li>
<li><p>De forma semelhante, antes de incluir o padr√£o Strategy em uma
certa classe devemos nos perguntar: vamos mesmo precisar de parametrizar
os algoritmos usados na implementa√ß√£o dessa classe? Existem, de fato,
usu√°rios que v√£o precisar de algoritmos alternativos? Se sim, vale a
pena usar o padr√£o Strategy. Caso contr√°rio, √© prefer√≠vel implementar o
algoritmo diretamente no corpo da classe.</p></li>
</ul>
<p>Apesar de usarmos apenas dois padr√µes como exemplo, perguntas
semelhantes podem ser feita para outros padr√µes.</p>
<p>No entanto, em muitos sistemas observa-se um uso exagerado de padr√µes
de projeto, em situa√ß√µes nas quais os ganhos de flexibilidade e
extensibilidade s√£o question√°veis. Existe at√© um termo para se referir a
essa situa√ß√£o: <strong>paternite</strong>, isto √©, uma <q>inflama√ß√£o</q>
associada ao uso precipitado de padr√µes de projeto.</p>
<p> John Ousterhout tem um coment√°rio relacionado a essa
<q>doen√ßa</q>:</p>
<blockquote>
<p><q>O maior risco de padr√µes de projetos √© a sua super-aplica√ß√£o
(<em>over-application</em>). Nem todo problema precisa ser resolvido por
meio dos padr√µes de projeto; por isso, n√£o tente for√ßar um problema a
caber em um padr√£o de projeto quando uma abordagem tradicional funcionar
melhor. O uso de padr√µes de projeto n√£o necessariamente melhora o
projeto de um sistema de software; isso s√≥ acontece se esse uso for
justificado. Assim como ocorre com outros conceitos, a no√ß√£o de que
padr√µes de projetos s√£o uma boa coisa n√£o significa que quanto mais
padr√µes de projeto usarmos, melhor ser√° nosso sistema.</q></p>
</blockquote>
<p>Ousterhout ilustra seu argumento citando o emprego de decoradores
durante a abertura de arquivos em Java, como mostrado no seguinte trecho
de c√≥digo:</p>
<pre><code>FileInputStream fs = new FileInputStream(fileName);
BufferedInputStream bs = new BufferedInputStream(fs);
ObjectInputStream os = new ObjectInputStream(bs);</code></pre>
<p>Segundo Ousterhout, decoradores adicionam complexidade desnecess√°ria
ao processo de cria√ß√£o de arquivos em Java. O principal motivo √© que,
via de regra, iremos sempre nos beneficiar de um buffer ao abrir
qualquer arquivo. Portanto, buffers de entrada/sa√≠da deveriam ser
oferecidos por <em>default</em>, em vez de por meio de uma classe
decoradora espec√≠fica. Assim, e de acordo com esse racioc√≠nio, as
classes <code>FileInputStream</code> e <code>BufferedInputStream</code>
poderiam ser fundidas em uma √∫nica classe.</p>
<h2 class="unnumbered" id="bibliografia">Bibliografia <a
href="#bibliografia" class="anchor-link" aria-hidden="true">üîó</a></h2>
<p>Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. Design
Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley,
1995.</p>
<p>Joshua Bloch. Effective Java. 3rd edition. Prentice Hall, 2017.</p>
<p>Eric Freeman, Elisabeth Robson, Bert Bates, Kathy Sierra. Head First
Design Patterns: A Brain-Friendly Guide. O'Reilly, 2004.</p>
<p>Eduardo Guerra. Design Patterns com Java: Projeto Orientado a Objetos
guiado por Padr√µes. Casa do C√≥digo, 2014.</p>
<p>Fernando Pereira, Marco Tulio Valente, Roberto Bigonha, Mariza
Bigonha. Arcademis: A Framework for Object Oriented Communication
Middleware Development. Software: Practice and Experience, 2006.</p>
<p>Fabio Tirelo, Roberto Bigonha, Mariza Bigonha, Marco Tulio Valente.
Desenvolvimento de Software Orientado por Aspectos. XXIII Jornada de
Atualiza√ß√£o em Inform√°tica (JAI), 2004.</p>
<h2 class="unnumbered" id="exerc√≠cios-de-fixa√ß√£o">Exerc√≠cios de Fixa√ß√£o
<a href="#exerc√≠cios-de-fixa√ß√£o" class="anchor-link"
aria-hidden="true">üîó</a></h2>
<p>1. (ENADE 2011, adaptado) Sobre padr√µes de projeto, assinale V ou
F.</p>
<p>( ) Prototype √© um tipo de padr√£o estrutural.</p>
<p>( ) Singleton tem por objetivo garantir que uma classe tenha ao menos
uma inst√¢ncia e fornecer um ponto global de acesso para ela.</p>
<p>( ) Template Method tem por objetivo definir o esqueleto de um
algoritmo em uma opera√ß√£o, postergando a defini√ß√£o de alguns passos para
subclasses.</p>
<p>( ) Iterator fornece uma maneira de acessar sequencialmente os
elementos de um objeto agregado sem expor sua representa√ß√£o
subjacente.</p>
<p>2. D√™ o nome dos seguintes padr√µes de projeto:</p>
<ol type="a">
<li><p>Oferece uma interface unificada e de alto n√≠vel que torna mais
f√°cil o uso de um sistema.</p></li>
<li><p>Garante que uma classe possui, no m√°ximo, uma inst√¢ncia e oferece
um ponto √∫nico de acesso a ela.</p></li>
<li><p>Facilita a constru√ß√£o de objetos complexos com v√°rios atributos,
sendo alguns deles opcionais.</p></li>
<li><p>Converte a interface de uma classe para outra interface esperada
pelos clientes. Permite que classes trabalhem juntas, o que n√£o seria
poss√≠vel devido √† incompatibilidade de suas interfaces.</p></li>
<li><p>Oferece uma interface ou classe abstrata para cria√ß√£o de uma
fam√≠lia de objetos relacionados.</p></li>
<li><p>Oferece um m√©todo para centralizar a cria√ß√£o de um tipo de
objeto.</p></li>
<li><p>Funciona como um intermedi√°rio que controla o acesso a um objeto
base.</p></li>
<li><p>Permite adicionar dinamicamente novas funcionalidades a uma
classe.</p></li>
<li><p>Oferece uma interface padronizada para caminhar em estruturas de
dados.</p></li>
<li><p>Permite parametrizar os algoritmos usados por uma
classe.</p></li>
<li><p>Torna uma estrutura de dados aberta a extens√µes, isto √©, permite
adicionar uma fun√ß√£o em cada elemento de uma estrutura de dados, mas sem
alterar o c√≥digo de tais elementos.</p></li>
<li><p>Permite que um objeto avise outros objetos de que seu estado
mudou.</p></li>
<li><p>Define o esqueleto de um algoritmo em uma classe base e delega a
implementa√ß√£o de alguns passos para subclasses.</p></li>
</ol>
<p>3. Dentre os padr√µes de projeto que respondeu na quest√£o (2), quais
s√£o padr√µes criacionais?</p>
<p>4. Considerando as respostas da quest√£o (2), liste padr√µes de projeto
que:</p>
<ol type="a">
<li><p>Ajudam a tornar uma classe aberta a extens√µes, sem que seja
preciso modificar o seu c√≥digo fonte (isto √©, padr√µes que colocam em
pr√°tica o princ√≠pio Aberto/Fechado).</p></li>
<li><p>Ajudam a desacoplar dois tipos de classes.</p></li>
<li><p>Ajudam a incrementar a coes√£o de uma classe (isto √©, fazem com
que a classe tenha Responsabilidade √önica).</p></li>
<li><p>Simplificam o uso de um sistema.</p></li>
</ol>
<p>5. Qual a semelhan√ßa entre Proxy, Decorador e Visitor? E qual a
diferen√ßa entre esses padr√µes?</p>
<p>6. No exemplo de Adaptador, mostramos o c√≥digo de uma √∫nica classe
adaptadora (<code>AdaptadorProjetorSamsung</code>). Escreva o c√≥digo de
uma classe semelhante, mas que adapte a interface <code>Projetor</code>
para a interface <code>ProjetorLG</code> (o c√≥digo de ambas interfaces √©
mostrado na Se√ß√£o 6.5). Chame essa classe de
<code>AdaptadorProjetorLG</code>.</p>
<p>7. Suponha uma classe base A. Suponha que queremos adicionar quatro
funcionalidades opcionais F1, F2, F3 e F4 em A. Essas funcionalidades
podem ser adicionadas em qualquer ordem, isto √©, a ordem n√£o √©
importante. Se usarmos heran√ßa, quantas subclasses de A teremos que
implementar? Se optarmos por uma solu√ß√£o por meio de decoradores,
quantas classes teremos que implementar (sem contar a classe A).
Justifique e explique sua resposta.</p>
<p>8. No exemplo de Decorador, mostramos o c√≥digo de um √∫nico decorador
(<code>ZipChannel</code>). Escreva o c√≥digo de uma classe semelhante,
mas que imprima a mensagem a ser transmitida ou recebida no console.
Chame essa classe decoradora de <code>LogChannel</code>.</p>
<p>9. Dado o c√≥digo abaixo de uma classe <code>Subject</code> (do padr√£o
Observador):</p>
<pre><code>interface Observer {
  public void update(Subject s);
}

class Subject {

  private List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;();

  public void addObserver(Observer observer) {
    observers.add(observer);
  }

  public void notifyObservers() {
    (A)
  }

}</code></pre>
<p>Implemente o c√≥digo de <code>notifyObservers</code>, comentado com um
(A) acima.</p>
<p>10. Suponha a API de Java para E/S. Suponha que para evitar o que
chamamos de paternite, voc√™ fez a uni√£o das classes
<code>FileInputStream</code> e <code>BufferedInputStream</code> em uma
√∫nica classe. Como discutimos na Se√ß√£o 6.13, o mecanismo de buffer ser√°
ativado por <em>default</em> na classe que voc√™ criou. Por√©m, como voc√™
tornaria poss√≠vel desativar buffers nessa nova classe, caso isso fosse
necess√°rio?</p>
<p>11. Suponha o exemplo de Visitor que usamos na Se√ß√£o 6.11.
Especificamente, suponha o seguinte c√≥digo, mostrado no final da
se√ß√£o.</p>
<pre><code>PrintVisitor visitor = new PrintVisitor();

foreach(Veiculo veiculo: listaDeVeiculosEstacionados) {
  veiculo.accept(visitor);
}</code></pre>
<p>Suponha que <code>listaDeVeiculosEstacionados</code> armazene tr√™s
objetos: <code>umCarro</code>, <code>umOnibus</code> e
<code>umOutroCarro</code>. Desenhe um diagrama de sequ√™ncia UML que
mostre os m√©todos executados por esse trecho de c√≥digo (suponha que ele
√© executado por um objeto <code>main</code>).</p>
<p> </p>
<p>12. Em uma entrevista dada ao site InformIT, em 2009, por ocasi√£o dos
15 anos do lan√ßamento da primeira edi√ß√£o do GoF, tr√™s dos autores do
livro mencionaram que ‚Äî se tivessem que lan√ßar uma segunda edi√ß√£o do
trabalho ‚Äî provavelmente manteriam os padr√µes originais e incluiriam
alguns novos, que se tornaram comuns desde o lan√ßamento da primeira
edi√ß√£o, em 1994. Um dos novos padr√µes que eles mencionaram na entrevista
√© chamado de <strong>Null Object</strong>. Estude e explique o
funcionamento e os benef√≠cios desse padr√£o de projeto. Para isso, voc√™
vai encontrar diversos artigos na Web. Mas se preferir consultar um
livro, uma boa refer√™ncia √© o Cap√≠tulo 25 do livro <em>Agile Principles,
Patterns, and Practices in C#</em>, de Robert C. Martin e Micah Martin.
Ou ent√£o o refactoring chamado <q>Introduce Null Object</q> do livro de
Refactoring de Martin Fowler.</p>
<h2 class="unnumbered">Perguntas Frequentes</h2>
<p>Veja tamb√©m o <a href="./faq/padroes-faq.html">FAQ</a> deste cap√≠tulo.</p>
<button onclick="darkMode()">Modo noturno</button>

<script>
function darkMode() {
   var element = document.body;
   element.classList.toggle("dark-mode");
}
</script>

</div>
</div>
</div>

<footer>
Direitos autorais reservados. Vers√£o para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/YhKNRZjkHu7ASc7M8">formul√°rio</a>.
</footer>
</body>
</html>
