<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Domain-Driven Design (DDD): Um Resumo – Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    q { quotes: "“" "”" "‘" "’"; }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RGYNKH464F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-RGYNKH464F');
  </script>

  <style>
  .dark-mode {
    background-color: black;
    color: white;
  }
  .dark-mode code {
    background-color: black;
    color: white;
  }    
  </style>

  <link rel="shortcut icon" type="image/x-icon" href="https://engsoftmoderna.info/figs/favicon.ico">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/mini-default.min.css">

  <link rel="stylesheet" href="https://engsoftmoderna.info/helper/engsoftmoderna.css">

  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-10 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">
<img src="https://engsoftmoderna.info/figs/capa/capa-3d.jpg"></a>
</p>

<p>
<a href="https://engsoftmoderna.info">Página principal do livro</a>
</p>

<p>Compre na

<a href="https://www.amazon.com.br/gp/product/6500019504">Amazon</a> ou
<!--
<a href="https://www.submarino.com.br/produto/1768283036/engenharia-de-software-moderna">
      Submarino</a> ou 
<a href="https://loja.umlivro.com.br/engenharia-de-software-moderna-4778188/p">
      UmLivro</a>
-->
<a href="https://www.casasbahia.com.br/livros/InformaticaCertificacao/livrosdeinformatica/engenharia-de-software-moderna-1513074930.html">Casas Bahia</a>
</p>

<!---
<p>
Veja também nosso  
<a href="https://www.engsoftmoderna.dcc.ufmg.br">curso de extensão</a> a distância, com certificados emitidos pelo DCC/UFMG. <b>Última semana de inscrições para a Turma 11 (até 18/08/2023).</b>
</p>
---->

<p>
Veja também os cursos de extensão a distância 
<a href="https://www.engsoftmoderna.dcc.ufmg.br">Engenharia de Software Moderna</a> (48 horas) e
<a href="https://www.testesoft.dcc.ufmg.br">Teste de Software</a> (20 horas), oferecidos pelo DCC/UFMG. </p>


<!---
<p>
Veja também nosso <a href="https://engsoftmoderna.info/curso">curso de extensão</a> a distância, com certificados emitidos pelo DCC/UFMG. 
</p>
--->
<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="1" id="domain-driven-design-ddd-um-resumo"><span
class="header-section-number">1</span> Domain-Driven Design (DDD): Um
Resumo</h1>
<blockquote>
<p><em>The heart of software is its ability to solve domain-related
problems for its user.</em> – Eric Evans</p>
</blockquote>
<h2 data-number="1.1" id="introdução"><span
class="header-section-number">1.1</span> Introdução</h2>
<p>Domain-Driven Design (DDD) é um conjunto de princípios para projeto
de software, organizados e sistematizados em 2003, por Eric Evans, em um
livro com o mesmo nome.</p>
<p>Os princípios defendidos por DDD têm, no seu conjunto, um objetivo
central: permitir o desenvolvimento de sistemas cujo design é centrado
em conceitos próximos e alinhados com um domínio de negócio.</p>
<p>O <strong>domínio</strong> de um sistema consiste da área e problema
de negócio que ele pretende resolver. Neste artigo, para explicar DDD,
vamos usar como exemplo um sistema para gerenciar uma biblioteca. Logo,
esse problema – gerenciamento de bibliotecas – constitui o domínio do
nosso sistema de exemplo.</p>
<p>DDD defende que os <strong>desenvolvedores</strong> devem ter um
profundo conhecimento do domínio do sistema que eles desenvolvem. Esse
conhecimento deve ser obtido por meio de conversas e discussões
frequentes com <strong>especialistas no domínio</strong> (ou no
negócio). Portanto, o design do sistema deve ser norteado para atender
ao seu domínio. E não, por exemplo, para se moldar a uma determinada
tecnologia de programação. Em suma, o design é dirigido pelo domínio, e
não por frameworks, arquiteturas, linguagens de programação, etc.</p>
<p>DDD defende que a separação entre domínio e tecnologia deve ser
promovida e expressa na arquitetura do sistema. Para tanto, padrões como
Arquitetura em Camadas (estudado no <a
href="https://engsoftmoderna.info/cap7.html#arquitetura-em-camadas">Capítulo
7</a>), Arquitetura Limpa (tratado neste outro <a
href="https://engsoftmoderna.info/artigos/arquitetura-limpa.html">artigo
didático</a>) ou Arquitetura Hexagonal (também coberto em um <a
href="https://engsoftmoderna.info/artigos/arquitetura-hexagonal.html">artigo</a>)
podem ser usados.</p>
<p>Antes de avançarmos, é importante mencionar que DDD se sobressai
quando é usado em sistemas para domínios complexos, cujas regras de
negócio são mais difíceis de serem imediatamente entendidas e
implementadas pelos desenvolvedores.</p>
<h2 data-number="1.2" id="linguagem-ubíqua"><span
class="header-section-number">1.2</span> Linguagem Ubíqua</h2>
<p><strong>Linguagem Ubíqua</strong> (ou <strong>Linguagem
Onipresente</strong>) é um conceito central de DDD. Ela consiste de um
conjunto de termos que devem ser plenamente entendidos tanto por
especialistas no domínio (usuários do sistema) como por desenvolvedores
(implementadores do sistema).</p>
<p>Para um projeto de software dar certo, DDD defende que esses dois
papéis – especialistas no domínio e desenvolvedores – devem falar a
mesma língua, que vai constituir a chamada Linguagem Ubíqua do sistema.
Essa ideia é ilustrada na seguinte figura:</p>
<figure>
<img src="./figs/linguagem-onipresente.svg" style="width:80.0%"
alt="A linguagem ubíqua representa o conhecimento compartilhado entre especialistas do negócio e desenvolvedores." />
<figcaption aria-hidden="true">A linguagem ubíqua representa o
conhecimento compartilhado entre especialistas do negócio e
desenvolvedores.</figcaption>
</figure>
<p>A figura deixa claro que existem termos que só os especialistas de
domínio conhecem. Já outros termos, de cunho tecnológico, são do
conhecimento apenas dos desenvolvedores. Porém, existe um conjunto de
termos que devem ser do conhecimento de ambos, os quais formam a
Linguagem Ubíqua do sistema.</p>
<p>Os termos da Linguagem Ubíqua são usados com dois propósitos:</p>
<ul>
<li><p>Para possibilitar uma comunicação fluida entre desenvolvedores e
especialistas no domínio.</p></li>
<li><p>Para nomear entidades do código do sistema, como classes,
métodos, atributos, pacotes, módulos, tabelas de bancos de dados, rotas
de APIs, etc.</p></li>
</ul>
<p>Além de clarificar o significado dos termos da linguagem ubíqua, é
importante que se definam os <strong>relacionamentos</strong> e
<strong>associações</strong> que existem entre eles.</p>
<p><strong>Exemplo</strong>: no nosso sistema de bibliotecas, a
Linguagem Ubíqua inclui termos como os seguintes:</p>
<blockquote>
<p>Livro, Exemplar, ISBN, Bibliotecária, Usuário, Acervo, Reserva,
Empréstimo, Multa, Catálogo</p>
</blockquote>
<p>Por outro lado, alguns termos são de domínio apenas dos
desenvolvedores, tais como proxy, observadores, cache, camadas, rotas,
dentre outros. Existem ainda termos que são do conhecimento apenas de
bibliotecárias, como certos formatos para definição de ISBNs, que não
são usados no Brasil.</p>
<p>Devemos definir também os relacionamentos e associações entre esses
termos, como exemplificado a seguir:</p>
<ul>
<li>Um <code>Livro</code> pode ter um ou mais
<code>Exemplares</code>.</li>
<li>Uma <code>Reserva</code> pode ser feita para no máximo três
<code>Livros</code>.</li>
<li>Existem três tipos de <code>Usuário</code>: <code>Aluno</code>,
<code>Professor</code> e <code>UsuárioExterno</code>.</li>
<li>O <code>Acervo</code> da biblioteca é formado por um conjunto de
<code>Livros</code>.</li>
</ul>
<p>Para documentar esses relacionamentos pode ser usado um
<strong>Diagrama de Classes</strong> de UML, conforme estudamos no <a
href="https://engsoftmoderna.info/cap4.html#diagrama-de-classes">Capítulo
4</a>. No entanto, esse diagrama pode ser simples e leve. Ele não
precisa, por exemplo, incluir todos os atributos e métodos de cada
classe.</p>
<h2 data-number="1.3" id="objetos-de-domínio"><span
class="header-section-number">1.3</span> Objetos de Domínio</h2>
<p>DDD foi proposto pensando em sistemas implementados em linguagens
orientadas a objetos. Então, quando se define o design desses sistemas,
alguns tipos importantes de objetos se destacam. Dentre eles, DDD lista
os seguintes:</p>
<ul>
<li>Entidades</li>
<li>Objetos de Valor</li>
<li>Serviços</li>
<li>Agregados</li>
<li>Repositórios</li>
</ul>
<p>Esses tipos de objetos de domínio devem ser entendidos como as
<q>ferramentas conceituais</q> que um projetista deve lançar mão para
projetar com sucesso um determinado sistema. Por isso, eles são chamados
também dos <strong>building blocks</strong> de DDD. Iremos comentar
sobre cada um deles a seguir.</p>
<h3 class="unnumbered" id="entidades-e-objetos-de-valor">Entidades e
Objetos de Valor</h3>
<p>Uma <strong>entidade</strong> é um objeto que possui uma identidade
única, que o distingue dos demais objetos da mesma classe. Por exemplo,
cada <code>Usuário</code> da nossa biblioteca é uma entidade, cujo
identificador é o seu número de matrícula na universidade.</p>
<p>Por outro lado, <strong>objetos de valor</strong> (<em>value
objects</em>) não possuem um identificador único. Assim, eles são
caracterizados apenas por seu estado, isto é, pelos valores de seus
atributos. Por exemplo, o <code>Endereço</code> de um
<code>Usuário</code> da biblioteca é um objeto de valor. Veja que se
dois <code>Endereços</code> tiverem exatamente os mesmos valores para
<code>rua</code>, <code>número</code>, <code>cidade</code>,
<code>CEP</code>, etc, eles serão idênticos.</p>
<p>Outros exemplos de objetos de valor incluem: <code>Moeda</code>,
<code>Data</code>, <code>Fone</code>, <code>Email</code>,
<code>Hora</code>, <code>Cor</code>, etc.</p>
<p><strong>Por que distinguir entre entidades e objetos de
valor?</strong> Entidades são objetos mais importantes e devemos, por
exemplo, projetar com cuidado como eles serão persistidos e depois
recuperados de um banco de dados. Devemos também tomar cuidado com o
ciclo de vida de entidades. Por exemplo, podem existir regras que
governam a criação e remoção de entidades. No caso da nossa biblioteca,
não se pode remover um <code>Usuário</code> se ele tiver um
<code>Empréstimo</code> pendente.</p>
<p>Já objetos de valor são mais simples. E também eles devem ser
<strong>imutáveis</strong>, ou seja, uma vez criados, não deve ser
possível alterar seus valores internos. Por exemplo, para alterar o
<code>Endereço</code> de um <code>Usuário</code> devemos abandonar o
objeto antigo e criar um objeto com o <code>Endereço</code> novo. Os
benefícios de objetos imutáveis já foram discutidos no <a
href="https://engsoftmoderna.info/cap9.html#objetos-mut%C3%A1veis">Capítulo
9</a>.</p>
<p>É interessante mencionar também que, recentemente, algumas linguagens
de programação passaram a oferecer suporte sintático para implementação
de objetos de valor. Por exemplo, nas versões mais recentes de Java,
eles podem ser implementados por meio de <a
href="https://docs.oracle.com/en/java/javase/16/language/records.html">records</a>.</p>
<h3 class="unnumbered" id="serviços">Serviços</h3>
<p>Existem operações importantes do domínio que não se encaixam em
entidades e objetos de valor. Assim, o ideal é criar objetos específicos
para implementar essas operações. No jargão de DDD, esses objetos são
chamados de <strong>serviços</strong>. Em alguns sistemas, é comum ver
esses objetos sendo chamados também de gerenciadores ou
controladores.</p>
<p>A assinatura das operações de um objeto de serviço pode incluir
entidades e objetos de valor. No entanto, objetos de serviço não devem
possuir estado, isto é, eles devem ser <strong>stateless</strong>. Por
isso, eles não costumam ter atributos, mas apenas métodos.</p>
<p>Serviços normalmente são implementados como
<strong>singletons</strong>, ou seja, possuem uma única instância
durante a execução do sistema. Mais detalhes sobre esse padrão de
projeto no <a
href="https://engsoftmoderna.info/cap6.html#singleton">Capítulo
6</a>.</p>
<p><strong>Exemplo</strong>: no nosso sistema de bibliotecas, podemos
ter um serviço que implementa as seguintes operações:</p>
<pre><code>class ServicoDeEmprestimo {
  ...
  void emprestarLivro(Usuario, Livro) {...}
  void devolverLivro(Usuario, Livro)  {...}
  ...
}  </code></pre>
<p>Na primeira operação, realiza-se o empréstimo de um
<code>Livro</code> para um certo <code>Usuário</code>. Na segunda
operação, um <code>Usuário</code> devolve um <code>Livro</code> que ele
tenha sob empréstimo.</p>
<p>Ambas as operações não são específicas nem de <code>Usuário</code>,
nem de <code>Livro</code>. Por isso, DDD recomenda criar um objeto de
serviço para acomodá-las.</p>
<h3 class="unnumbered" id="agregados">Agregados</h3>
<p><strong>Agregados</strong> (<em>aggregates</em>) são coleções de
entidades e objetos de valor. Ou seja, algumas vezes não faz sentido
raciocinar sobre entidades e objetos de valor de forma individual. Em
vez disso, temos que pensar em grupos de objetos para ter uma visão
consistente com o domínio que estamos modelando.</p>
<p>Um agregado possui um objeto raiz, que deve ser uma entidade.
Externamente, o agregado é acessado a partir dessa raiz. A raiz, por sua
vez, referencia os objetos internos do agregado. Porém, esses objetos
internos não devem ser visíveis para o resto do sistema, ou seja, apenas
a raiz pode referenciá-los.</p>
<p>Como formam uma unidade coerente, agregados são persistidos em
conjunto em bancos de dados. A deleção de um agregado, da memória
principal ou de um banco de dados, implica na deleção da sua raiz e de
todos os objetos internos.</p>
<p>Como eles são objetos mais complexos e com objetos internos, pode ser
interessante implementar métodos especificamente para criação de
agregados, os quais são chamados de <strong>fábricas</strong>. Ou seja,
tais métodos são implementações do padrão de projeto de mesmo nome.</p>
<p><strong>Exemplo</strong>: No sistema de bibliotecas, um
<code>Empréstimo</code> possui um <code>Usuário</code> (que é uma
entidade) e uma lista de <code>ItemEmpréstimo</code>. Cada
<code>ItemEmpréstimo</code> contém informações sobre um certo
<code>Livro</code> que foi emprestado.</p>
<p>Logo, <code>Empréstimo</code> e <code>ItemEmpréstimo</code> formam um
agregado, como mostrado na figura. Isto é, uma entidade única do ponto
de vista conceitual. <code>Empréstimo</code> é a raiz do agregado e
<code>ItemEmpréstimo</code> é a classe dos objetos internos, os quais
não podem ser manipulados sem passar antes pela raiz.</p>
<figure>
<img src="./figs/ddd-agregado.png" style="width:35.0%"
alt="Exemplo de agregado" />
<figcaption aria-hidden="true">Exemplo de agregado</figcaption>
</figure>
<p>Observe que <code>ItemEmpréstimo</code> referencia
<code>Livro</code>, porém essa última classe não faz parte do agregado,
pois seus objetos têm vida própria, isto é, eles existem
independentemente de estarem emprestados ou não.</p>
<h3 class="unnumbered" id="repositórios">Repositórios</h3>
<p>Para implementar certos serviços do domínio precisamos antes obter
referências para determinados objetos.</p>
<p>Por exemplo, suponha um serviço que lista os <code>Empréstimos</code>
realizados por um <code>Usuário</code>. Para implementá-lo, não podemos
assumir que todos os agregados do tipo <code>Empréstimo</code> estão na
memória principal. Na verdade, em qualquer sistema real, eles estão
armazenados em um banco de dados.</p>
<p>Um <strong>repositório</strong> é então um objeto usado para
recuperar outros objetos de domínio de um banco de dados. Seu objetivo é
prover uma abstração que blinde os desenvolvedores de preocupações
relacionadas com acesso a bancos de dados. Normalmente, repositórios são
criados para recuperar entidades ou agregados.</p>
<p>Em outras palavras, um repositório oferece uma abstração para o banco
de dados usado pelo sistema e, assim, permite que os desenvolvedores
continuem focados no domínio, em vez de ter sua atenção desviada, em
certos momentos, para uma tecnologia de armazenamento de dados. Em
termos mais concretos, um repositório permite manipular objetos de
domínio como se eles fossem listas (ou coleções) armazenadas na memória
principal. A implementação interna do repositório cuida de ler e salvar
essas listas no banco de dados.</p>
<p><strong>Exemplo:</strong> No sistema de bibliotecas, existe um
repositório com métodos para recuperar <code>Empréstimos</code>
armazenados em um banco de dados:</p>
<pre><code>class RepositorioDeEmprestimos {
  List&lt;Emprestimo&gt; findEmprestimosDeUsuario(Usuario u) {...}
  List&lt;Emprestimo&gt; findEmprestimosPorData(Data inicio, Data fim) {...}
  List&lt;Emprestimo&gt; findEmprestimosVencidos() {...}
  ...   
}</code></pre>
<p>Além dos métodos <code>find*</code>, um repositório pode implementar
métodos para salvar, atualizar e remover objetos:</p>
<pre><code>class RepositorioDeEmprestimos {

  // métodos find* (veja acima)
  
  void salvar(Emprestimo e) {...}
  void atualizar(Emprestimo e) {...}
  void remover(Emprestimo e) {...} 
}</code></pre>
<h2 data-number="1.4" id="contextos-delimitados"><span
class="header-section-number">1.4</span> Contextos Delimitados</h2>
<p>Com o tempo, sistemas de software ficam mais complexos e abrangentes.
Por isso, é irrealista imaginar que sistemas de organizações grandes e
complexas vão possuir um modelo de domínio único e baseado na mesma
linguagem ubíqua.</p>
<p>Em vez disso, é natural que tais organizações tenham sistemas que
atendem a usuários com perfis e necessidades diferentes, o que complica
a definição de uma linguagem ubíqua. A solução para esse problema
consiste em quebrar tais domínios complexos em domínios menores, os
quais em DDD são chamados de <strong>Contextos Delimitados</strong>
(<em>Bounded Contexts</em>).</p>
<p><strong>Exemplo:</strong> Suponha que a nossa biblioteca tenha um
setor financeiro. Esse setor tem necessidades específicas, que começam a
justificar um projeto separado, com uma linguagem própria. Por exemplo,
nesse domínio financeiro, a classe <code>Usuário</code> pode, inclusive,
ser chamada de <code>Cliente</code> e ter novos atributos.</p>
<h2 data-number="1.5" id="camada-anticorrupção"><span
class="header-section-number">1.5</span> Camada Anticorrupção</h2>
<p>Às vezes, temos que integrar sistemas que estão em contextos
delimitados diferentes. Por exemplo, um sistema A precisa usar serviços
de um sistema B, que pode inclusive ser um sistema externo, isto é, de
uma outra organização. Para evitar que A tenha que se adaptar e usar,
mesmo que parcialmente, a linguagem ubíqua de B, pode-se usar uma
<strong>Camada Anticorrupção</strong> para mediar essa comunicação.</p>
<p>Essa camada é formada por três tipos principais de classes:</p>
<ul>
<li><p>Classes de Serviço, cujos métodos serão chamados por A e que,
portanto, seguem a linguagem ubíqua desse sistema.</p></li>
<li><p><a href="https://engsoftmoderna.info/cap6.html#adaptador">Classes
Adaptadoras</a>, que convertem o modelo e os tipos de dados de B para o
modelo e tipos de dados de A. Ou seja, essas classes vão isolar
elementos próprios de B e evitar que eles cheguem até o sistema
A.</p></li>
<li><p>Uma <a
href="https://engsoftmoderna.info/cap6.html#fachada">Classe de
Fachada</a>, usada para acessar o sistema B. O papel dessa classe é
facilitar o uso de B, principalmente quando ele é um sistema legado com
uma interface complexa e antiga.</p></li>
</ul>
<p>Logo, o fluxo costuma ser o seguinte:</p>
<pre><code>Sistema A -&gt; [ Serviços -&gt; Adaptadores -&gt; Fachada ] -&gt; Sistema B</code></pre>
<p>Nesse fluxo, as classes entre colchetes constituem a Camada
Anticorrupção que foi construída para integrar os sistemas A e B.</p>
<h2 data-number="1.6" id="conclusão"><span
class="header-section-number">1.6</span> Conclusão</h2>
<p>Em um material de referência, que escreveu em 2014, Eric Evans
definiu assim DDD:</p>
<blockquote>
<p>DDD é uma abordagem para desenvolvimento de sistemas de software
complexos, em que: (1) o foco está no domínio do sistema; (2)
desenvolvedores e especialistas no negócio devem explorar esse domínio
de forma colaborativa; (3) como resultado, eles devem se comunicar
usando uma linguagem ubíqua, mas dentro de um contexto delimitado.</p>
</blockquote>
<p>A linguagem ubíqua do sistema deve ser usada também no seu código,
para nomear variáveis, parâmetros, métodos, classes, pacotes, etc.
Especificamente, um projeto DDD deve fazer uso dos seguintes tipos de
objetos principais: entidades, objetos de valor, serviços, agregados e
repositórios.</p>
<h2 class="unnumbered" id="exercícios">Exercícios</h2>
<!---
1. Marque V ou F:

   (&nbsp;&nbsp;) DDD recomenta arquitetar um sistema em camadas, incluindo uma camada focada no domínio e nas regras do negócio.

   (&nbsp;&nbsp;) Quando se usa Scrum, a linguagem ubíqua é definida apenas pelo Product Owner. 

   (&nbsp;&nbsp;) Entidades são definidas por sua identidade; objetos de valor são definidos por seus atributos.

   (&nbsp;&nbsp;) DDD recomenda que entidades implementem internamente sua própria lógica de persistência em bancos de dados.
   
   (&nbsp;&nbsp;) Objetos de valor (*value objects*) não devem possuir métodos `set*`.

   (&nbsp;&nbsp;) Apenas entidades e agregados podem possuir repositórios.

   (&nbsp;&nbsp;) DDD defende que um sistema de software complexo deve ter um modelo de domínio único, baseado na mesma linguagem ubíqua.
--->
<p>1. Para fixar os principais conceitos de DDD, responda ao seguinte <a
href="https://engsoftmoderna.info/exercicios/exvf.html#/cap/DDD">exercício</a>
de V ou F, com correção online.</p>
<p>2. Suponha que você trabalha em uma empresa que possui um aplicativo
para entrega de comida pela Internet. Você ficou responsável pelo
projeto da camada de domínio do backend desse sistema. Para isso, você
decidiu usar DDD. Descreva então:</p>
<ol type="a">
<li>Cinco termos da linguagem ubíqua do sistema</li>
<li>Três entidades</li>
<li>Três objetos de valor</li>
<li>Um agregado (incluindo o objeto raiz e seus objetos internos)</li>
<li>Dois métodos de um serviço</li>
<li>Dois métodos de um repositório</li>
</ol>
<p>Em suas respostas, basta citar os nomes que foram pedidos.</p>
<p>3. Suponha um sistema de comércio eletrônico, com as seguintes
classes <code>Pedido</code>, <code>ItensPedido</code> e
<code>Produto</code>. Desenhe um diagrama de classes que represente as
relações entre essas classes. Quais classes constituem um agregado? Qual
classe está fora do agregado e porquê?</p>
<p>4. Seja o seguinte método do sistema de bibliotecas discutido no
artigo e que usa DDD:</p>
<pre><code>void emprestarLivros(int userId, int livroId) {
  Usuario usuario = &quot;recuperar dados de userId&quot;
  Livro livro = &quot;recuperar dados de livroId&quot;
  usuario_ok = &quot;checar se usuário em dia com a biblioteca&quot;
  livro_disponivel = &quot;checar se livro tem exemplares disponíveis&quot;
  if (usuario_ok &amp;&amp; livro_disponivel)
     &quot;criar empréstimo de livro para usuario&quot;        
}
</code></pre>
<ol type="a">
<li><p>O método <code>emprestarLivro()</code> pertenceria a qual tipo de
classe de DDD?</p></li>
<li><p>Como você classificaria as classes <code>Usuario</code> e
<code>Livro</code>?</p></li>
<li><p>As operações <q>recuperar dados de usuário</q>, <q>recuperar
dados de livro</q> e <q>criar empréstimo de livro</q> pertenceriam a
qual tipo de classe?</p></li>
<li><p>Suponha que <code>Emprestimo</code> (uma classe) tenha um
conjunto de <code>ItemEmprestimo</code> (outra classe). O conjunto
dessas duas classes forma que tipo de estrutura em DDD?</p></li>
</ol>
<p>5. Depois de aprender DDD, um desenvolvedor resolveu estruturar seu
sistema, que é bastante complexo, como mostrado a seguir. Basicamente,
ele criou um pacote (ou, se preferir, um módulo ou diretório) para
agrupar os arquivos que implementam os tipos de objetos de domínio
preconizados por DDD. Essa decisão é recomendável ou não? Em outras
palavras, ela é fiel e consistente com os princípios de DDD? Justifique
sua resposta.</p>
<pre><code>   Raiz
      |__ Entidades
      |   | arquivos que implementam entidades
      |
      |__ Agregados
      |   | arquivos que implementam agregados
      |
      |__ ObjetosValor
      |   | arquivos que implementam objetos de valor
      |
      |__ Servicos
      |   | arquivos que implementam serviços
      |
      |__ Repositorios
      |  | arquivos que implementam repositórios</code></pre>
<hr />
<p>Voltar para a lista de <a href="./artigos.html">artigos</a>.</p>
<button onclick="darkMode()">Modo noturno</button>

<script>
function darkMode() {
   var element = document.body;
   element.classList.toggle("dark-mode");
}
</script>

</div>
</div>
</div>

<footer>
Direitos autorais reservados. Versão para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formulário</a>.
</footer>
</body>
</html>
